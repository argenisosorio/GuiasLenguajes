====================
Guía de GitLab by dM
====================

==========================
Como crear una GitLab Page
==========================

GitLab te permite tener una página html en un entorno de producción, basado en
algún repositorio que tengas en tu cuenta de usuario, este servicio solo permite
el despliegue de páginas html y ficheros estáticos como hojas de estilo,
javascript, jquery entre otros, lo cual significa que es ideal para mostrar
diseños de sitios web.

=========================
Habilitar una Gitlab Page
=========================

1) Entramos en algún repositorio nuestro que tenga un index.html para mostrar
como página principal.

2) Vamos a agregar un nuevo archivo al repositorio, lo podemos hacer desde la
consola de comandos o desde la interfáz, nuevo fichero que vamos a agregar a
nuestro repositorio se debe llamar .gitlab-ci.yml y su contenido sera:

pages:
  stage: deploy
  script:
  - mkdir .public
  - cp -r * .public
  - mv .public public
  artifacts:
    paths:
    - public
  only:
  - master

Hacemos un commit para guardar el nuevo archivo, subimos los cambios en el
repositorio.

3) Hay que esperar entre 2 a 5 min para que se cree la nueva página de nuestro
repositorio, luego desde la interfaz del navegador vamos a nuestro repositorio,
en el panel de la izquierda vamos a Configuración y luego a Paginas, si ya se
creo nos saldra lo siguiente en un panel:

Congratulations! Your pages are served under:

https://myuser.gitlab.io/name_my_repo

4) Ya podemos acceder a la página de GitLab de nuestro repositorio, si entramos
y da error 404 es que todavía esta procesando, intentemos 1 min después y así
hasta que esté en línea.

==========================
Guía de la wiki y markdown
==========================

Url: https://gitlab.com/help/user/markdown#wiki-specific-markdown

====================
Integración continua
====================

La integración continua (continuous integration en inglés) es una práctica de
ingeniería de software que consiste en hacer integraciones automáticas de un
proyecto lo más a menudo posible para así poder detectar fallos cuanto antes.

Entendemos por integración la compilación y ejecución de pruebas de todo un
proyecto.

El proceso suele ser: cada cierto tiempo (horas), descargarse las fuentes desde
el control de versiones (por ejemplo CVS, Git, Subversion, Mercurial o Microsoft
Visual SourceSafe) compilarlo, ejecutar pruebas y generar informes.

Para esto suelen utilizarse aplicaciones como Solano CI, Bamboo, Pipeline,
Apache Continuum, Hudson, Jenkins, GoCD, CruiseControl o Anthill (para proyectos
Java) o CruiseControl.Net, Team Foundation Build para .Net, que se encargan de
controlar las ejecuciones, apoyadas en otras herramientas como Ant o Maven
(también para proyectos Java), o Nant o MSBUILD (para .Net) que se encargan de
realizar las compilaciones, ejecutar las pruebas y realizar los informes.

A menudo la integración continua está asociada con las metodologías de
programación extrema y desarrollo ágil.

Ventajas
========

-Los desarrolladores pueden detectar y solucionar problemas de integración de
forma continua, evitando el caos de última hora cuando se acercan las fechas de
entrega.

-Disponibilidad constante de una versión para pruebas, demos o lanzamientos
anticipados.

-Ejecución inmediata de las pruebas unitarias.

-Monitorización continua de las métricas de calidad del proyecto.

Fuentes
=======

-https://es.wikipedia.org/wiki/Integraci%C3%B3n_continua

=====
CI/CD
=====

En ingeniería de software, CI/CD o CICD generalmente refiere a las prácticas
combinadas de integración continua y entrega continua (también conocida como
despliegue continuo).

Contamos con herramientas para esto en GitLab por ejemplo.

Fuentes
=======

-https://es.wikipedia.org/wiki/CI/CD

================
Entrega continua
================

Entrega continua (continuous delivery en inglés) es un enfoque de la ingeniería
del software en que los equipos de desarrollo producen software en ciclos
cortos, asegurando que el software puede ser liberado en cualquier momento, de
forma confiable.

Apunta a la construcción, prueba, y liberación del software de forma más rápida
y más frecuente. Este enfoque ayuda en la reducción del costo, tiempo, y riesgo
de la liberación de versiones a través de la liberación de versiones más
incrementales a aplicaciones en producción. Un proceso directo y repetible de
liberación es importante para una entrega continua.

Etapas
======

-Automatización de la compilación e integración continua: Esta etapa consta de
la creación de archivos binarios a partir del código fuente. A medida que los
desarrolladores implementan nuevas funciones, estas son integradas al código
central, compiladas, y probadas.

-Automatización de pruebas: En esta etapa se prueba rigurosamente la nueva
versión de aplicación, para asegurar que cumple con todos los requerimientos de
calidad del sistema.

-Automatización de implementación: Luego que las etapas anteriores fueron
verificadas, se puede implementar la nueva versión en el ambiente de producción.

Esta implementación se realiza de forma automática, dejando disponibles las
nuevas funcionalidades al usuario, en solo unos minutos.

Fuentes
=======

-https://es.wikipedia.org/wiki/Entrega_continua

=================================================================
Cómo recibir notificaciones del repositorio de GitLab en Telegram
=================================================================

1) Añadimos como participante del grupo a @gitlab_bot, este último dejo de
funcionar por lo cual está la opción de añadir a @GitLabX_BOT que es lo mismo.

2) Al agregarlo al grupo, llega un mensaje como este:

Hi here! To setup notifications for this chat your GitLab project(repo), open
Settings -> Web Hooks and add this URL:
https://integram.org/gitlab/cQgO-Szntu4

ó

Hi here! To setup notifications for this chat your GitLab project(repo),
open Settings -> Web Hooks and add this URL:
http://lab6.btech.id:9876/gitlab/cAVLqxuHaZ4

3) Nos vamos al repositorio de Gitlab, nos vamos a la parte cd Configuración >
Webhooks y en el campo url pegamos la url que nos pasó el bot por el chat de
telegram.

4) Le damos click a Add webhook y listo, ya solo resta probar algún eventos
para verificar que esté funcionando.

========================
El archivo gitlab-ci.yml
========================

El archivo .gitlab-ci.yml sirve para configurar el comportamiento de Gitlab CI
en cada proyecto. En el archivo define la estructura y el orden de los pipelines
y determina qué ejecutar con el Gitlab runner y qué decisiones tomar cuando
condiciones específicas se cumplen (como cuando un proceso falla o termina
exitosamente).

Fuente
======

https://platzi.com/clases/1526-gitlab/19299-gitlab-ciyml/

================================
Caso casi práctico GitlLab CI/CD
================================

Vamos a suponer que tenemos un API de Node que trae una lista de libros de una
base de datos. Un escenario bastante sencillo y práctico, para no complicar
mucho las cosas.

A partir de ahora, podemos crear una tubería (pipeline a partir de ahora), que
empuje nuestro código en 3 fases: construcción, pruebas y entrega. Recordemos
que un pipeline es un grupo de pasos que son agrupados bajo características
similares. Con estas fases o etapas, nuestro pipeline es definido en 3 tipos:

1: El Pipeline del proyecto (Project Pipeline).
2: El Pipeline de integración continua.
3: El Pipeline de entrega.

El pipeline del proyecto instala dependencias, corre los linters y cualquier
script que tenga que ver con código. El pipeline de integración continua corre
pruebas automatizadas y construye versiones distribuidas del código.

Finalmente, el pipeline de entrega, entrega el código a un ambiente de un
proveedor de nube designado.

El esquema resultante resumido sería el siguiente:

A) Build
  i. Install NPM Dependencies
  ii. Run ES-Linter
  iii. Run Code-Minifier
B) Test
  i. Run unit
  ii. Run compile
C) Deploy
  i. Production
    1) Launch EC2 instance on AWS
  ii. Staging
  iii.
    1) Launch on local development server

En esta jerarquía, los tres componentes son considerados tres diferentes
pipelines. Las partes importantes (build, test y deploy) son etapas (stages) y
cada parte debajo de estas secciones son trabajos.

Para usar GitLab CI/CD, creamos un archivo con nombre “.gitlab-ci.yml” en la
raíz del proyecto de nuestro repositorio de GitLab y agregamos el siguiente
código yaml:

image: node:10.5.0

stages:
  - build
  - test
  - deploy

before_scripts
  - npm install

Todo lo anterior es un ejemplo, simplemente el archivo describe instrucciones
para ejecutar de manera secuencial.

Fuente
======

https://www.icm.es/2020/07/17/caso-practico-gitlab-ci-cd/

=======================================================================
Recibir notificaciones en telegram de las acciones de un repo con CI/CD
=======================================================================

1- Primero debes crear un nuevo bot. Abre Telegram y busca el bot "BotFather".

2- Inicia una conversación con BotFather y envíale el comando "/newbot".

3- Sigue las instrucciones que te dará BotFather. Primero, debes proporcionarle
un nombre para tu bot. Luego, debes proporcionarle un nombre de usuario que
termine en "bot". Por ejemplo, "myawesomebot".

BotFather te proporcionará un token de acceso para tu bot. Guárdalo en un lugar
seguro, ya que lo necesitarás más adelante para enviar solicitudes a la API de
Telegram.

Ejemplo:

Ya estando en el chat con BotFather, escribimos

/newbot

BotFather:

Alright, a new bot. How are we going to call it? Please choose a name for your bot.

prueba

BotFather:

Good. Now let's choose a username for your bot. It must end in `bot`. Like this,
for example: TetrisBot or tetris_bot.

pruebabot

BotFather:

Done! Congratulations on your new bot. You will find it at t.me/pruebabot. You
can now add a description, about section and profile picture for your bot, see
/help for a list of commands. By the way, when you've finished creating your
cool bot, ping our Bot Support if you want a better username for it. Just make
sure the bot is fully operational before you do this.

Use this token to access the HTTP API:
xxxxxxxxxx:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
Keep your token secure and store it safely, it can be used by anyone to control
your bot.

For a description of the Bot API, see this page: https://core.telegram.org/bots/api

-----

¡Listo! Ahora tienes un bot de Telegram. Puedes usar el token de acceso para
enviar solicitudes a la API de Telegram y crear las funcionalidades que deseas
para tu bot. Por ejemplo, puedes configurar el bot para enviar mensajes
automáticos, responder a comandos o interactuar con otros usuarios de Telegram.

4- Ahora debemos obtener el id que es único único de un grupo o canal en el cual
queremos recibir las notificaciones, para obtenerlo agregue temporalmente el bot
https://telegram.me/itpp_myid_bot al grupo o canal, este te devolvera el id del
grupo. normalmente, es un entero negativo.

5- Ahora vamos al repo que queremos que notifique cuando tenga interacciones Y
creamos en la raíz un archivo con nombre .gitlab-ci.yml, el contenido de ese
archivo será:

-----

stages:
  - notify

telegram_notification:
  stage: notify
  image: curlimages/curl:latest
  script:
    - export MESSAGE="Se ha realizado un nuevo push, el mensaje del commit es: '$CI_COMMIT_MESSAGE'"
    - curl -s -X POST https://api.telegram.org/botTELEGRAM_TOKEN/sendMessage -d chat_id=XXXX -d text="${MESSAGE}" >> /dev/null
  only:
    - master

-----

Donde secrets.TELEGRAM_TOKEN es el token secreto de tu bot y
XXXX es el id del chat que te dio el bot itpp_myid_bot.

Para probarlo, simplemente hacemos un nuevo push al repositorio y este nos
debería notificar en telegram.

Desde la sección pipelines de nuestro repositorio podremos ver las ejecuciones
realizadas del archivo .gitlab-ci.yml.

Con más detalles:

stages:
  - notify

telegram_notification:
  stage: notify
  image: curlimages/curl:latest
  script:
    - export MESSAGE="Nuevo push a la rama: $CI_COMMIT_REF_NAME, commit '$CI_COMMIT_MESSAGE' > $CI_PROJECT_URL/-/commit/$CI_COMMIT_SHA"
    - curl -s -X POST https://api.telegram.org/botXXXX/sendMessage -d chat_id=XXXX -d text="${MESSAGE}" >> /dev/null
  only:
    - master

Crear variables en nuestro repositorio para CI/CD
==================================================

Configurtación > CI/CD > Variables > Añadir variable, agregamos una nueva con
clave: BotTELEGRAM_TOKEN y valor, el token de nuestro bot.

Para utilizar la variable BotTELEGRAM_TOKEN en la línea de comando que mencionas
debes sustituir <your_bot_token> por $BotTELEGRAM_TOKEN, de la siguiente manera:

- curl -s -X POST https://api.telegram.org/bot$BotTELEGRAM_TOKEN/sendMessage -d chat_id=<your_chat_id> -d text="${MESSAGE}" >> /dev/null

De esta forma, la variable BotTELEGRAM_TOKEN se expandirá en su valor
correspondiente en la línea de comando.

Recuerda que para que esto funcione, debes haber definido previamente la
variable BotTELEGRAM_TOKEN en tu archivo .gitlab-ci.yml o en la sección
"Variables" de tu proyecto en GitLab, tal como lo hemos mencionado
anteriormente.

Lo mismo se puede hacer con el ID del chat, declarar la variable CHAT_ID, agregar
su valor con usarla en el comando con $CHAT_ID.

Ahora agregamos el autor del commit y también que notifique de cambios en la
rama dev:

stages:
  - notify

telegram_notification:
  stage: notify
  image: curlimages/curl:latest
  script:
    - export MESSAGE="Nuevo push de $CI_COMMIT_AUTHOR en la rama $CI_COMMIT_REF_NAME, commit '$CI_COMMIT_MESSAGE' > $CI_PROJECT_URL/-/commit/$CI_COMMIT_SHA"
    - curl -s -X POST https://api.telegram.org/bot$BotTELEGRAM_TOKEN/sendMessage -d chat_id=$CHAT_ID -d text="${MESSAGE}" >> /dev/null
  only:
    - master
    - dev

Para que notifique los cambios de dev o de cualquier otra rama esta debe ser una
rama protegida.

-----

Obteniendo solo el Nombre y Apellido del auto y no el correo:

stages:
  - notify

telegram_notification:
  stage: notify
  image: curlimages/curl:latest
  script:
    - export MESSAGE="Nuevo push en el repo $CI_PROJECT_URL de $(echo $CI_COMMIT_AUTHOR | cut -d' ' -f1,2) en la rama $CI_COMMIT_REF_NAME, commit $CI_COMMIT_MESSAGE -> $CI_PROJECT_URL/-/commit/$CI_COMMIT_SHA"
    - curl -s -X POST https://api.telegram.org/bot$BotTELEGRAM_TOKEN/sendMessage -d chat_id=$CHAT_ID -d text="${MESSAGE}" >> /dev/null
  only:
    - master

Recomendada:

telegram_notification:
  stage: notify
  image: curlimages/curl:latest
  script:
    - export MESSAGE="$(echo $CI_COMMIT_AUTHOR | cut -d' ' -f1,2) pusheo a la rama $CI_COMMIT_REF_NAME | $CI_COMMIT_MESSAGE -> $CI_PROJECT_URL/-/commit/$CI_COMMIT_SHA"
    - curl -s -X POST https://api.telegram.org/bot$BotTELEGRAM_TOKEN/sendMessage -d chat_id=$CHAT_ID -d text="${MESSAGE}" >> /dev/null
  only:
    - master

========================
Rama protegida en GitLab
========================

Una rama protegida en GitLab es una rama en un repositorio de Git que ha sido
configurada para tener restricciones adicionales para evitar cambios no
autorizados. Esta configuración se implementa para prevenir modificaciones
accidentales o no autorizadas en ramas importantes del repositorio, como la rama
"master" o ramas de desarrollo principales.

Cuando una rama está protegida en GitLab, se aplican ciertas restricciones y
reglas que generalmente incluyen:

No permitir push directo: Los usuarios no pueden hacer push directamente a la
rama protegida. Los cambios deben enviarse mediante merge requests (también
conocidos como "pull requests" en otros sistemas de control de versiones).

Revisión de cambios (Code Review): Antes de que los cambios se incorporen a la
rama protegida, al menos una revisión de código (code review) aprobada es
necesaria. Otros miembros del equipo deben revisar y aprobar los cambios antes
de que se fusionen con la rama protegida.

Requerir pipelines exitosos: Antes de que los cambios se fusionen con la rama
protegida, se exige que los pipelines de CI/CD sean exitosos. Esto garantiza que
los cambios cumplan con las pruebas automatizadas antes de integrarlos en la
rama protegida.

Restricciones adicionales: GitLab permite configurar restricciones adicionales
según las necesidades del proyecto, como requerir que solo ciertos usuarios o
grupos tengan permiso para aprobar merge requests en la rama protegida.

Las ramas protegidas en GitLab son una medida de seguridad importante para
garantizar la calidad y la integridad del código en el repositorio. Al
restringir la posibilidad de cambios directos en ramas importantes, se minimiza
el riesgo de errores y problemas en el código base, y se fomenta un enfoque
colaborativo a través de revisiones y pruebas antes de la incorporación de
cambios a la rama principal del repositorio.

Fuente
======

ChatGPT

============================================================================
Hacer push a un repositorio gitlab pasando usuario y contraseña directamente
============================================================================

$ git push https://your-username:your-token@gitlab.com/usuario/repositorio.git master

Ejemplo:

$ git push https://pepeperez:xyz1233212zyx@gitlab.com/pepeperez/mi_repo.git master

Fuente
======

ChatGPT

====================================================
En un merge request que es la opción Squash commits?
====================================================

Squash y fusión

Al trabajar en una rama, es común realizar pequeños commits que describen el
proceso de desarrollo de una mejora o corrección. Si bien estos commits son
útiles durante el desarrollo, pueden generar un historial de Git desordenado una
vez finalizada la tarea. Para mantener un historial más limpio y claro en el
repositorio, se recomienda utilizar la estrategia de squash y fusión. Esta
técnica combina todos los commits relacionados en uno solo, simplificando el
historial y facilitando su revisión sin perder el contexto de los cambios
realizados.

Fuente
======

https://docs.gitlab.com/ee/user/project/merge_requests/squash_and_merge.html

====================
Claves SSH en GitLab
====================

Las claves SSH le permiten establecer una conexión segura entre su computadora y
GitLab. Las huellas digitales SSH verifican que el cliente se conecta al host
correcto.

SSH utiliza dos claves, una clave pública y una clave privada.

-La clave pública se puede distribuir.
-La clave privada debe estar protegida.

Para usar SSH para comunicarse con GitLab, necesita

-El cliente OpenSSH, que viene preinstalado en GNU/Linux, macOS y Windows 10.
-Versión SSH 6.5 o posterior. Las versiones anteriores utilizaban una firma MD5, que no es segura.

Para ver la versión de SSH instalada en su sistema, ejecute:

$ ssh -V

Tipos de claves SSH compatibles
===============================

Para comunicarse con GitLab, puede utilizar los siguientes tipos de claves SSH:

ED25519
ED25519_SK
ECDSA_SK
RSA
ECDSA (Como se señala en Criptografía práctica con Go , los problemas de
seguridad relacionados con DSA también se aplican a ECDSA).

Generarlas las llaves ssh en Debian
===================================

En Debian, el comando estándar es ssh-keygen. Sigue estos pasos:

Abre la terminal y ejecuta:

$ ssh-keygen -t ed25519 -C "tu_correo@ejemplo.com"

(Usamos ed25519 porque es el algoritmo más moderno, rápido y seguro actualmente).

Configuración:

-Te pedirá una ruta para guardar el archivo. Presiona Enter para usar la ruta
por defecto (/home/usuario/.ssh/id_ed25519).

-Te pedirá una passphrase (contraseña para la clave). Es opcional, pero muy
recomendable: añade una capa de seguridad extra si alguien roba tu archivo de
clave privada.

Tus claves se habrán creado en la carpeta oculta .ssh, para ver tus claves:

$ ls .ssh/

id_ed25519
id_ed25519.pub (Pública: Esta es la que compartes)

Añade una clave SSH a tu cuenta de GitLab
=========================================

Para usar SSH con GitLab, copia tu clave pública a tu cuenta de GitLab:

Copia el contenido de tu archivo de clave pública, para copiar una clave ED25519
al portapapeles:

Una opción es copiar al portapapeles en Linux (requiere el paquete xclip
instalado)

$ xclip -sel clip < ~/.ssh/id_ed25519.pub

La otra opción es manualmente con:

$ cat .ssh/id_ed25519.pub

Copia el contenido de la clave, sera algo como esto.

ssh-ed25519 XXXXXXXXXXXXXXXXXXX tu_correo@ejemplo.com

Inicia sesión en GitLab y busca la sección de Claves SSH.

Selecciona Añadir nueva clave.

En el cuadro Clave, pega el contenido de tu clave pública. Si copiaste la clave
manualmente, asegúrate de copiarla completa.

En el cuadro Título, escribe una descripción, como Portátil del trabajo o
Estación de trabajo en casa.

Opcional. Selecciona el tipo de uso de la clave. Se puede usar para
autenticación, firma o ambas. Autenticación y firma es el valor predeterminado.

Opcional. Actualizar la fecha de caducidad para modificar la fecha de caducidad
predeterminada.

Los administradores pueden ver las fechas de caducidad y usarlas como guía al
eliminar claves.

Seleccionar "Añadir clave".

Si se añadio correctamente debe aparecer la llave creada en la lista.

Verificación
============

Para verificar que todo quedó perfecto, escribe esto en tu terminal:

$ ssh -T git@gitlab.com

Si usaste frase de paso te pedira la misma, si todo está bien, GitLab te
responderá:

Welcome to GitLab, @tu_usuario!

Prueba con push
===============

Ahora que ya tienes las llaves, Gitlab y tu computadora tienen ya "se conocen"
lo que sigue es empezar a trabajar con tus repositorios usando la dirección SSH
en lugar de la HTTPS.

1. Clonar un proyecto existente

Si ya tienes un proyecto en GitLab que quieres bajar a tu computadora:

Ve a la página del proyecto en GitLab.

Haz clic en el botón azul Code.

Copia el link debajo de Clone with SSH (se ve algo como
git@gitlab.com:user/project.git).

En tu terminal, escribe: git clone git@gitlab.com:usuario/proyecto.git

2. Conectar un proyecto local que ya tienes

Si ya tienes una carpeta con código en tu PC y quieres subirla a un repo nuevo
en GitLab:

Entra a tu carpeta en la terminal.

Si no has iniciado git, usa git init.

Agrega el "remote" usando la dirección SSH:

$ git remote add origin git@gitlab.com:tu_usuario/tu_proyecto.git

Ahora ya puedes hacer git push -u origin main sin que te pida contraseña.

Hacer push con un repositorio local ya existente anteriormente
==============================================================

En un .git/config como este no sirve el push que haga uso de las llaves ssh:

[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
[remote "origin"]
    url = https://gitlab.com/user/project
    fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
    remote = origin
    merge = refs/heads/master 

El "problema" es que tu archivo de configuración todavía tiene la dirección
HTTPS grabada. Por eso, Git sigue intentando entrar por la puerta principal
pidiendo usuario y contraseña, en lugar de usar el túnel SSH que acabas de
configurar.

Fíjate en esta línea de tu archivo: url = https://gitlab.com/user/project

Cómo solucionarlo? Cambiando el Remote

No necesitas editar el archivo manualmente (aunque podrías). Es más seguro y
rápido ejecutar este comando en tu terminal, dentro de la carpeta de tu proyecto:

$ git remote set-url origin git@gitlab.com:user/project.git

Para hacerlo manual la línea debe quedar así:

url = git@gitlab.com:user/project.git

¿Qué acabamos de hacer?

Hemos cambiado el protocolo de comunicación. Si revisas de nuevo tu .git/config,
verás que la URL ahora empieza con git@gitlab.com....

Verificación final

[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
[remote "origin"]
    url = git@gitlab.com:user/project.git
    fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
    remote = origin
    merge = refs/heads/master

Una vez que ejecutes ese comando, intenta hacer un push:

$ git push origin master

Nota importante: Si al crear tu llave SSH le pusiste una "passphrase"
(contraseña de la llave), Git te la pedirá una vez por sesión. Pero ojo, esa es
la contraseña de tu archivo de llave en tu PC, no tu contraseña de la página de
GitLab.

Fuentes
=======

Gemini IA

https://docs.gitlab.com/18.1/user/ssh/#add-an-ssh-key-to-your-gitlab-account

====================================================
¿Qué son las claves GPG y para que sirven en GitLab?
====================================================

Si las llaves SSH sirven para identificarte al entrar (como una tarjeta de
acceso al edificio), las llaves GPG sirven para firmar tu trabajo (como un sello
notarial en un contrato).

¿Qué es una clave GPG?
======================

GPG (GNU Privacy Guard) es una herramienta que permite cifrar y firmar
digitalmente tus datos. En el contexto de GitLab, se usa para verificar tu
identidad como autor de los cambios (commits) que subes.

Cualquier persona puede configurar su nombre y correo en Git así:

$ git config --global user.name "Mr Miyagi"

$ git config --global user.email "mrmiyagi@mail.com"

Sin GPG, GitLab aceptará ese commit y parecerá que Mr Miyagi escribió el código.
GPG evita esta suplantación.

¿Para qué se usan en GitLab?
============================

1. Obtener el distintivo "Verified"

Cuando firmas tus commits con GPG y subes tu llave pública a GitLab, aparecerá
un escudo verde que dice "Verified" al lado de tus cambios. Esto le dice a tu
equipo: "Este código realmente lo escribió Mr Miyagi y nadie lo alteró en el
camino".

2. Integridad del código

Asegura que el código no ha sido modificado por un tercero desde que lo firmaste
hasta que llegó al servidor. Es un estándar de seguridad en proyectos de código
abierto o en empresas con normas de auditoría estrictas.

Generar las llaves GPG y configurarlas
======================================

1. Generar el par de llaves GPG

Ejecuta el siguiente comando y sigue las instrucciones:

$ gpg --full-generate-key

Tipo de llave: Presiona 1 y Enter para elegir la opción (RSA).

Tamaño: Escribe 4096.

Validez: Presiona 0 (para que no caduque nunca) y confirma con y.

Nombre y Correo: Importante: Usa el mismo correo que tienes configurado en GitLab.

Passphrase: Elige una contraseña segura (la necesitarás cada vez que hagas un commit).

2. Obtener el ID de tu llave

Para que Git sepa qué llave usar, necesitamos su ID. Lista tus llaves con:

$ gpg --list-secret-keys --keyid-format LONG

Busca la línea que empieza por sec. Verás algo como esto:

sec rsa4096/ABC1234567890XYZ 2024-05-20 [SC]

Tu ID es la parte después de la barra: ABC1234567890XYZ.

3. Exportar la llave pública a GitLab

Ahora dile a GitLab quién eres. Primero, muestra tu llave pública en la terminal:

$ gpg --armor --export ABC1234567890XYZ

(Sustituye el ID por el tuyo).

Copia todo el bloque de texto (incluyendo las líneas de BEGIN y END) y pégalo
en: GitLab > Settings > GPG Keys > Add new key.

4. Configurar Git para firmar automáticamente

Ahora configura tu computadora local para que use esa llave siempre:

# Indicarle a Git qué llave usar

git config --global user.signingkey ABC1234567890XYZ

# Obligar a Git a firmar cada commit automáticamente

$ git config --global commit.gpgsign true

Ejecutemos este comando para rafirmar la configuración para que no de un error
común.

$ git config --global user.signingkey ABC1234567890XYZ

5. ¡A probar!

Haz un cambio en tu código y haz un commit:

$ git commit -m "Mi primer commit firmado"

Te aparecerá una ventana pidiendo la passphrase que creaste en el paso 1.

Luego haz el push:

$ git push origin master

Verificación Visual en la Web
==============================

Entra a tu proyecto en GitLab.com.

Ve a Code > Commits.

Verás la lista de cambios. Al lado de tu último commit ("Mi primer commit
firmado"), debería aparecer un pequeño botón verde o un escudo que dice Verified.
Para que salga en verde el correo de la cuenta de gitlab debe coincidir con el
correo configurado en la creación de las llaves GPP de lo contrario saldrá la
etiqueta gris de Firmado pero sin verificar.

Si haces clic en ese botón, GitLab te mostrará los detalles de tu llave GPG
(el ID que configuramos antes).

2. Verificación en tu Terminal (Local)

Si quieres estar 100% seguro sin salir de la consola, puedes usar este comando
que muestra el log con los detalles de la firma:

$ git log --show-signature -1

Deberías ver una salida similar a esta:

commit 95fdcc5...
gpg: Signature made Tue Feb 10 2026
gpg:                using RSA key 60BF441B78BDD02F
gpg: Good signature from "Tu Nombre <tu_correo@ejemplo.com>" [ultimate]

Fuente
======

Gemini IA
