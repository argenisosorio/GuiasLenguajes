============================================
Guía de Compilacion de Paquetes Debian by dM
============================================

¿Qué es empaquetamiento?

Empaquetamiento es la posibilidad de tomar el código fuente de un programa y
compilarlo, generando un "paquete" que es un instalador para Debian
(formato .deb) de ese programa.

=============
dpkg - debian
=============

El programa dpkg es la base del sistema de gestión de paquetes de Debian
GNU/Linux. Fue creado por Ian Jackson en 1993. Se utiliza para instalar quitar,
y proporcionar información sobre los paquetes .deb.

dpkg es en sí misma una herramienta de bajo nivel; se necesita un frontal de
alto nivel para traer los paquetes desde lugares remotos o resolver conflictos
complejos en las dependencias de paquetes. Debian cuenta con apt para esta
tarea.

Herramientas Dpkg, Debian posee una serie de herramientas que es necesario
llamar para construir un paquete:

-dpkg-source Empaqueta y desempaqueta los archivos fuentes de un paquete Debian.

-dpkg-gencontrol Lee la información de un árbol fuente Debian desempaquetado y
genera un paquete binario de control, generando una entrada para éste en el
fichero debian/files.

-dpkg-shlibdeps Calcula las dependencias de ejecutables respecto a bibliotecas.

-dpkg-genchanges Lee la información de un árbol fuente Debian desempaquetado y
ya construido, generando un fichero de control de los últimos cambios
(un.changes).

-dpkg-buildpackage Es un script de control que se puede utilizar para
automatizar la construcción del paquete.

-dpkg-distaddfile Añade una entrada de un fichero a debian/files.

-dpkg-parsechangelog Lee el fichero de cambios changelog) de un árbol fuente
Debian desempaquetado y genera una salida con la información de estos cambios,
convenientemente preparada.

===
deb
===

-Extensión de archivo: .deb

-Tipo de formato: Sistema de gestión de paquetes

.deb es la extensión del formato de paquetes de software de la distribución de
Linux, Debian GNU/Linux y derivadas (e.j.Ubuntu), y el nombre más usado para
dichos paquetes. Como Debian, su nombre proviene de Deborah Murdock, ex-esposa
del fundador de la distribución Ian Murdock.

El programa predeterminado para manejar estos paquetes es dpkg, generalmente
usando apt/aptitude aunque también hay interfaces gráficas como Synaptic
PackageKit, Gdebi o en Ubuntu Software Center (este último solo para Ubuntu),
desde la versión 3.0. Es posible convertir un paquete deb a otros formatos de
paquete (como RPM), y viceversa, usando la aplicación alien.

==================
Estructura interna
==================

Los paquetes deb son archivos estándar de Unix que incluyen dos archivos tar en
formato gzip, bzip2 o lzma: uno de los cuales alberga la información de control
y el otro los datos.

Estos paquetes contienen tres archivos:

-debian-binary - número de versión del formato deb. Este es "2.0" para las
versiones actuales de Debian.

-control.tar.gz - toda la meta-información del paquete.

-data.tar, data.tar.gz, data.tar.bz2 o data.tar.lzma: - los archivos a instalar.

============================
Instalación de paquetes .deb
============================

Documentacion oficial de debian:

https://debian-handbook.info/browse/es-ES/stable/sect.manipulating-packages-with-dpkg.html

dpkg es la herramienta para instalar un paquete Debian, para hacer esto
utilizamos su opción -i o --install.

=============================================
Ejemplo de instalación de un paquete con dpkg
=============================================

Listar o mostrar el contenido del paquete.

$ dpkg -c dsc-nombre-paquete-xxx_i386.deb

Lista los ficheros instalados en el sistema, que pertenecen al paquete xxx.

$ dpkg -L xxx

Desempaquetamos el contenido del paquete en una ruta, necesario es crear la ruta
antes.

$ dpkg -x dsc-nombre-paquete-xxx_i386.deb /home/dir/

El comando desempaquetara, configurara y comprobará las dependencias del paquete
si hay paquetes sin instalar, lo notificara, una vez instalados los paquetes
necesarios, el paquete pendiente por configurar lo hará automaticamente,
completando así la instalacion, se podrá comprobar con un aptitude show
nombre_paquete. Si agregamos un paquete generado por nosotros a un repositorio
personalizado podremos contar con la resolución automática de dependencias lo
cual no pasa si se instala con dpkg.

# dpkg -i man-db_2.7.0.2-5_amd64.deb

Comprobar la instalación, Deberías ver ii delante del nombre del paquete en la
salida en pantalla, ello significaría que el programa ha sido correctamente
instalado.

# dpkg -l | grep nombre-del-paquete

Desinstalar paquete con dpkg, Este comando removerá el paquete, pero dejara los
archivos de configuracion intactos, esto es util en caso que hubieras realizado
cambios en ellos y quieras una copia para usos posteriores. Pero si deseas
quitar todo rastro del paquete debes usar purge

# dpkg -r nombre-del-paquete

dpkg --purge is used to remove the package binaries and the configuration files.

$ dpkg --purge package_name

Forzar la desinstalación del paquete xxx.deb.

$ dpkg -force -r xxx.deb

Ahora no quedará rastro del paquete antes instalado.# dpkg -P nombre-del-paquete

Muestra información sobre el paquete, sobre las dependencias y las versiones de
las mismas, lo que mostrario con un aptitude show.

$ dpkg --info nombre_paquete.deb

Para listar el total de paquetes instalados.

$ dpkg --get-selections

Gracias a este herramienta también es posible exportar la lista de paquetes
instalados, crear el fichero

# dpkg --get-selections > /home/dir/mis_paquetes.txt

Luego podemos instalarlos en otra máquina pasandole la lista, obtención de la
lista precedente.

# dpkg --set-selections < /home/dir/mis_paquetes.txt

Instalación de la lista

# apt-get dselect-upgrade

Da la lista de paquetes instalados pero con mayor información. Sin embargo, no
es posible utilizarlo para instalar una lista de paquetes.

$ dpkg -l

Lista los paquetes instalados que coincidan con el nombre xxx.

$ dpkg -l xxx

Lista los paquetes que contienen la cadena xx en su nombre de paquete.

$ dpkg -l *xxx*

===============================
Descargando los paquetes fuente
===============================

Es muy común en el mundo del software libre estudiar el código fuente o corregir
código erróneo. Para lograr esto, se necesita descargar el código fuente del
programa.

El sistema APT provee de una manera fácil de obtener código fuente de muchos
programas contenidos en la distribución, incluyendo todos los archivos
necesarios para crear un .deb para el programa.

Otro uso común de las fuentes de Debian es el de adaptar la versión más reciente
de un programa, de la versión inestable. Compilar un programa en la versión
estable generará .debs con las dependencias ajustadas para acoplarse a los
paquetes en la distribución.

Para lograr esto una entrada deb-src en el archivo /etc/apt/sources.list debe
apuntar hacia "unstable". Esta línea debe estar habilitada (sin comentar).

Para descargar un paquete fuente, haga lo siguiente:

$ apt-get source packagename

Esto descargará tres archivos: un .orig.tar.gz, un .dsc y un .diff.gz. En el
caso de paquetes especiales para Debian, el último de estos archivos no es
descargado y el primero generalmente no tendrá el "orig" en el nombre.

El archivo .dsc es utilizado por dbpkg-source para descomprimir el paquete en el
directorio packagename-version. Con cada paquete descargado existe un directorio
debian/ que contiene los archivos necesarios para crear un paquete .deb.

Para automáticamente compilar el paquete cuando está siendo descargado, sólo
agrega -b a la línea de comando así.

$ apt-get -b source packagename

Hay una diferencia entre el apt-get source y las otras opciones. La opción
source puede ser utilizada por usuarios normales, sin necesitar de poderes
especiales de root. Los archivos son descargados a un directorio desde el cual
el comando apt-get source package es ejecutado.

===============================
Estructura de un paquete fuente
===============================

Un paquete fuente generalmente consiste de tres archivos: uno .dsc, uno
.orig.tar.gz y uno .debian.tar.gz (o .diff.gz). Ellos permiten la creación de
paquetes binarios (.deb) a partir de los archivos de código fuente del programa,
escritos en un lenguaje de programación.

El archivo .dsc («Debian Source Control»: control de fuente Debian) es un
archivo de texto corto que contiene una cabecera RFC 2822 que describe el
paquete fuente e indica qué otros archivos forman parte del mismo. Está firmado
por su encargado, lo que garantiza su autenticidad.

# Ejemplo 5.1. Un archivo .dsc

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Format: 3.0 (quilt)
Source: zim
Binary: zim
Architecture: all
Version: 0.62-3
Maintainer: Emfox Zhou <emfox@debian.org>
Uploaders: Raphaël Hertzog <hertzog@debian.org>
Homepage: http://zim-wiki.org
Standards-Version: 3.9.6
Vcs-Browser: http://anonscm.debian.org/gitweb/?p=collab-maint/zim.git
Vcs-Git: git://anonscm.debian.org/collab-maint/zim.git
Build-Depends: debhelper (>= 9), xdg-utils, python (>= 2.6.6-3~), libgtk2.0-0 (>= 2.6), python-gtk2, python-xdg
Package-List:
 zim deb x11 optional arch=all
Checksums-Sha1:
 ad8de170826682323c10195b65b9f1243fd75637 1772246 zim_0.62.orig.tar.gz
 a4f70d6f7fb404022c9cc4870a4e62ea3ca08388 14768 zim_0.62-3.debian.tar.xz
Checksums-Sha256:
 19d62aebd2c1a92d84d80720c6c1dcdb779c39a2120468fed01b7f252511bdc2 1772246 zim_0.62.orig.tar.gz
 fc2e827e83897d5e33f152f124802c46c3c01c5158b75a8275a27833f1f6f1de 14768 zim_0.62-3.debian.tar.xz
Files:
 43419efba07f7086168442e3d698287a 1772246 zim_0.62.orig.tar.gz
 725a69663a6c2961f07673ae541298e4 14768 zim_0.62-3.debian.tar.xz

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2
Comment: Signed by Raphael Hertzog

iQEcBAEBCAAGBQJUR2jqAAoJEAOIHavrwpq5WFcH/RsdzCHc1oXXxHitU23hEqMj
T6ok29M1UFDJDowMXW75jQ1nT4WPUtvEGygkCHeoO/PvjEvB0sjU8GQlX+N9ddSB
aHfqfAYmVhADNGxrXQT5inZXUa8qGeeq2Sqf6YcWtsnuD56lDbvxkyf/XYopoIEl
oltfl05z/AI+vYsW482YrCz0fxNAKAvkyuPhDebYI8jnKWeAANoqmKpsNc/HYyvT
+ZiA5o57OiGdOKT6XGy3/FiF3dkHiRY8lXW7xdr1BbIgulwl9UmiUNwuxwOYbQO7
edtjiTJqOaFUA0x1zB/XGv5tHr1MjP8naT+kfVoVHTOox51CDbeu5D3DZY4imcY=
=Wtoa
-----END PGP SIGNATURE-----

Note que el paquete fuente también tiene dependencias (Build-Depends)
completamente distintas de aquellas del paquete binario ya que indican las
herramientas necesarias para compilar el software en cuestión y construir su
paquete binario.

========================================
PRECAUCIÓN Espacios de nombres distintos
========================================

Es importante saber que no hay una correspondencia necesaria entre el nombre de
un paquete fuente y el de el o los paquetes binarios que genera. Es
suficientemente fácil de entender si sabe que cada paquete fuente puede generar
varios paquetes binarios. Es por esto que el archivo .dsc tiene los campos
Source y Binary para nombrar explícitamente el paquete fuente y almacenar la
lista de paquetes binarios que genera, respectivamente.

=========================================
CULTURA Porqué dividir en varios paquetes
=========================================

Frecuentemente un paquete fuente (para un programa dado) puede generar varios
paquetes binarios. La división es justificada por la posibilidad de utilizar
(partes de) el mismo en varios contextos. Si consideramos una biblioteca
compartida, ésta puede ser instalada para hacer funcionar una aplicación
(por ejemplo, libc6) o para desarrollar un nuevo programa (libc6-dev sería el
paquete correcto). Encontramos la misma lógica para servicios cliente/servidor
donde deseamos instalar el servidor en una máquina y la parte cliente en otras
(este es el caso, por ejemplo, de openssh-server y openssh-client). Tan
frecuentemente también se provee la documentación en un paquete dedicado: el
usuario puede instalarla independientemente del software y puede elegir
eliminarla en cualquier momento para ahorrar espacio en disco. Adicionalmente,
esto también ahorra espacio en disco en las réplicas Debian ya que todas las
arquitecturas comparten los paquetes de documentación (en lugar de tener la
documentación duplicada en los paquetes para cada arquitectura).

==================================================
PERSPECTIVA Diferentes formatos de paquetes fuente
==================================================

Originalmente sólo existía un formato de paquete fuente. Este es el formato 1.0
que asocia un compendio .orig.tar.gz con un parche de «debianización» .diff.gz
(también hay una variante que consiste de un simple compendio .tar.gz, utilizada
automáticamente si hay disponible un archivo .orig.tar.gz).

Desde Debian Squeeze, los desarrolladores Debian tienen la opción de utilizar
nuevos formatos que corrigen varios problemas del formato histórico. El formato
3.0 (quilt) puede combinar varios compendios de origen en el mismo paquete
fuente: puede incluir compendios .orig-componente.tar.gz además del .orig.tar.gz
usual. Esto es útil con el software distribuido desde origen en varios
componentes pero para el que se desea sólo un paquete fuente. Estos compendios
también puede comprimirse con bzip2 o xz en lugar de gzip, lo que ahorra espacio
en disco y recursos de red. Finalmente, se reemplaza el parche monolítico
.diff.gz por un compendio .debian.tar.gz que contiene las instrucciones de
compilación y un conjunto de parches al origen contribuidos por el desarrollador
del paquete. Estos últimos son registrados en un formato compatible con quilt —
una herramienta que facilita la gestión de una serie de parches.

=============================================
HERRAMIENTA Descomprimiendo un paquete fuente
=============================================

Si tiene un paquete fuente, puede utilizar dpkg-source (del paquete role="pkg")
para descomprimirlo:

$ dpkg-source -x package_0.7-1.dsc

============
Dependencias
============

Una dependencia es un paquete accesorio requerido por un paquete instalador para
hacer funcionar correctamente un programa después de instalarlo.

Generalmente son bibliotecas de código o programas accesorios. Un programa puede
tener múltiples dependencias, las cuales no siempre vienen instaladas en la
distribución Linux elegida por diversas razones, por no ser necesarias, por
aumentar demasiado el tamaño del archivo ISO, etc. Algunas distros, por ser una
distribuciones minimalistas, de tamaño ligero, encaminan con frecuencia al
usuario  tener que buscar dependencias de programas que no se suelen ofrecer en
los repositorios o en los foros, por eso el administrador de paquetes incluye
una herramienta para detectar y descargar las dependencias junto con el programa
principal.

Aunque es posible ofrecer un solo paquete que incluya el programa principal más
las dependencias, muchos compiladores y desarrolladores optan por ofrecer esos
componentes por separado para facilitar la descarga a través de conexiones
lentas, o para darle al usuario la opción de instalar sólo los componentes que
sabe que están ausentes en su sistema. Por eso, siempre es recomendable
investigar cuáles son las dependencias del programa que se desea instalar, así
como verificar que se tiene suficiente espacio para la instalación. No todas las
dependencias son absolutamente necesarias, algunas sólo dan soporte adicional
para ciertas funciones o efectos visuales que extienden las características del
programa en sí mismo.

Muchas veces cuando ejecutamos un programa, pero más frecuente cuando estamos
instalando algún programa en Unix/Linux nos podemos enfrentar con errores de
dependencias de librerías. Esto se da por diversos motivos pero hay un comando
que nos indica las dependencias de librerías que tiene cada programa, el comando
es ldd.

ldd es un comando que enlista las dependencias dinámicas de archivos ejecutables
o de objetos compartidos.

Si el archivo es un archivo ejecutable o un objeto compartido, ldd enlista las
rutas de todas las librerías u objetos compartidos que son cargados cuando es
ejecutado el programa o cuando es cargado el objeto compartido. Si los objetos
compartidos no tuvieran permisos de ejecución ldd enviará un mensaje de
advertencia antes de intentar procesar el archivo. Ejemplo:

$ ldd /usr/bin/python2.7 // Ver las dependencias de una librería o ejecutable

########################
##### Metapaquetes #####
########################

Un metapaquete es un como un paquete que enlaza varios paquetes, es decir, es un paquete que contiene referencias a
varios paquetes pero no realiza ninguna funcionalidad.

Los metapaquetes sirven para poder instalar fácilmente varios paquetes con una sola orden. Estos paquetes guardan entre
sí una cierta coherencia.

El funcionamiento de un metapaquete es el siguiente:

Imaginemos que tenemos el metapaquete A, que contiene a B, C , D y E. Cuando instalamos el metapaquete A, lo que en realidad estamos instalando
son los paquetes B, C, D y E.

--- Estructura de un metapaquete ---

Tal como los paquetes comunes, los metapaquetes deben ser generados a partir de un código fuente basado en las políticas de Debian.

metapaquete
    |-- AUTHORS                (opcional)
    |-- COPYING                (opcional)
    |-- debian
    |    |-- changelog
    |    |-- compat
    |    |-- control
    |    |-- copyright
    |    |-- postinst
    |    |-- postrm
    |    |-- preinst
    |    |-- prerm
    |    |-- rules
    |    `-- source
    |        `-- format
    |-- LICENSE                (opcional)
    |-- Makefile               (opcional)
    |-- README                 (opcional)
    |-- THANKS                 (opcional)
    `-- TODO                   (opcional)

La carpeta debian contiene los siguientes archivos:

-changelog: Lista cronológica de versiones del metapaquete, que además contiene una descripción significativa de los cambios hechos en cada una de ellas.
-compat: versión de debhelper utilizada.
-control: El archivo más importante en un metapaquete. Especifica las dependencias, el nombre del paquete, el responsable (mantenedor),
descripción, entre otros campos.
-copyright: Declaración de derechos de autor (si los hubiere) y licencia de distribución del paquete.
-postinst, postrm, preinst, prerm: Los scripts del mantenedor permiten configurar o modificar partes del sistema en diferentes momentos de la instalación del paquete.
-rules: El archivo rules especifica las reglas para el empaquetado de la aplicación.
-source/format: Especifica el formato del código fuente, el más recomendado es 3.0 (quilt).

Los siguientes son archivos opcionales que pueden o no ser incluidos a gusto del desarrollador. Normalmente se incluyen, pero en el caso de los
metapaquetes no hay código que compilar, ni copiar dentro del paquete (que es para lo que sirve el Makefile), ni tampoco hay
código que documentar o describir.

-AUTHORS: Contiene el o los autores del código fuente.
-COPYING: Declaración de derechos de autor (si los hubiere) y licencia de distribución del código fuente.
-LICENSE: Una copia exacta de la licencia con que se distribuye el código fuente.
-Makefile: Son el conjunto de instrucciones necesarias para que el código fuente se organice, (compile si es necesario) e instale en
el sistema. También contiene instrucciones para limpiar y desinstalar.
-README: Descripción detallada del software. Se responden preguntas como: ¿Para que sirve? ¿Cómo se instala? ¿Cómo se desinstala? ¿Donde consigo ayuda?
-THANKS: Agradecimientos a las personas que contribuyeron contigo.
-TODO: Cosas que quisieras hacer en el futuro con tu software.

##### Fundamentos de la compilacion de programas en GNU - Linux #####

¿Qué es "compilar"?

Compilar es transformar el código fuente (código escrito en un determinado lenguaje de programación, por ejemplo C, C++, etc) en un programa ejecutable para su funcionamiento mediante el uso del procesador para la conversión del lenguaje usado para generar el código a el binario y ensamblador. También se le suele llamar empaquetamiento.

make y makefiles

Make es una herramienta de gestión de dependencias, típicamente, las que existen entre los archivos que componen el código fuente de un programa, para dirigir su recompilación o "generación" automáticamente. Su función básica consiste en determinar automáticamente qué partes de un programa requieren ser recompiladas y ejecutar los comandos necesarios para hacerlo, también lo es que Make puede usarse en cualquier escenario en el que se requiera, de alguna forma, actualizar automáticamente un conjunto de archivos a partir de otro, cada vez que éste cambie.

Por defecto lee las instrucciones para generar el programa u otra acción del fichero makefile. Las instrucciones escritas en este fichero se llaman dependencias.

La herramienta make se usa para las labores de creación de fichero ejecutable o programa, para su instalación, la limpieza de los archivos temporales en la creación del fichero, todo ello especificando unos parámetros iniciales (que deben estar en el makefile) al ejecutarlo.

Además de ser éste su objetivo principal, es utilizado para automatización de otras tareas como la creación de documentos del formato docbook, mantenimiento del sistema, simplemente usando o creando makefiles que hagan estas tareas.

Estructura de un makefile

Los makefiles son los ficheros de texto que utiliza make para llevar la gestión de la compilación de programas. Se podrían entender como los guiones de la película que quiere hacer make, o la base de datos que informa sobre las dependencias entre las diferentes partes de un proyecto. Todos los Makefiles están ordenados en forma de reglas, especificando qué es lo que hay que hacer para obtener un módulo en concreto. El formato de cada una de esas reglas es el siguiente:

objetivo: dependencias
    comandos

En "objetivo" definimos el módulo o programa que queremos crear, un ejecutble o un archivo objeto, después de los dos puntos y en la misma línea podemos definir qué otros módulos o programas son necesarios para conseguir el "objetivo", esas son las dependencias. Por último, en la línea siguiente y sucesivas indicamos los comandos necesarios para llevar esto a cabo. Es muy importante que los comandos estén separados por un tabulador del comienzo de línea.

juego : ventana.o motor.o bd.o
    gcc –O2 –c juego.c –o juego.o
    gcc –O2 juego.o ventana.o motor.o bd.o –o juego

Para crear "juego" es necesario que se hayan creado "ventana.o", "motor.o" y "bd.o" (típicamente habrá una regla para cada uno de esos ficheros objeto en ese mismo Makefile).

Comentarios en makefiles

Todo lo que esté escrito desde el carácter "#" hasta el final de la línea será ignorado por make. Las líneas que comiencen por el carácter "#" serán tomadas como líneas en blanco. Es bastante recomendable hacer uso de comentarios para dotar de mayor claridad a los Makefiles. Podemos añadir una cabecera con la fecha, autor y número de versión del fichero, para llevar un control de versiones más eficiente.

Variables

La forma de definir una variable es indicar el nombre de la variable (típicamente en mayúsculas) y su valor:

CC = gcc –O2

Comandos de mantenimiento

Es habitual que los ficheros makefile puedan contener otros comandos de mantenimiento, que no generen un fichero en concreto, sino que sirvan para realizar una determinada acción dentro de nuestro proyecto. Normalmente estos comandos suelen tener un objetivo, pero ninguna dependencia. El ejemplo más típico de este tipo de comando es "clean" que incluyen casi la totalidad de makefiles, utilizada para "limpiar" de ficheros ejecutables y ficheros objeto los directorios que haga falta, con el propósito de rehacer todo la próxima vez que se llame a "make":

clean:
    rm –f juego *.o

Reglas implícitas

No todos los objetivos de un makefile tienen por qué tener una lista de comandos asociados para poder realizarse. En ocasiones se definen reglas que sólo indican las dependencias necesarias, y es el propio make quien decide cómo se lograrán cada uno de los objetivos, ejemplo:

juego : juego.o
juego.o : juego.c

Con un Makefile como este, make verá que para generar "juego" es preciso generar previamente "juego.o" y para generar "juego.o" no existen comandos que lo puedan realizar, por lo tanto, make presupone que para generar un fichero objeto basta con compilar su fuente, y para generar el ejecutable final, basta con enlazar el fichero objeto. Así pues, implícitamente ejecuta las siguientes reglas:

cc –c juego.c –o juego.o
cc juego.o –o juego

Generando el ejecutable, mediante llamadas al compilador estándar.

Invocando al comando make

Cuando invocamos al comando make desde la línea de comandos, lo primero que se busca es un fichero que se llama "GNUmakefile", si no se encuentra se busca un fichero llamado makefile y si por último no se encontrase, se buscaría el fichero Makefile. Si no se encuentra en el directorio actual ninguno de esos tres ficheros, se producirá un error y make no continuará:

$ make
make: *** No se especificó ningún objetivo y no se encontró ningún makefile. Alto.

CMake

Es una herramienta multiplataforma de generación o automatización de código. Se utiliza para ahorrar tiempo y esfuerzo en la compilación de nuestras fuentes.

Instalación:

$ sudo apt-get install cmake

Para comprobar que funciona crearemos un directorio llamado compilacion y entramos en el directorio.

debian@debian:~$ mkdir compilacion && cd compilacion

Dentro creamos un fichero .cpp con el siguiente contenido:

#include <iostream>

using namespace std;

int main () {
    cout << "Hola Mundo!";
    return 0;
}

Lo guardamos como source.cpp

CMake necesita como entrada un fichero llamado CMakeLists.txt Este fichero contiene un programa que describe qué dependencias deben cumplirse (como un ./configure convencional) y cómo se construye el proyecto (una especie de Makefile de alto nivel).

El lenguaje que se utiliza para crear este programa es propio de CMake, se ejecuta de forma secuencial y su sintaxis es bastante regular y simple.

En el mismo directorio compilacion creamos un fichero CMakeLists.txt con el siguiente contenido:

CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
PROJECT(application)
ADD_EXECUTABLE(executable source.cpp)

Todo el fichero CMakeLists.txt está constituido por comandos que describen tanto las dependencias como la forma de construir el proyecto. También existen estructuras de control (if) y bucles (foreach, while). Gracias a estas estructuras, construir un programa que describa los pormenores de la construcción de un proyecto.

Ahora creamos dentro del directorio, la carpeta build con el siguientes comandos:

$ mkdir build

Nuestro directorio /compilacion de momento tendría los ficheros y carpetas:

debian@debian:~/compilacion$ ls

build  CMakeLists.txt  source.cpp

Ejecutamos el comando:

$ cmake .

Que nos mostrara la siguiente salida:

-- The C compiler identification is GNU 4.9.2
-- The CXX compiler identification is GNU 4.9.2
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/debian/compilacion

Luego del comando anterior, nuestro directorio /compilacion ahora guarda los ficheros y carpetas:

debian@debian:~/compilacion$ ls

build  CMakeCache.txt  CMakeFiles  cmake_install.cmake  CMakeLists.txt  Makefile  source.cpp

Ejecutamos un:

$ make

Que nos mostrara la siguietne salida:

Scanning dependencies of target executable
[100%] Building CXX object CMakeFiles/executable.dir/source.cpp.o
Linking CXX executable executable
[100%] Built target executable

Si todo esta bien, nos creara un programa ejecutable a partir de source.cpp, entonces, nuestro directorio /compilacion guarda los ficheros y carpetas:

debian@debian:~/compilacion$ ls

build  CMakeCache.txt  CMakeFiles  cmake_install.cmake  CMakeLists.txt  executable  Makefile  source.cpp

El fichero ejecutable que se creo es executable

Para comprobar que funciona correctamente, escribimos:

debian@debian:~/compilacion$ ./executable

Y nos mostraria el contenido de source.cpp compilado, en este caso, un simple Hola Mundo!

Con cada proyecto descargado que use Cmake tiene un fichero CMakeLists.txt en el que describimos el proyecto utilizando un lenguaje con su propia sintaxis. Con él declaramos dónde están los directorios de inclusión, los ficheros fuente, las librerías de las que depende, los productos que generamos (ejecutables o librerías), etc. Partiendo de esta declaración de proyecto, el script es procesado por CMake y genera los ficheros de compilación.

Otro ejemplo

Dentro de un directorio x creamos el CMakeLists.txt con el siguiente contenido:

SET(saludo "Hola Mundo")
MESSAGE(${saludo})

En este ejemplo creamos una variable utilizando SET y accedemos a su contenido con ${variable}.

Luego ejecutamos:

$ cmake .

Y obtendrás la siguiente salida:

user@debian:/x$ cmake .
-- The C compiler identification is GNU
-- The CXX compiler identification is GNU
-- Check for working C compiler: /usr/bin/gcc
-- Check for working C compiler: /usr/bin/gcc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
Hola Mundo
-- Configuring done
-- Generating done
-- Build files have been written to: /x

Las comprobaciones que CMake hace antes del mensaje "Hola Mundo" son las correspondientes para un proyecto programado en C/C++. Por defecto, si no se especifica otro lenguaje, se harán estas comprobaciones.

Pruebamos de nuevo el comando anterior:

user@debian:/x$ cmake .
Hola Mundo
-- Configuring done
-- Generating done
-- Build files have been written to: /x

Makefile generado

Por defecto, en sistema UNIX como GNU/Linux, CMake genera un Makefile con diferentes objetivos. Si ejecutamos make para el ejemplo del "Hola Mundo" no pasará nada ya que hasta el momento no se ha creado un programa para compilar proyectos.

./configure

Es un script en bash con una funcion especial y que existe en el directorio con las fuentes del programa que estemos intentando instalar. Es el encargado de configurar y crear un fichero Makefile que sera utilizado por make para compilar/instalar el programa que estemos instalando.

configure se ejecuta con $ ./configure porque al ser un script en el directorio fuente del programa a instalar, se debe llamar desde este directorio con ./ delante para definir que nos referimos al configure del directorio donde nos encontramos y para que sistema lo pueda encontrar.

El ejecutar configure + make + make install es el método mas común de instalación de un programa cuando lo compilamos nosotros mismos, pero no es el único y algunos programas tienen sus propios métodos de configuracion/compilacion/instalacion.

########################################
##### Compilar e instalar paquetes #####
########################################

$ aptitude search build-essential // Este paquete es esencial para crear y manejar paquetes debian,
por consiguiente para la creación, compilacion e instalación de programas en debian, ubuntu etc.
Tambien se instala cuando se va a desarrollar con c y c++ puesto que la instalacion incluye
los compiladores y las librerias necesarias para comenzar a trabajar en estos lenguajes.

Descargámos el código fuente del programa que queremos compilar e instalar.
Normalmente lo encontraremos en un archivo comprimido, con extensión tar.bz2. 
Así que tendrás que descomprimirlo escribiendo en la consola:

$ tar xvzf paquete.tar.gz (o ver sección de Comprimir/Descomprimir archivos arriba)

//Ahora vamos al directorio donde hemos extraído el contenido del paquete:
$ cd path_del_paquete

// Confguramos el modo de compilación con:
./configure

Luego escribimos:
make

Y finalmente, instalamos con:
make install

// Si no hay errores ya deberíamos poder usar el programa instalado.

#############################################
##### Crear un paquete .deb desde cero. #####
#############################################

¿Qué es un paquete .deb?

.deb es la extensión del formato de paquetes de software de la distribución de Linux, Debian GNU/Linux y derivadas.

El programa predeterminado para manejar estos paquetes es dpkg, generalmente usando apt/aptitude.

¿Qué es dpkg?

dpkg es la base del sistema de gestión de paquetes de Debian GNU/Linux. Se utiliza para instalar, configurar, construir, quitar, y proporcionar información sobre los paquetes .deb. 

**Nota: usando deb-src:
Hay que asegurarte que tenemos algunos "repositorios de código fuente" configurados en el ordenador.
Abrimos el fichero /etc/apt/sources.list y comprobamos que tienemos una o más lineas que empiecen con deb-src.
Estas lineas se necesitan para trabajar con los paquetes de código fuente. 

**Nota: Descargando las dependencias necesarias para crear el paquete

Para construir casi cualquier programa, necesitarás algunas dependencias instaladas. Las dependencias son los programas o librerías que se necesitan para
compilar tu programa. Normalmente son un montón de paquetes acabados en -dev, pero también pueden ser otras cosas com automake o gcc, dependerá de la
cantidad de herramientas de desarrollo que ya hayas instalado en la máquina.

apt te proporciona una manera muy fácil para instalar las dependencias que necesitas:

$ sudo apt-get build-dep nombre_paquete

En este ejemplo crearemos un paquete.deb a partir de un script.sh de prueba.

Creamos el script.sh

$ touch script.sh

Luego lo llenamos con el siguiente contenido:

#!/bin/bash
VAL=10
echo $VAL

Guardamos, este script imprime el valor de una variable precargada.

Podemos probarlo con:

$ bash script.sh

Los scripts de ejecución de la mayoría de programas instalados en GNU - Linux Debian se guardan la ruta /usr/bin del sistema, por tanto crearemos un paquete que siga esa regla.

Creamos un directorio donde guardaremos todos los ficheros que irán dentro de nuestro paquete. Podemos usar cualquier nombre, luego entramos en el directorio creado.

$ mkdir tmp && cd tmp

Dentro de la carpeta "tmp" creamos otro directorio.

tmp$ mkdir mipaquete

Dentro del directorio creado "mipaquete" crearemos otra carpeta llamada "usr".

tmp$ cd mipaquete

tmp/mipaquete$ mkdir usr

Luego, dentro de la carpeta "usr" crearemos otra carpeta llamada "bin"

tmp/mipaquete$ cd usr

tmp/mipaquete/usr$ mkdir bin

Ahora movemos el script.sh a ese directorio "tmp/mipaquete/usr/bin"

$ cd

$ mv script.sh tmp/mipaquete/usr/bin/

Ahora creamos otro directorio junto a la carpeta "mipaquete" llamado DEBIAN, que contendra el fichero de paquete de control. Este es un fichero con un determinado formato y que proporciona informacion del contenido del paquete .deb.

tmp$ mkdir DEBIAN

Dentro de la carpeta "DEBIAN" Creamos el fichero de control con:

tmp$ cd DEBIAN

tmp/DEBIAN$ touch control

Luego, el fichero "control" lo llenamos con lo siguiente:

Descripción de como llenar el fichero control:

Package: NombreDelPaquete (no se permiten espacios o caracteres _)
Priority: optional
Section: misc
Maintainer: NombreDelCreador <email>
Architecture: all
Version: 1.0
Depends: NombrePaquete1, NombrePaquete2,... (si tiene alguna dependencia)
Description: Descripción corta del paquete
 Y aqui una descripción larga (No eliminar el espacio inicial al comienzo de esta línea)
(Por último, se elimina esta linea y se deja una linea vacia)

Ejemplo de fichero "control" para nuestra prueba:

Package: Script
Priority: optional
Section: misc
Maintainer: Argenis Osorio <aosorio@mail.com>
Architecture: all
Version: 1.0
Depends:
Description: Este script imprime el valor de una variable precargada.
 Este script imprime el valor de una variable precargada, usa una cabecera que lo distingue como script de bash

Guardamos el fichero modificado y cambiamos los permisos del directorio "tmp":

$ cd

$ sudo chown -R root.root tmp/

Antes de construir nuestro paquete, nuestro directorio debería tener el siguiente contenido:

tmp/
  DEBIAN/
    control
  mipaquete/
    usr/
      bin/
        script.sh

Por último creamos el paquete en formato .deb, ejemplo:

$ dpkg -b paquete /ruta/del/paquete/nombre_paquete.deb

Creamos el .deb de nuestra prueba

$ dpkg -b tmp /home/debian/mipaquete.deb

El comando nos muestra:

dpkg-deb: construyendo el paquete `script' en `/home/debian/mipaquete.deb'.

Me generara mipaquete.deb con el script listo para instalar.

Listar el contenido de nuestro paquete
$ dpkg -c mipaquete.deb

Desempaquetamos el contenido del paquete en una ruta, necesario es crear la ruta donde se va a guardar antes de ejecutar el comando.
$ dpkg -x mipaquete.deb /home/debian/tmp/

Mostrar información sobre el paquete, sobre las dependencias y las versiones de las mismas, con esto veremos el contenido que escribimos en el fichero control.
$ dpkg --info mipaquete.deb

Package: Script
Priority: optional
Section: misc
Maintainer: Argenis Osorio <aosorio@cenditel.gob.ve>
Architecture: all
Version: 1.0
Depends:
Description: Este script imprime el valor de una variable precargada.
 Este script imprime el valor de una variable precargada, usa una cabecera que lo distingue como script de bash.

-----------

##### Recompilar o Reconstruir paquetes Debian (.deb) desde los códigos fuente #####

Es común en el mundo del software libre estudiar el código fuente o corregir código erróneo. Para
lograr esto, se necesita descargar el código fuente del programa.

**Nota: usando deb-src:
Hay que asegurarte que tenemos algunos "repositorios de código fuente" configurados en el ordenador.
Abrimos el fichero /etc/apt/sources.list y comprobamos que tienemos una o más lineas que empiecen con deb-src.
Estas lineas se necesitan para trabajar con los paquetes de código fuente.

**Nota: Descargando las dependencias necesarias para crear el paquete
Para construir casi cualquier programa, necesitarás algunas dependencias instaladas. Las dependencias son
los programas o librerías que se necesitan para compilar tu programa. Normalmente son un montón de paquetes
acabados en -dev, pero también pueden ser otras cosas com automake o gcc, dependerá de la cantidad
de herramientas de desarrollo que ya hayas instalado en la máquina.

apt te proporciona una manera muy fácil para instalar las dependencias que necesitas:

$ sudo apt-get build-dep nombre_paquete

Para este ejemplo trabajaremos con las fuentes de Meld (Es una herramienta que permite al usuario ver los
cambios entre, y fusionar, dos  archivos, dos directorios, o dos archivos con un ancestro común.)

Primero creamos un directorio y entramos en el, allí trabajaremos y haremos las pruebas:

$ mkdir tmp && cd tmp

Luego, descargamos las fuentes del paquete Meld. Con las fuentes podemos hacer modificaciones, compilar e
instalar el programa y construir o reconstruir un paquete original o con modificaciones.

tmp$ apt-get source meld

Eso nos descargará los siguientes directorios y ficheros:

meld-3.12.1/
meld_3.12.1-2.debian.tar.xz
meld_3.12.1-2.dsc
meld_3.12.1.orig.tar.xz

Un paquete fuente generalmente consiste de tres archivos: .dsc, .orig.tar.gz y .debian.tar.gz (o .diff.gz).
Ellos permiten la creación de paquetes binarios .deb, partir de los archivos de código fuente del programa, escritos
en un lenguaje de programación.

El fichero .dsc (Debian Source Control) en español: Control de Fuente Debian, es un archivo de texto corto que contiene
una cabecera RFC 2822 que describe el paquete fuente e indica qué otros archivos forman parte del mismo, similar a
la del fichero control que esta en el directorio raiz en la carpeta debian.

Hay que notar que el paquete fuente también tiene dependencias (Build-Depends) completamente distintas de aquellas del paquete
binario ya que indican las herramientas necesarias para compilar el software en cuestión y construir su paquete binario.

El fichero .dsc es utilizado por dbpkg-source para descomprimir el paquete en el directorio raiz, como descargamos las
fuentes con apt-get se nos crea el directorio raíz por defecto, es este caso meld-3.12.1/.

El archivo .orig.tar.gz es un compendio que contiene el código fuente como es provisto por el desarrollador original.
Se le pide a los encargados de paquetes Debian que no modifiquen este compendio para poder verificar fácilmente el origen
e integridad del archivo (comparándolo simplemente con una suma de verificación) y para respetar los deseos de algunos autores.

El archivo .debian.tar.gz contiene todas las modificaciones realizadas por el desarrollador Debian, especialmente el agregado
de un directorio debian que contiene las instrucciones para construir un paquete Debian.

¿Que es dpkg-source?
Es una herramienta de manipulación de paquetes fuente de Debian, empaqueta y desempaqueta los archivos fuente.

Con cada paquete descargado existe un directorio debian/ que contiene los archivos necesarios para crear un paquete
.deb, en este caso ese directorio esta dentro de la carpeta meld-3.12.1/ que es el directorio raíz de las fuentes.

Entramos en el directorio raíz de las fuentes:

temp$ cd meld-3.12.1/

Ahora ejecutamos el comando que construirá nuestro .deb en el directorio tmp/ 

tmp/meld-3.12.1$ dpkg-buildpackage -rfakeroot

¿Que es dpkg-buildpackage? Es un programa que automatiza el proceso de construcción de un paquete Debian.

¿Y fakeroot? Proporciona un entorno de raíz temporal, elimina la necesidad de convertirse en root para la construcción del paquete.

Al final, dentro de nuestro directorio tmp/ tendremos nuestro .deb construido

tmp/
  meld_3.12.1-2_all.deb

###################
##### dh-make #####
###################

dh-make es una herramienta para convertir archivos de código fuente en paquetes de código fuente de Debian

-Configuraración: Primero debemos configurar las variables de entorno $DEBEMAIL y $DEBFULLNAME que son utilizadas por varias herramientas
de mantenimiento de Debian para obtener el nombre y correo electrónico del constructor o mantenedor de los paquetes.

En el /home/user editamos el fichero .bashrc le añadimos al final lo siguiente:

export DEBFULLNAME="Argenis Osorio"

export DEBEMAIL=aosorio@cenditel.gob.ve

Guardamos...

Con esto tendríamos configurado dh-make.

############################################
##### Lintian - Debian package checker #####
############################################

Lintian es una utilidad para buscar errores en paquetes .deb, comprueba los paquetes en busca de incoherencias y errores comunes y es usado
por los administradores de los repositorios de Debian para descartar solicitudes de inclusion de paquetes que no cumplan con los estándares
del GNU/Linux Debian.

# apt-get install lintian

$ lintian name_package_0.0.1.deb // Nos mostrara el resultado de las comprobaciones de lintian.