=====================
Guía de Laravel by dM
=====================

Usaremos $ para describir los comandos que se usaran con usuario regular.

Usaremos # para describir los comandos que se usaran con superusuario.

================
¿Qué es Laravel?
================

Laravel es un framework de código abierto para desarrollar aplicaciones y
servicios web con PHP 5 y PHP 7. Su filosofía es desarrollar código PHP de forma
elegante y simple, evitando el "código espagueti". Fue creado en 2011 y tiene
una gran influencia de frameworks como Ruby on Rails, entre otros...

Gran parte de Laravel está formado por dependencias, especialmente de Symfony,
esto implica que el desarrollo de Laravel dependa también del desarrollo de sus
dependencias.

=======================
¿Como funciona Laravel?
=======================

Laravel utiliza el paradigma del "Modelo-Vista-Controlador"

1) Un usuario ingresa a una página o sistema web creado con Laravel, a ese
ingreso se le llama "solicitud" o "petición".

2) Esa "solicitud" o "petición" llega a un archivo llamado rutas, las rutas es
un archivo donde especificamos que rutas o direcciones url están disponible en
un sistema/página web.

Por ejemplo si yo tengo una página llamada misitio.com y puedo acceder a
"misitio.com/registro" donde muestra un formulario para registrarse, "/registro"
es una ruta. por tanto se debe definir en ese archivo donde están las rutas. si
intento acceder a "misitio.com/prueba" y me da error, eso quiere decir que esa
ruta no existe o no ha sido especificada en el archivo de rutas.

Si una ruta válida es visitada, el paso siguiente es ir a un controlador o una
vista, el ir a un controlador solo se hará si es necesario, el controlador es la
parte donde Laravel realiza operaciones con los datos, inserción, listar,
actualización de la base de datos, calculos, ejecutar funciones con los datos,
entre otros. En el controlador es donde está la lógica de un sistema/página web.

El controlador puede acceder al modelo, el modelo son las tablas de la base de
datos reflejadas en archivos php.

Entonces un controlador puede solicitar al modelo que le traiga todos los
usuarios registrados en el sistema para, el controlador los recibe de vuelta y
ahora puede mandarlos a una vista para que sean mostrados en una página simple.

La segunda opción es ir a una vista directamente, una vista es una pagina simple
donde se muestran textos, imagenes, videos, etc, sin interactuar con otros
elementos del sistema, sin consultas ni nada.

Otro elemento del paradigma de Laravel son los Middlewares, que no es mas que un
filtro. Imaginemos que tenemos un panel de administración del sistema, y no
queremos que todos los usuarios puedan acceder a ese panel, si no solo usuarios
con permisos adecuados, entonces ahí aparecen los middlewares y sus
funcionalidades. Las rutas y los controladores pueden acceder a los middlewares.

===============
Características
===============

-Sistema de ruteo, también RESTful
-Blade, Motor de plantillas
-Peticiones Fluent
-Eloquent ORM
-Basado en Composer
-Soporte para el caché
-Soporte para MVC
-Usa componentes de Symfony
-Adopta las especificaciones PSR-212​ y PSR-4

¿Qué es un ORM (Object Relational Mapping)?
===========================================

Un ORM es un modelo de programación que permite mapear las estructuras de una
base de datos relacional (SQL Server, Oracle, MySQL, etc.), en adelante RDBMS
(Relational Database Management System), sobre una estructura lógica de
entidades con el objeto de simplificar y acelerar el desarrollo de nuestras
aplicaciones.

Las estructuras de la base de datos relacional quedan vinculadas con las
entidades lógicas o base de datos virtual definida en el ORM, de tal modo que
las acciones CRUD (Create, Read, Update, Delete) a ejecutar sobre la base de
datos física se realizan de forma indirecta por medio del ORM.

¿Qué es el eloquent?
====================

Eloquent es el ORM que incluye Laravel para manejar de una forma fácil y
sencilla los procesos correspondientes al manejo de bases de datos en nuestro
proyecto, gracias a las funciones que provee podremos realizar complejas
consultas y peticiones de base de datos sin escribir una sola línea de código
SQL.

Viene incluido con Laravel y proporciona una implementación de ActiveRecord
hermosa y simple para trabajar con su base de datos. Cada tabla de la base de
datos tiene un "Modelo" correspondiente que se utiliza para interactuar con esa
tabla. Los modelos le permiten consultar datos en sus tablas, así como insertar
nuevos registros en la tabla.

¿Qué es blade en laravel?
=========================

Blade es un motor de plantillas simple y a la vez poderoso proporcionado por
Laravel. A diferencia de otros motores de plantillas populares de PHP, Blade no
te impide utilizar código PHP plano en tus vistas.

=================================================================
Instalación de paquetes necesarios para la instalación de Laravel
=================================================================

**Importante** Esta guía fue probada en GNU/Linux Debian 9 Stretch
usando las siguientes versiones:

Instalar Apache:

# apt-get install apache2 

-----

Instalar PHP y extras para apache:

$ sudo apt install php7.0

$ sudo apt install php7.0-gd php7.0-mysql libapache2-mod-php7.0 php-zip php7.0-mbstring php7.0-xml php7.0-intl php-symfony-intl php7.0-pgsql

$ sudo apt install php-symfony-config php-symfony-dependency-injection php-symfony-expression-language php-symfony-yaml php-symfony-browser-kit php-libsodium php-symfony-http-kernel php-uuid

-----

Instalar Mysql para usarlo en un futuro como motor de base de datos:

# apt-get install mysql-server

================================
Para seguir necesitamos composer
================================

Composer es un manejador de dependencias, no un gestor de paquetes. Pero es
cierto que trata con paquetes y librerías, la instalación siempre es local para
cualquier proyecto, las librerías se instalan en un directorio por defecto
(normalmente es /vendor). Composer es capaz de instalar las librerías que
requiere tu proyecto con las versiones que necesiten. ¿Y si mis librerías
dependen de otras? También es capaz de resolver eso y descargar todo lo
necesario para que funcione y así quitarnos del dolor de cabeza de hacer todo
eso de forma manual.

=================================
¿Qué problemas resuelve Composer?
=================================

Tienes un proyecto que depende de ciertas librerías desarrolladas por terceros,
y a su vez, éstas librerías también dependen de otras (tú no tienes porqué
conocer estas librerías) lo que hace Composer en este caso es averiguar que
librerías deben instalarse; es decir, resuelve todas las dependencias indirectas
y descarga automáticamente la versión correcta de cada paquete.

Descargamos composer:

$ php -r "readfile('https://getcomposer.org/installer');" | php

El comando anterior nos descarga el fichero "composer.phar"

-----

Movemos composer a /usr/local/bin, lo cual nos permitirá que este disponible
desde donde sea que lo necesitemos:

# mv composer.phar /usr/local/bin/composer

-----

Comprobamos la instalación con el siguiente comando:

$ composer

======================
Instalación de Laravel
======================

Laravel utiliza Composer para manejar las dependencies. entonces, antes de usar
Laravel, hay que tener instalado Composer en nuestra máquina.

Primero descargamos el instalador de Laravel vía Composer

$ composer global require "laravel/installer=~1.1"

La salida de este comando:

Changed current directory to /home/user/.config/composer
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 10 installs, 0 updates, 0 removals
  - Installing symfony/process (v3.4.6): Downloading (100%)         
  - Installing psr/log (1.0.2): Downloading (100%)         
  - Installing symfony/debug (v3.4.6): Downloading (100%)         
  - Installing symfony/polyfill-mbstring (v1.7.0): Downloading (100%)         
  - Installing symfony/console (v3.4.6): Downloading (100%)         
  - Installing guzzlehttp/promises (v1.3.1): Downloading (100%)         
  - Installing psr/http-message (1.0.1): Downloading (100%)         
  - Installing guzzlehttp/psr7 (1.4.2): Downloading (100%)         
  - Installing guzzlehttp/guzzle (6.3.0): Downloading (100%)         
  - Installing laravel/installer (v1.3.4): Downloading (100%)         
symfony/polyfill-mbstring suggests installing ext-mbstring (For best performance)
symfony/console suggests installing symfony/event-dispatcher ()
symfony/console suggests installing symfony/lock ()
Writing lock file
Generating autoload files

Nos dice el directorio donde va a ser instalado laravel luego prosige con la
instalación.

Luego de la instalación, comprobamos la ruta donde está laravel con:

$ cd .config/composer/vendor/bin

Si navegamos bien hacia ese directorio, entonces seguimos, agregamos al final
del .bashrc lo siguiente:

PATH=$PATH:~/.config/composer/vendor/bin

Aplicamos los cambios con el siguiente comando:

$ source .bashrc

El primer comando el una comprobación corta, el segundo es completa y larga,
recomendado el primero.

Creamos un proyecto de laravel para probar:

$ laravel new nombre_del_proyecto

=================================================================
En la siguiente sección instalaremos Laravel en su última versión
=================================================================

**Importante** Esta guía fue probada usando la versión 7.2 de php,
Composer 1.6.3, Laravel Installer 2.0, Laravel Framework 5.6.11 en
GNU/Linux Debian 9 Stretch.

$ sudo apt-get install apt-transport-https lsb-release ca-certificates

$ sudo wget -O /etc/apt/trusted.gpg.d/php.gpg https://packages.sury.org/php/apt.gpg

$ echo "deb https://packages.sury.org/php/ $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/php.list

$ sudo apt-get update

Si da problema con la firma, volver a ejecutar:

$ sudo wget -O /etc/apt/trusted.gpg.d/php.gpg https://packages.sury.org/php/apt.gpg
--2019-03-18 21:28:18--  https://packages.sury.org/php/apt.gpg

y probar de nuevo el update.

==================================
Instalación de paquetes necesarios
==================================

Buscamos la versión de php disponible en el repositorio.

$ aptitude search search php

-----

Instalamos la versión disponible del paquete

$ sudo apt-get install php7.2-cli

-----

Verificar la versión de php que se instaló.

$ php -v

-----

Instalar Apache:

# apt-get install apache2

-----

Instalar dependencias extras necesarias:

# aptitude install php7.2-gd php7.2-mysql libapache2-mod-php7.2 php-zip php7.2-mbstring php7.2-xml php7.2-intl

# aptitude install php-symfony-config php-symfony-dependency-injection php-symfony-expression-language php-symfony-yaml php-symfony-browser-kit php-libsodium php-symfony-http-kernel php-uuid

-----

Instalar Mysql para usarlo en un futuro como motor de base de datos

# apt-get install mysql-server

======================
Instalación de Laravel
======================

Instalar composer.

-----

Instalar Laravel

$ composer global require "laravel/installer"

-----

Luego de la instalación, comprobamos la ruta donde está laravel con:

$ cd .config/composer/vendor/bin

-----

Si navegamos bien hacia ese directorio, entonces seguimos, agregamos al final
del .bashrc lo siguiente:

PATH=$PATH:~/.config/composer/vendor/bin

-----

Aplicamos los cambios con el siguiente comando:

$ source .bashrc

El primer comando es para una comprobación corta, el segundo es completa y
larga, recomendado el primero.

-----

Creamos un proyecto de laravel para probar:

$ laravel new mysite

Luego de la generación del proyecto e instalación de dependendencias

-----

Entramos en el dirctorio del proyecto y corremos el servidor de desarrollo:

$ php artisan serve

Si corre sin problemas podemos visitar: localhost:8000/ y visualizar Laravel en
letras grandes.

======================================================
Intstalar y crear un proyecto de Laravel, vía composer

**Opción recomendada**
======================================================

Primero hay que instalar composer con los pasos descritos más arriba.

Luego, con el siguiente comando especificacoms la versión que queremos instalar:

$ composer create-project --prefer-dist laravel/laravel mysite "5.4.*"

Con el comando anterior lo que estamos declarando es que cree el proyecto
"mysite" y que se use la ultima actualización de la versión 5.4 de Laravel, que
es compatible con el php7.0 que está instalado.

Ahora vamos a correr el servidor local de desarrllo usando el script Artisan.

Este comando inicia el servidor de desarrllo en http://localhost:8000:

Entramos en el dirctorio del proyecto y corremos el servidor de desarrollo:

$ php artisan serve

Si corre sin problemas podemos visitar: localhost:8000/ y visualizar Laravel en
letras grandes.

Con el siguiente comando se instala la última versión disponible:

$ composer create-project --prefer-dist laravel/laravel mysite

Con esta opción Laravel quedará instalao dentro del proyecto creado, no estará
instalado de manera global en el sistema.

===========
Tips/Extras
===========

Primero que nada deberemos saber que cuando se ejecuta un proyecto este busca la
carpeta publica (public) la cual contiene un archivo index.php que se carga por
default el cual carga el proyecto.

-----

Para comprobar la versión de Laravel instalada entramos en el directorio de un
proyecto creado:

Hay 2 formas:

1) Revisar el archivo composer.json:

Navega a la raíz del proyecto Laravel, abre el archivo composer.json, busca la
línea que tiene "laravel/framework". El valor que aparece al lado te indicará la
versión de Laravel que se está utilizando.

Por ejemplo:

"require": {
    "laravel/framework": "^8.0"
}

2) Usar la línea de comandos:

Abre la terminal en la raíz del proyecto, ejecuta el siguiente comando:

$ php artisan --version

Este comando mostrará la versión exacta de Laravel que se está utilizando en el
proyecto.

-----

Para cambiar el puerto donde se esta sirviendo el proyecto:
	
$ php artisan serve --port=9000

-----

Para cambiar la ip y el puerto donde se esta sirviendo el proyecto:

$ php artisan serve --host=192.168.0.100 --port=8000

-----

Si se va a servir el proyecto por una url diferente a localhost, algunas cosas
como las imágenes puede ser que sigan siendo servidas por localhost por tanto se
puede configurar la variable APP_URL en el archivo .env que está oculto en el
directorio raíz del proyecto:

#APP_URL=http://localhost
APP_URL=http://192.168.0.100

Cuando se clona un proyecto de un repositorio, lo mas común es que se omita la
carpeta /vendor que contiene los paquetes/librerías requeridas por el proyecto,
entonces las instalamos con:

$ composer install

===================================
Estructura del proyecto con Laravel
===================================

Vamos a comentar los principales directorios de la estructura de Laravel para
ello me he ayudado de la documentación de la estructura en español de Laravel,
donde puedes encontrar información más detallada:

-app: Contiene los modelos, y el código base de nuestra aplicación, incluirá
los directorios Console, Http y Providers.

-app/Http/routes.php: para la definición de las rutas.

-app/Http/Controllers: Aquí será donde se definirán los controladores.

-app/config/app.php: Contiene configuración general de la aplicación.

-bootstrap: Contiene el archivo app.php que arranca el framework. Este directorio
también alberga un directorio de caché que contiene archivos generados por el
framework para la optimización del rendimiento, como los archivos de caché de
rutas y servicios. Normalmente, no debería necesitar modificar ningún archivo
dentro de este directorio.

-config: Como su nombre lo indica, contiene todos los archivos de configuración
de su aplicación. Es una gran idea leer todos estos archivos y familiarizarse
con todas las opciones disponibles.

-database: El directorio de la base de datos contiene las migraciones de la base
de datos, las fábricas de modelos y las semillas o seeds. Si lo desea, también
puede utilizar este directorio para almacenar una base de datos SQLite.

-resources/views: Contiene las vistas, donde usaremos el motor de plantillas
Blade. El directorio de recursos contiene sus vistas, así como archivos CSS o
JavaScript sin compilar, este directorio también aloja todos sus archivos de
idioma.

-public: Carpeta pública desde dónde se inicia el proceso de ejecución de una
aplicación Laravel.

El punto de entrada para todas las solicitudes a una aplicación de Laravel es el
archivo public/index.php. Todas las solicitudes son dirigidas a este archivo por
la configuración de su servidor web (Apache / Nginx). El archivo index.php no
contiene mucho código. Más bien, es un punto de partida para cargar el resto del
marco.

El archivo index.php carga la definición de autocargador generada por Composer y
luego recupera una instancia de la aplicación Laravel desde bootstrap/app.php.

-routes: El directorio de rutas contiene todas las definiciones de ruta para su
aplicación. De forma predeterminada, se incluyen varios archivos de ruta con
Laravel: web.php, api.php, console.php y channels.php.

-routes/web.php: Contiene rutas que RouteServiceProvider coloca en el grupo de
middleware web, que proporciona el estado de la sesión, la protección CSRF y el
cifrado de cookies.  Si su aplicación no ofrece una API RESTful sin estado, es
probable que todas sus rutas estén definidas en el archivo web.php.

-routes/api.php: Contiene rutas que RouteServiceProvider coloca en el grupo de
middleware api. Estas rutas están destinadas a ser sin estado, por lo que las
solicitudes que ingresan a la aplicación a través de estas rutas deben
autenticarse mediante tokens y no tendrán acceso al estado de la sesión.

-routes/console.php: Es donde puedes definir todos tus comandos de consola
basados en el cierre. Cada cierre está vinculado a una instancia de comando, lo
que permite un enfoque simple para interactuar con los métodos de I/O de cada
comando. Aunque este archivo no define rutas HTTP, define puntos de entrada
(rutas) basados en la consola en su aplicación.

-routes/channels.php: Es donde puede registrar todos los canales de transmisión
de eventos que admite su aplicación.

-storage: El directorio de almacenamiento contiene sus registros, plantillas
Blade compiladas, sesiones basadas en archivos, cachés de archivos y otros
archivos generados por el framework. Este directorio está segregado en
los directorios app, framework y logs. El directorio app se puede utilizar para
almacenar cualquier archivo generado por su aplicación. El directorio framewok
se utiliza para almacenar cachés y archivos generados por el marco. Finalmente,
el directorio logs contiene los archivos de registro de su aplicación.

-storage/app/public: Se puede utilizar para almacenar archivos generados por el
usuario, como los avatares de perfil, que deberían ser de acceso público. Debe
crear un enlace simbólico en public/storage que apunte a este directorio. Puede
crear el enlace usando el comando de artisan php artisan storage:link

-vendor: Contiene los paquetes y dependencias de Composer instaladas.

================================================
Actualizar proyectos de Laravel luego de un pull
================================================

$ composer install

$ npm install

$ npm run dev

$ composer dumpautoload

$ php artisan migrate

$ php artisan serve

===========================
Limpiar la cache en Laravel
===========================

Ejecute el siguiente comando para borrar la memoria caché de la aplicación
Laravel.

$ php artisan cache:clear

==============================================================
Eliminar rastros de la configuración de un proyecto en Laravel
==============================================================

Elimina rastros de la configuración del sistema y las carga de nuevo, es decir,
es como si borraras los .pyc en proyectos de python.

$ php artisan config:cache

================================================
Borrar la caché de ruta de su aplicación Laravel
================================================

Para borrar el caché de ruta de su aplicación Laravel, ejecute el siguiente
comando

$ php artisan route:clear

=============================
Borrar caché de configuración
=============================

Puede usar config:clear para borrar la caché de configuración de la aplicación
Laravel.

$ php artisan config:clear

=================================
Borrar caché de vistas compiladas
=================================

Además, es posible que deba borrar los archivos de vista compilados de su
aplicación Laravel. Para borrar los archivos de vista compilados, ejecute el
siguiente comando desde la terminal.

$ php artisan view:clear

=================================
Configurar Laravel con postgresql
=================================

Configurar base de datos de postgresql en el archivo .env:

DB_CONNECTION=pgsql
DB_HOST=localhost
DB_PORT=5432
DB_DATABASE=nombre_base_de_datos
DB_USERNAME=usuario_base_de_datos
DB_PASSWORD=contrasena_base_de_datos

=============================
Configurar Laravel con sqlite
=============================

1) Instalar el paquete de sqlite para php, dependiendo de la versión de php que
tengamos instalada.

# apt install php7.3-sqlite3

2) Crear un archivo database.sqlite en la ruta my_project/database.

my_project/database$ touch database.sqlite

3) Configurar el fichero .env, debemos poner la ruta absoluta de la db.

DB_CONNECTION=sqlite
APP_URL=http://127.0.0.1
DB_PORT=3306
DB_DATABASE=/home/user/my_project/database/database.sqlite
DB_USERNAME=homestead
DB_PASSWORD=secret

4) Una vez configurada el gestor de base de datos, realizamos las migraciones.

$ php artisan migrate

5) Levantar el servidor de desarrollo.

$ php artisan serve

====================================
Artisan CLI (Command Line Interface)
====================================

Artisan es el nombre de la interfaz de línea de comandos incluida con Laravel.
Proporciona una serie de comandos útiles para su uso mientras desarrolla su
aplicación.  Está impulsado por el poderoso componente de la Consola Symfony.

===========================
Comandos de artisan y otros
===========================

Para conocer el listado completo de los comandos disponibles ejecutamos en
consola, en el directorio raíz de un proyecto de Laravel.

$ php artisan list

Comando disponibles:

clear-compiled  Eliminar el archivo de clase compilado
db              Iniciar una nueva sesión de CLI de base de datos
down            Ponga la aplicación en modo de mantenimiento / demostración
dump-server     Inicie el servidor de volcado para recopilar información de volcado
env             Mostrar el entorno del actual del framework
help            Muestra ayuda para un comando
inspire         Muestra una cita inspiradora
list            Lista de comandos de artisan
migrate         Ejecute las migraciones de la base de datos
optimize        Almacenar en caché los archivos de arranque del framework
serve           Sirve la aplicación en el servidor de desarrollo PHP
test            Ejecute las pruebas de la aplicación
tinker          Interactuar con su aplicación
ui              Swap the front-end scaffolding for the application
up              Saque la aplicación del modo de mantenimiento

auditing
  auditing:audit-driver  Cree un nuevo controlador de auditoría
  auditing:install       Instale todos los recursos de auditoría

auth
  auth:clear-resets      Vacíe los tokens de restablecimiento de contraseña caducados

backup
  backup:clean           Elimine todas las copias de seguridad anteriores al número de días especificado en config.
  backup:list            Muestra una lista de todas las copias de seguridad.
  backup:monitor         Supervise el estado de todas las copias de seguridad.
  backup:run             Ejecute la copia de seguridad.

cache
  cache:clear            Vaciar la caché de la aplicación
  cache:forget           Eliminar un elemento de la caché
  cache:table            Crear una migración para la tabla de la base de datos de caché

config
  config:cache           Cree un archivo de caché para una carga de configuración más rápida
  config:clear           Eliminar el archivo de caché de configuración

countries
  countries:update       Actualizar todos los datos

db
  db:seed                Sembrar la base de datos con registros
  db:wipe                Eliminar todas las tablas, vistas y tipos

debugbar
  debugbar:clear         Borrar el almacenamiento de la barra de depuración

event
  event:cache            Descubrir y almacenar en caché los eventos y los oyentes de la aplicación.
  event:clear            Borrar todos los eventos y oyentes almacenados en caché
  event:generate         Genere los eventos y oyentes que faltan en función del registro
  event:list             Enumere los eventos y los oyentes de la aplicación

key
  key:generate           Establecer la clave de la aplicación

log-viewer
  log-viewer:check       Verifique todos los requisitos de LogViewer.
  log-viewer:clear       Borrar todos los archivos de registro generados
  log-viewer:publish     Publique todos los recursos y archivos de configuración de LogViewer
  log-viewer:stats       Muestra estadísticas de todos los registros.

make
  make:cast              Create a new custom Eloquent cast class
  make:channel           Create a new channel class
  make:command           Create a new Artisan command
  make:component         Create a new view component class
  make:controller        Create a new controller class
  make:event             Create a new event class
  make:exception         Create a new custom exception class
  make:export            Create a new export class
  make:factory           Create a new model factory
  make:import            Create a new import class
  make:job               Create a new job class
  make:listener          Create a new event listener class
  make:mail              Create a new email class
  make:middleware        Create a new middleware class
  make:migration         Create a new migration file
  make:model             Create a new Eloquent model class
  make:notification      Create a new notification class
  make:observer          Create a new observer class
  make:policy            Create a new policy class
  make:provider          Create a new service provider class
  make:request           Create a new form request class
  make:resource          Create a new resource
  make:rule              Create a new validation rule
  make:seeder            Create a new seeder class
  make:test              Create a new test class

migrate
  migrate:fresh          Elimine todas las tablas y vuelva a ejecutar todas las migraciones
  migrate:install        Crea el repositorio de migración
  migrate:refresh        Restablecer y volver a ejecutar todas las migraciones
  migrate:reset          Revertir todas las migraciones de bases de datos
  migrate:rollback       Revertir la última migración de la base de datos
  migrate:status         Muestra el estado de cada migración.

notifications
  notifications:table    Crea una migración para la tabla de notificaciones

optimize
  optimize:clear         Eliminar los archivos de arranque en caché

package
  package:discover       Reconstruir el manifiesto del paquete en caché

queue
  queue:batches-table    Create a migration for the batches database table
  queue:clear            Delete all of the jobs from the specified queue
  queue:failed           List all of the failed queue jobs
  queue:failed-table     Create a migration for the failed queue jobs database table
  queue:flush            Flush all of the failed queue jobs
  queue:forget           Delete a failed queue job
  queue:listen           Listen to a given queue
  queue:prune-batches    Prune stale entries from the batches database
  queue:restart          Restart queue worker daemons after their current job
  queue:retry            Retry a failed queue job
  queue:retry-batch      Retry the failed jobs for a batch
  queue:table            Create a migration for the queue jobs database table
  queue:work             Start processing jobs on the queue as a daemon

route
  route:cache            Cree un archivo de caché de ruta para un registro de ruta más rápido
  route:clear            Eliminar el archivo de caché de ruta
  route:list             Lista de todas las rutas registradas

schedule
  schedule:list          List the scheduled commands
  schedule:run           Run the scheduled commands
  schedule:test          Run a scheduled command
  schedule:work          Start the schedule worker

schema
  schema:dump            Volcar el esquema de base de datos dado

session
  session:table          Crear una migración para la tabla de la base de datos de la sesión

snapshot
  snapshot:cleanup       Specify how many snapshots to keep and delete the rest
  snapshot:create        Create a new snapshot.
  snapshot:delete        Delete a snapshot.
  snapshot:list          List all the snapshots.
  snapshot:load          Load up a snapshot.

storage
  storage:link           Create the symbolic links configured for the application

stub
  stub:publish           Publish all stubs that are available for customization

ui
  ui:auth                Scaffold basic login and registration views and routes
  ui:controllers         Scaffold the authentication controllers

vendor
  vendor:publish         Publish any publishable assets from vendor packages

view
  view:cache             Compile todas las plantillas Blade de la aplicación
  view:clear             Borrar todos los archivos de vista compilados

-----

Sacar la aplicación del modo de mantenimiento.

$ php artisan up

-----

Poner la aplicación en modo de mantenimiento.

$ php artisan down

-----

Para ver el listado completo de rutas, Como resultado nos mostrará un listado de
todas las rutas de la aplicación con la información sobre el método HTTP, la
URI, la acción, el nombre y los middleware definidos para cada ruta, con lo
cual, entre otras cosas, podemos verificar que todas las rutas de nuestra
aplicación están bien definidas.

php artisan route:list

-----

Mismo que el anterior pero más compacta la información.

$ php artisan route:list -c

-----

Mismo que el anterior pero especificando las columnas que quiero ver.

$ php artisan route:list --columns=uri,method

-----

Restablecer y volver a ejecutar todas las migraciones

$ php artisan migrate:refresh

-----

Omite los métodos down o los rollbacks eliminando todas las tablas para luego
ejecutar los métodos up.

$ php artisan migrate:fresh

-----

Actualice la base de datos y ejecute todas las semillas de la base de datos.

$ php artisan migrate:refresh --seed

-----

Quitar todas las tablas, migrar y cargar la base de datos con las semillas

$ php migrate artisan: fresh

$ php artisan migrate: fresh --seed

-----

El comando dump-autoload actualiza la información del cargador automático de
clases. Este comando es útil cuando añades nuevas clases y no quieres ejecutar
el comando install o update.

$ composer dumpautoload

-----

Con este comando Laravel compilará todos los paquetes que se encuentran en
node_modules y unificará los archivos que se encuentran en el directorio
resources/js y resources/sass a los archivos app.js y app.css respectivamente.

$ npm run dev

-----

Con este comando Laravel compilará todos los paquetes que se encuentran en
node_modules y unificará los archivos que se encuentran en el directorio
resources/js y resources/sass a los archivos app.js y app.css respectivamente.

$ npm run prod

Diferencias entre run dev y run prod
====================================

run dev: Compilar para desarrollo, los archivos resultantes mantienen el código
fuente desminificados. Las herramientas usadas en el navegador identifican los
objetos y componentes para poder depurar el código.

run prod -> compilar para producción, los archivos resultantes estan
minificados. Las herramientas de desarrollo usadas en el navegador no pueden
acceder a los componentes u objetos por lo que es complicado poder interactuar
con ellos a través del navegador.

-----

npm run dev combina todos sus componentes de Vue y otros archivos JavaScript en
un archivo combinado compatible con el navegador.

npm run watch hace lo mismo, pero luego permanece activo y "observa" las
actualizaciones de sus archivos .vue y .js. Si detecta un cambio, reconstruirá
el archivo compatible con el navegador para que pueda actualizar la página.

$ npm run watch

===============
Seed y Seeders
===============

Una manera de cargar datos en la base de datos es utilizando los Seeders de
Laravel.

Laravel incluye un método simple para sembrar su base de datos con datos de
prueba utilizando clases semilla (Seed). Todas las clases de semillas se
almacenan en el directorio database/seeds. Las clases de semillas pueden tener
el nombre que desee, pero probablemente deberían seguir alguna convención
razonable, como nombretablaSeeder, etc. De manera predeterminada, se define una
clase DatabaseSeeder para usted. Desde esta clase, puede utilizar el método de
llamada para ejecutar otras clases semilla, lo que le permite controlar el orden
de siembra.

Aplicar un seeder específico
============================

Se puede aplicar un seeder de maner individual con el siguiente comando:

$ php artisan db:seed --class NombreDelSeeder

Crear un seeder
===============

$ php artisan make:seeder CategoriesSeeder

Esto nos creará un archivo en la carpeta database/seeds/ que tendrá el nombre
que le demos en el comando.

Así se ve CategoriesSeeder.php

<?php

use Illuminate\Database\Seeder;

class CategoriesSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        //
    }
}

Con esto ya tenemos el archivo pero no es todo lo que necesitamos para poder
trabajar con datos autogenerados, para ello usaremos un componente llamado Faker
el cual se encargará de generar estos datos, Faker viene instalado por defeto
en Laravel.

Vamos al archivo CategoriesSeeder y dentro podremos observer que se encuentra
una función llamada run() que es donde nosotros vamos a usar Faker para poblar
la base de datos o la tabla específica, ahora bien antes de todo debemos agregar
la clase de Faker a nuestro Seeder, para esto agregamos al inicio del archivo la
linea:

use Faker\Factory as Faker;

Quedaría el archivo así:

<?php

use Illuminate\Database\Seeder;
use Faker\Factory as Faker;

class CategoriesSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        //
    }
}

Ahora crearemos una variable llamada $faker que nos servira para poblar la base
de datos, ahora bien usando la clase DB, si bien dentro del ejemplo queremos
crear 50 categorías vamos a crear un for para que ejecute nuestro código de
inserción 50 veces y el componente de Faker en cada pasada cambiará los valores
del registro que se va a agregar, quedando de esta forma:

$faker = Faker::create();
for ($i=0; $i < 50; $i++) {
    \DB::table('categories')->insert(array(
           'name' => $faker->firstNameFemale,
           'created_at' => date('Y-m-d H:m:s'),
           'updated_at' => date('Y-m-d H:m:s')
    ));
}

Creamos nuestro objeto Faker, el cual puede generar información falsa para
nuestra base de datos y ahora usamos la clase DB el método table para llamar la
tabla donde se va a insertar la información y se le concatena el método insert()
el cual recibe por parametro un arreglo clave => valor con los campos de la tabla.

Faker tiene muchas variedades de datos, los cuales podemos consultar en su
Repositorio de Github así como su uso básico.

En este ejemplo usamos una propiedad que se llama firstNameFemale para darle
nombre a las categorías y la propiedad.

y si lo agregamos al ejemplo queda así:

<?php

use Illuminate\Database\Seeder;
use Faker\Factory as Faker;

class CategoriesSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $faker = Faker::create();
        for ($i=0; $i < 50; $i++) {
            \DB::table('categories')->insert(array(
                   'name' => $faker->firstNameFemale,
                   'created_at' => date('Y-m-d H:m:s'),
                   'updated_at' => date('Y-m-d H:m:s')
            ));
        }
    }
}

Y ahora lo que sigue es abrir un archivo llamado DatabaseSeeder.php, en este
archivo se mandan a llamar todos los seeders en el orden que los necesitemos, en
este archivo se agregará la linea:

$this->call('PastelesSeeder');

Quedano así:

<?php

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        // $this->call(UsersTableSeeder::class);
        $this->call('CategoriesSeeder');
    }
}

Ahora para ejecutar el los seeders:

$ php artisan db:seed

Solo resta revisar los datos guardados en la tabla para comprobar que haya
funcionado.

Se pueden consultar las demás opciones disponibles de Faker para generar
diferentes tipos de datos desde:

https://github.com/fzaninotto/Faker#basic-usage

===============================================
Usar un seeder para generar usuarios aleatorios
===============================================

Laravel por defecto crea la tabla users en la base de datos.

Para usar el Factory de los usuarios, no debemos generar ninguna acción, ya que
este ya está creado, si queremos revisarlo, podemos revisar
database/factories/UserFactory.php.

En cuanto al seeder, lo único que se debe hacer es ir a
database/seeders/DatabaseSeeder.php y quitar los comentarios de la línea que
llama al factory del usuario, quedando así

<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\User;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        User::factory(5)->create();
    }
}

Correr el seeder

$ php artisan db:seed

Esto generará 5 usuarios con datos aleatorios en la tabla users de la base de
datos.

===========================================================
Crear un seeder para generar un o unos usuarios específicos
===========================================================

1) Crear el seeder con el siguiente comando:

$ php artisan make:seeder UsersTableSeeder

2) Editar el seeder creado, el archivo es /database/seeders/UsersTableSeeder.php

3 Agregamos lo siguiente:

<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\User;
use Illuminate\Support\Facades\DB;

class UsersTableSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        DB::table('users')->insert([
            'name' => 'admin',
            'email' => 'admin@mail.com',
            'password' => bcrypt('123456'),
        ]);
        // DB::table('users')->insert([
        //     'name' => 'user2',
        //     'email' => 'user2@email.com',
        //    'password' => bcrypt('password'),
        // ]);
    }
}

Como se aprecia, se puede agregar más de 1 usuario

3) Ejecutamos el seeder con el siguiente comando:

$ php artisan db:seed --class UsersTableSeeder

O podemos agregarlo a /database/seeders/DatabaseSeeder.php para que se ejecute
con los demás seeders a través del comando:

$ php artisan db:seed

=============================================
Descargue y cargue bases de datos rápidamente
=============================================

Usando el paquete laravel-db-snapshots

Disponible desde > https://github.com/spatie/laravel-db-snapshots

Este paquete proporciona comandos Artisan para descargar y cargar rápidamente
bases de datos en una aplicación de Laravel.

Crear un dump

$ php artisan snapshot:create my-first-dump

Nos creara un archivo "my-first-dump.sql" en la ruta project/database/snapshots

-----

Crear otro dump

$ php artisan snapshot:create my-second-dump

-----

Cargar el primer dump

$ php artisan snapshot:load my-first-dump

-----

Cargar el último dump

$ php artisan snapshot:load --latest

-----

Listar todas las snapshots

$ php artisan snapshot:list

====================================
Estructura de un proyecto en Laravel
====================================

Nota: Probado en Laravel 5

Todos los proyectos nuevos en Laravel 5.1 tienen la siguiente estructura de
directorios:

app/
bootstrap/
config/
database/
public/
resources/
storage/
tests/
vendor/
.env
.env.example
.gitattributes
.gitignore
artisan
composer.json
composer.lock
gulpfile.js
package.json
phpspec.yml
phpunit.xml
readme.md
server.php

A continuación describiremos los directorios y archivos más importantes para que
nos ayuden a entender más el funcionamiento del framework.

=================
El directorio app
=================

App es usado para ofrecer un hogar por defecto a todo el código personal de tu
proyecto. Eso incluye clases que puedan ofrecer funcionalidad a la aplicación,
archivos de configuración y más. Es considerado el directorio más importante de
nuestro proyecto ya que es en el que más trabajaremos.

El directorio app tiene a su vez otros subdirectorios importantes pero uno de
los más utilizados es el directorio Http en el cuál ubicaremos nuestros
Controllers, Middlewares y Requestsen sus carpetas correspondientes, además
dentro del subdirectorio Http encontremos también el archivo routes.php donde
escribiremos las rutas de la aplicación.

A nivel de la raíz del directorio app encontraremos el modelo User.php, los
modelos comunmente se ubicarán a nivel de la raíz de la carpeta app aunque igual
es posible estructurarlos de la forma que queramos, por ejemplo, en una carpeta
llamada Models.

====================
El directorio config
====================

La configuración tanto para el framework como para tu aplicación se mantiene en
este directorio. La configuración de Laravel existe como un conjunto de archivos
PHP que contienen matrices clave-valor. Entre los archivos más usados del
directorio config se encuentran:

app.php : En este archivo nos puede interesar configurar el lenguaje de nuestra
aplicación, la zona horaria, los providers y aliases de las clases más comunes.

database.php : En este archivo podemos configurar principalmente el motor de
base de datos al cuál deseamos conectarnos.

======================
El directorio database
======================

Aquí se encontraran los archivos relacionados con el manejo de la base de datos.

Dentro de este directorio se encuentran los subdirectorios:

factories : Aquí escribiremos nuestros model factories.

migrations : Todas las migraciones que creamos se ubican en este subdirectorio.

seeds : Contiene todas las clases de tipo seed.

====================
El directorio public
====================

Dentro de este directorio colocaremos todos los recursos estáticos de nuestra
aplicación, es decir, archivos css, js, imágenes y fuentes.

Es recomendable crear una carpeta por cada tipo de recurso.

=======================
El directorio resources
=======================

Dentro de este directorio se encuentran los subdirectorios:

assets : Aquí se ubican todos los archivos less de nuestra aplicación (útil para
desarrolladores front-end).

lang : Aquí se encuentran todos los archivos de internacionalización, es decir,
los archivos para poder pasar nuestro proyecto de un idioma a otro.

Normalmente habrá una carpeta por cada idioma, ejemplo:
en : idioma inglés
es : idioma español

views : Aquí ubicaremos nuestras vistas en formato php o php.blade, es
recomendable crear una carpeta por cada controlador, además agregar una carpeta
templates para las plantillas. Una plantilla es una vista general, que tiene
segmentos que pueden ser reemplazados mediante la herencia de plantillas.

=====================
El directorio storage
=====================

Cuando Laravel necesita escribir algo en el disco, lo hace en el directorio
storage. Por este motivo, tu servidor web debe poder escribir en esta ubicación.
Aquí podemos encontrar otros directorios entre los cuales el más relevante es el
subdirectorio framework, es ahí donde se almacena el cache y las vistas
compiladas.

===================
El directorio tests
===================

Aquí escribiremos los archivos de pruebas que serán ejecutadas posteriormente
por phpunit.

==============================
El archivo .env y .env.example
==============================

El archivo .env no existe cuando instalamos laravel, en este archivo se
configurará el modo en que se ejecuta nuestra aplicación, por defecto será el
modo debug, además podemos configurar la conexión a la base de datos y la
conexión con el servidor de correo electronico. El archivo .env lo creamos
copiando el archivo .env.example y renombrando la copia como .env.

Por motivos de seguridad de la base de datos el archivo .env nunca se sube
cuando hacemos un push en nuestro repositorio. Es por eso que aparece escrito
dentro del archivo .gitignore en la raíz de nuestro proyecto.

=======================
El archivo package.json
=======================

Es el responsable de almacenar el nombre de las dependencias de node instaladas
catalogándolas principalmente en dos tipos: dependencias de desarrollo y
dependencias de la aplicación.

Al mirar dentro de este archivo, si bien hay algunas cosas que podemos reconocer
de manera inmediata, hay algunos valores y textos que es muy probable que no
sepamos que significan ni como llegaron ahí.

¿Qué es el package.json?
========================

De cierta forma, podemos considerar este package.json como un manifiesto de
nuestro proyecto.

Históricamente, Node ha trabajado con una herramienta para administrar paquetes
llamada npm. Esta herramienta, que normalmente se instala junto con Node, tiene
dos roles fundamentales:

-Manejar la publicación de un proyecto al registro público de npm (para que
otros puedan descargarlo y utilizarlo como dependencia en sus propios proyectos).

-Administrar las dependencias de tu proyecto.

Para esto, guarda un registro en un archivo llamado, justamente, package.json.

Dentro de este archivo se definen y manejan características como:

-Nombre de tu proyecto.
-Versión.
-Dependencias.
-Repositorio.
-Autores.
-Licencia.

A través de este archivo, finalmente, se puede garantizar la integridad del
proyecto. Es decir, podemos asegurar que quienes tengan una copia del mismo,
podrán acceder a las mismas propiedades y sincronizar entre múltiples partes
cada vez que decidan hacer un cambio. De cierta forma, podemos considerar este
package.json como un manifiesto de nuestro proyecto.

Por ejemplo, consideremos el siguiente escenario:

Dos personas están trabajando en el mismo proyecto, con copias independientes en
cada uno de sus equipos. El primero de ellos determina que para completar la
nueva funcionalidad, va a necesitar implementar una nueva librería al proyecto.

Antiguamente, sin manejo de dependencias, era necesario hacer una de dos cosas:

-Incluir la librería (1 o múltiples archivo(s)) manualmente en el directorio del
proyecto, potencialmente aumentando el peso del proyecto de manera considerable.

-No incluir la librería, pero comunicarle a cada persona que obtuviera una copia
del mismo que antes de trabajar en el proyecto necesitaría instalar esta nueva
dependencia (buena forma de hacer nuevos amigos, poco óptimo en términos de
tiempo).

Con el uso de administradores de dependencias, ya estos pasos no son necesarios.
Ahora cada persona que decida obtener una copia del proyecto, desde ahora al
final de los tiempos, puede instalar todas y cada una de las dependencias que
tengamos declaradas en este “manifiesto” sin la necesidad de incluir una copia
de éstas en ningún otro lado más que ahí.

Cabe mencionar que si bien muchas características del package.json parecieran
ser específicas para proyectos publicados en el registro de npm (como librerías)
también aplican para proyectos cuya finalidad no es ser publicados en ningún
registro (como por ejemplo aplicaciones Web o móviles, juegos y otros), pero que
si se benefician de las utilidades relacionadas a la administración de
dependencias.

¿Cómo crearlo?
==============

Antes de crear un package.json, hay solo una regla a tener en consideración: El
archivo debe ser un JSON de formato válido (no puede ser un objeto literal de JS
exportado desde un archivo), con todas las especificaciones que esto implica
(por ejemplo, cada key debe tener comillas dobles, solo ciertos valores son
válidos, etc.)

Para crearlo, hay 2 formas: hacerlo de forma manual o hacerlo de forma
automática:

===================================
Creando un package.json manualmente
===================================

Si bien es recomendable usar alguno de los asistentes para crear el archivo de
forma automática, en caso de que necesitemos hacerlo de forma manual, es solo
cosa de crear un archivo llamado package.json en la raíz del proyecto e incluir,
como mínimo, la siguiente información:

name.
version.

=======================================
Creando un package.json automáticamente
=======================================

Es la forma más rápida de hacerlo, ya que tanto npm como yarn incluyen un
asistente que nos permite crear un package.json con un solo comando:

$ npm init

El asistente nos hará algunas preguntas para definir la información del proyecto
(nombre, version, archivo de entrada, licencia y repositorio entre otros).

Fuente
======

-https://medium.com/noders/t%C3%BA-yo-y-package-json-9553929fb2e3

====
Yarn
====

Es una herramienta de administración de paquetes para Node llamada. Su
funcionamiento, al menos en cuanto al uso del package.json, es prácticamente
igual.

========================
El archivo composer.json
========================

Cuando comenzamos un proyecto tenemos a la mano al archivo composer.json, aquí
encontramos una lista con los paquetes y versiones que usará nuestra aplicación,
pero en la medida que avanzamos vemos que nos aparece un archivo llamado
composer.lock y por eso estamos aquí. Este archivo (composer.json) es un plano
inicial y breve, es una lista jerárquica de dependencias y aplicaciones. Cuando
comenzamos no tenemos un archivo composer.lock, este aparece en el momento que
ejecutamos el comando composer install. En otras palabras, instalamos los
paquetes y el misterioso archivo composer.lock nace y tiene vida.

========================
El archivo composer.lock
========================

Revelemos el misterio, en composer.json tenemos una breve lista con las
versiones aproximadas de dependencia que Composer debe instalar, y el archivo
composer.lock tiene el registro exacto de las versiones de dependencia que se
han instalado.

Si fuiste a mirar el archivo composer.lock habrás notado que es un super
archivo, y eso se debe a que tiene item a item la versión precisa que se instaló
cuando Composer siguió las instrucciones de archivo composer.json. Este archivo
también realiza un seguimiento de todas las versiones de las dependencias de sus
dependencias. Tienes todo aquí, dependencias de dependencias de dependencia que
a su vez puede tener dependencias... Bueno, entiendes la idea.

Todo, absolutamente todo tu sistema a nivel jerárquico de dependencias tendrá
sus versiones en el archivo composer.lock.

Lo que puedes estarte preguntando es ¿para que me sirve?... Y esto es bastante
simple. Si eliminas a la carpeta vendor a su vez estarás elimimando todos los
paquetes y dependencias. Entonces no te preocupas, solo ejecutas el comando
composer install y composer verá que tienes un archivo llamado composer.lock.
Entonces en lugar de encontrar versiones compatibles de su dependencias para
completar el archivo composer.json, él instalará la versión exacta de su
dependencias como se define en el archivo composer.lock.

Esto significa que tenemos la versión exacta de nuestras dependencias que
teníamos instaladas antes borrar la carpeta vendor. Y eso si resulta bastante
útil.

Otra pregunta, ¿qué causaría que el archivo composer.lock cambie?

Este archivo cambia si ejecutas el comando composer update y no recomiendo
hacerlo a cada rato, debes usar composer install para instalar tu nuevo paquete
sin actualizar las versiones de tus otros paquetes. Esto sería mucho más seguro
y evitamos fallas por actualizar nuevos paquetes y dependencias.

============================================================================
Añadir/Agregar e instalar nuevos paquetes en nuestra aplicación vía composer
============================================================================

Con este comando el paquete se agreagará a composer.json y composer.lock y se
instalara.

$ composer require laravel/my-package

Según parece, cada paquete de laravel tiene la terminación del comando de
instalación un poco diferente, por ejemplo:

Así se agrega e instala Laravel Breeze:

$ composer require laravel/breeze --dev

y así, se agrega e instala Laravel Collective:

$ composer require laravelcollective/html

La segunda forma de instalar paquetes es de manera manual, editando el paquete
composer.json.

Tal que:

En la sección require de composer.json agregar el paquete

"require": {
    "laravelcollective/html": "5.1.*"
}

y luego ejecutar update para que instale el paquete:

$ composer update

Agregar e instalar una version específica del paquete
=====================================================

$ composer require xxx/package:version

Ejemplo:

$ composer require laravelcollective/html:5.8

====================
Desinstalar paquetes
====================

Para desinstalar un paquete simplemente ejecuta el comando, este comando admite
las mismas opciones del comando composer require.

$ composer remove my-package

===================
Actualizar paquetes
===================

Podemos hacerlo de la siguiente forma:

Puedes actualizar todos los paquetes que se encuentran en composer.json

$ composer update

-----

Puedes actualizar únicamente uno o varios paquetes separándolos por espacios

$ composer update doctrine/dbal laravel/framework

----

$ Puedes actualizar todos los paquetes de un proveedor (‘vendor’) usando un
asterisco

$ composer update doctrine/*

===============
Rutas o Routing
===============

Las rutas son las encargadas de llamar a una acción que puede estar en un
controlador, redirigirnos a otra página web o podría ejecutar una función.

Las rutas de Laravel más básicas aceptan un URI y un Closure, proporcionando un
método muy simple y expresivo para definir rutas:

Route::get('foo', function () {
    return 'Hello World';
});

Los archivos de ruta predeterminados
====================================

Todas las rutas de Laravel se definen en el directorio /routes. Estos archivos
son cargados automáticamente por el framework. El archivo routes/web.php define
las rutas que son para su interfaz web. A estas rutas se les asigna el grupo de
middleware web, que proporciona características como el estado de la sesión y la
protección CSRF. Las rutas en las routes/api.php no tienen estado y se les
asigna el grupo de middleware api.

Para la mayoría de las aplicaciones, comenzará por definir rutas en su archivo
routes/web.php. Se puede acceder a las rutas definidas en routes/web.php
ingresando la URL de la ruta definida en su navegador.

Por ejemplo, puede acceder a la siguiente ruta navegando a
http://your-app.test/user en su navegador. La ruta sería:

Route::get('/user', 'UserController@index');

Métodos disponibles para las rutas
==================================

Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);

A veces, es posible que deba registrar una ruta que responda a varios métodos
HTTP. Puede hacerlo utilizando el método match. O incluso puede registrar una
ruta que responda a todos los métodos HTTP utilizando el método any:

Route::match(['get', 'post'], '/', function () {
    //
});

Route::any('/', function () {
    //
});

Protección CSRF
===============

Recuerde, cualquier formulario HTML que apunte a rutas POST, PUT, PATCH o
DELETE que estén definidas en el archivo de rutas web debe incluir un campo de
token CSRF. De lo contrario, la solicitud será rechazada.

<form method="POST" action="/profile">
    @csrf
    ...
</form>

Redirigir rutas
===============

Si está definiendo una ruta que redirige a otro URI, puede usar el método
Route::redirect. Este método proporciona un atajo conveniente para que no tenga
que definir una ruta completa o un controlador para realizar una redirección
simple:

Route::redirect('/here', '/there');

Rutas de vista o View Routes
============================

Si su ruta solo necesita devolver una vista, puede usar el método Route::view.

Al igual que el método de redireccionamiento, este método proporciona un acceso
directo simple para que no tenga que definir una ruta completa o un controlador.

El método de vista acepta un URI como primer argumento y un nombre de vista como
segundo argumento. Además, puede proporcionar una matriz de datos para pasar a
la vista como un tercer argumento opcional:

Route::view('/welcome', 'welcome');

Route::view('/welcome', 'welcome', ['name' => 'Taylor']);

Parametros de las rutas
=======================

A veces, necesitará capturar segmentos del URI dentro de su ruta. Por ejemplo,
es posible que deba capturar la identificación de un usuario de la URL.
Puede hacerlo definiendo parámetros de ruta:

Route::get('user/{id}', function ($id) {
    return 'User '.$id;
});

Puede definir tantos parámetros de ruta como requiera su ruta:

Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) {
    //
});

Los parámetros de ruta siempre están encerrados entre llaves {} y deben constar
de caracteres alfabéticos y no pueden contener un carácter -.

En lugar de utilizar el carácter -, utilice un guión bajo (_). Los parámetros de
ruta se inyectan en callbacks/controladores de ruta según su orden; los
nombres de los argumentos de callbacks / controlador no importan.

Parámetros opcionales
=====================

Ocasionalmente, es posible que deba especificar un parámetro de ruta, pero haga
que la presencia de ese parámetro de ruta sea opcional. Puede hacerlo colocando
un ? marcador después del nombre del parámetro. Asegúrese de darle a la variable
correspondiente de la ruta un valor predeterminado:

Route::get('user/{name?}', function ($name = null) {
    return $name;
});

Route::get('user/{name?}', function ($name = 'John') {
    return $name;
});

Restricciones de expresiones regulares
======================================

Puede restringir el formato de los parámetros de su ruta utilizando el método
where en una instancia de ruta. El método where acepta el nombre del parámetro
y una expresión regular que define cómo se debe restringir el parámetro:

Route::get('user/{name}', function ($name) {
    //
})->where('name', '[A-Za-z]+');

Route::get('user/{id}', function ($id) {
    //
})->where('id', '[0-9]+');

Route::get('user/{id}/{name}', function ($id, $name) {
    //
})->where(['id' => '[0-9]+', 'name' => '[a-z]+']);

Restricciones globales
======================

Si desea que un parámetro de ruta esté siempre limitado por una expresión
regular determinada, puede usar el método de patrón.  Debe definir estos
patrones en el método de arranque de su RouteServiceProvider:

/**
 * Define your route model bindings, pattern filters, etc.
 *
 * @return void
 */
public function boot()
{
    Route::pattern('id', '[0-9]+');

    parent::boot();
}

Una vez que se ha definido el patrón, se aplica automáticamente a todas las
rutas usando ese nombre de parámetro:

Route::get('user/{id}', function ($id) {
    // Only executed if {id} is numeric...
});

Rutas nombradas
===============

Las rutas con nombre permiten la generación conveniente de URL o
redireccionamientos para rutas específicas. Puede especificar un nombre para una
ruta encadenando el método de nombre en la definición de ruta:

Route::get('user/profile', function () {
    //
})->name('profile');

También puede especificar nombres de ruta para las acciones del controlador:

Route::get('user/profile', 'UserProfileController@show')->name('profile');

ó

Route::post('','StudentController@store')->name('students.store');

Generación de URL para rutas con nombre
=======================================

Una vez que haya asignado un nombre a una ruta determinada, puede usar el
nombre de la ruta al generar URL o redireccionamientos a través de la
función de ruta global:

// Generating URLs...
$url = route('profile');

// Generating Redirects...
return redirect()->route('profile');

Si la ruta nombrada define parámetros, puede pasar los parámetros como segundo
argumento a la función de ruta. Los parámetros dados se insertarán
automáticamente en la URL en sus posiciones correctas:

Route::get('user/{id}/profile', function ($id) {
    //
})->name('profile');

$url = route('profile', ['id' => 1]);

Grupos de rutas
===============

Los grupos de rutas le permiten compartir atributos de ruta, como middleware o
espacios de nombres, en una gran cantidad de rutas sin necesidad de definir esos
atributos en cada ruta individual. Los atributos compartidos se especifican en
un formato de matriz como primer parámetro del método Route::group.

Los grupos anidados intentan "fusionar" atributos de forma inteligente con su
grupo principal. Middleware y where condiciones se combinan mientras se agregan
nombres, espacios de nombres y prefijos. Los delimitadores de espacio de nombres
y las barras inclinadas en los prefijos de URI se agregan automáticamente cuando
corresponde.

Middleware
==========

Para asignar middleware a todas las rutas dentro de un grupo, puede utilizar el
método de middleware antes de definir el grupo. El middleware se ejecuta en el
orden en el que se enumeran en la matriz:

Route::middleware(['first', 'second'])->group(function () {
    Route::get('/', function () {
        // Uses first & second Middleware
    });

    Route::get('user/profile', function () {
        // Uses first & second Middleware
    });
});

Namespaces
==========

Otro caso de uso común para los grupos de rutas es asignar el mismo namespace
a un grupo de controladores usando el método del espacio de nombres:

Route::namespace('Admin')->group(function () {
    // Controllers Within The "App\Http\Controllers\Admin" Namespace
});

Recuerde, de forma predeterminada, RouteServiceProvider incluye sus archivos de
ruta dentro un grupo de namespace, lo que le permite registrar rutas de
controlador sin especificar el prefijo completo del namespace
App\Http\Controllers. Por lo tanto, solo necesita especificar la parte del
namespace que viene después del namespace base App\Http\Controllers.

Rutas de sub dominios
=====================

Los grupos de rutas también se pueden usar para manejar el enrutamiento de
subdominios. A los subdominios se les pueden asignar parámetros de ruta al igual
que los URI de ruta, lo que le permite capturar una parte del subdominio para
usar en su ruta o controlador. El subdominio se puede especificar llamando al
método de dominio antes de definir el grupo:

Route::domain('{account}.myapp.com')->group(function () {
    Route::get('user/{id}', function ($account, $id) {
        //
    });
});

Prefijos de rutas
=================

El método de prefijo puede usarse para prefijar cada ruta en el grupo con un URI
dado. Por ejemplo, es posible que desee prefijar todos los URI de ruta dentro
del grupo con admin:

Route::prefix('admin')->group(function () {
    Route::get('users', function () {
        // Matches The "/admin/users" URL
    });
});

Prefijos de nombre de ruta
==========================

El método del nombre se puede utilizar para prefijar cada nombre de ruta en el
grupo con una cadena determinada. Por ejemplo, es posible que desee agregar el
prefijo admin a todos los nombres de las rutas agrupadas. La cadena dada tiene
el prefijo del nombre de la ruta exactamente como se especifica, por lo que nos
aseguraremos de proporcionar el final . carácter en el prefijo:

Route::name('admin.')->group(function () {
    Route::get('users', function () {
        // Route assigned name "admin.users"...
    })->name('users');
});

Enlace de modelo de ruta
========================

Al inyectar un ID de modelo a una ruta o acción de controlador, a menudo
consultará para recuperar el modelo que corresponde a ese ID. El enlace del
modelo de ruta de Laravel proporciona una forma conveniente de inyectar
automáticamente las instancias del modelo directamente en sus rutas. Por
ejemplo, en lugar de inyectar la ID de un usuario, puede inyectar toda la
instancia del modelo de usuario que coincida con la ID dada.

Enlace implícito
================

Laravel resuelve automáticamente los modelos Eloquent definidos en rutas o
acciones de controlador cuyos nombres de variables con sugerencias de tipo
coinciden con el nombre de un segmento de ruta. Por ejemplo:

Route::get('api/users/{user}', function (App\User $user) {
    return $user->email;
});

Dado que la variable $ user está insinuada como el modelo App\User Eloquent y el
nombre de la variable coincide con el segmento de URI de {usuario}, Laravel
inyectará automáticamente la instancia del modelo que tiene una ID que coincide
con el valor correspondiente del URI de solicitud. Si no se encuentra una
instancia de modelo coincidente en la base de datos, se generará automáticamente
una respuesta HTTP 404.

Fallback Routes o Rutas de respaldo
===================================

Con el método Route::fallback, puede definir una ruta que se ejecutará cuando
ninguna otra ruta coincida con la solicitud entrante. Normalmente, las
solicitudes no gestionadas generarán automáticamente una página "404" a través
del controlador de excepciones de su aplicación. Sin embargo, dado que puede
definir la ruta alternativa dentro de su archivo routes/web.php, todo el
middleware del grupo de middleware web se aplicará a la ruta. Puede agregar
middleware adicional a esta ruta según sea necesario:

Route::fallback(function () {
    //
});

Limitación de tasa
==================

Laravel incluye un middleware para limitar el acceso a las rutas dentro de su
aplicación. Para comenzar, asigne el middleware del throttle a una ruta o grupo
de rutas. El middleware throttle acepta dos parámetros que determinan la
cantidad máxima de solicitudes que se pueden realizar en una cantidad
determinada de minutos. Por ejemplo, especifiquemos que un usuario autenticado
puede acceder al siguiente grupo de rutas 60 veces por minuto:

Route::middleware('auth:api', 'throttle:60,1')->group(function () {
    Route::get('/user', function () {
        //
    });
});

Método de formulario suplantación
=================================

Los formularios HTML no admiten acciones PUT, PATCH o DELETE. Por lo tanto, al
definir rutas PUT, PATCH o DELETE a las que se llama desde un formulario HTML,
deberá agregar un campo _method oculto al formulario. El valor enviado con el
campo _method se utilizará como método de solicitud HTTP:

<form action="/foo/bar" method="POST">
    <input type="hidden" name="_method" value="PUT">
    <input type="hidden" name="_token" value="{{ csrf_token() }}">
</form>

Puede usar la directiva @method Blade para generar la entrada _method:

<form action="/foo/bar" method="POST">
    @method('PUT')
    @csrf
</form>

Verbos HTTP
===========

Estos verbos realizan las siguientes acciones:

GET: recupera recursos.

POST: crea un recurso.

PUT/PATCH: modifica un recurso.

DELETE: elimina un recurso.

Partial Resource Routes

Rutas de recursos o resource Routes
===================================

Al declarar una ruta de recursos, puede especificar un subconjunto de acciones
que el controlador debe manejar en lugar del conjunto completo de acciones
predeterminadas:

Route::resource('photos', PhotoController::class)->only([
    'index', 'show'
]);

Route::resource('photos', PhotoController::class)->except([
    'create', 'store', 'update', 'destroy'
]);

Rutas de recursos de API
========================

Al declarar rutas de recursos que serán consumidas por las API, normalmente
querrá excluir rutas que presenten plantillas HTML como crear y editar. Por
conveniencia, puede utilizar el método apiResource para excluir automáticamente
estas dos rutas:

Route::apiResource('photos', PhotoController::class);

===========================================
Agregar una nueva ruta para mostrar mensaje
===========================================

En mysite/router/web.php agregamos lo siguiente:

Route::get('/hola', function () {
    echo "Hola!!!";
});

ó

Route::get('/greeting', function () {
    return 'Hello!!!';
});

Ahora visitamos http://127.0.0.1:8000/hola y veremos "Hola!!!".

Otro ejemplo:

En este ejmplo le vamos a pasar el valor desde la url al parámetro de la función
que lo está esperando, osea "name".

Route::get('articles/{name}', function ($name) {
    echo "El nombre que has colocado es: ".$name;
});

Si visitamos:

http://127.0.0.1:8000/articles/carlos

En el navegador veríamos:

El nombre que has colocado es: carlos

Ejemplo de una ruta con parámetro opcional
==========================================

Agregamos un ? luego de {name y en el parámetro de la función también podemos
colocar una cadena por defecto que se mostrará si no se coloca parámetro en la
url.

Route::get('articles/{name?}', function ($name = "No colocó nombre") {
    echo "El nombre que has colocado es: ".$name;
});

Si visitamos http://127.0.0.1:8000/articles/ veremos:

El nombre que has colocado es: No colocó nombre

Ejemplo de un prefijo para unas rutas
=====================================

Tenemos la ruta "articles" y dentro contiene un grupo de rutas:

Route::prefix('articles')->group(function () {
    /*Route::get('view/{article?}', function ($article = "Vacío" ) {
        echo $article;
    });*/
    Route::get('view', function () {
        echo "view";
    });
    Route::get('view2', function () {
        echo "view2";
    });
});

Accecibles desde http://127.0.0.1:8000/articles/view y
http://127.0.0.1:8000/articles/view2

Otro ejemplo pero recibiendo parámetro:

Route::prefix('articles')->group(function () {
    Route::get('view/{article?}', function ($article = "Vacío" ) {
        echo $article;
    });
});

Si vicitamos http://127.0.0.1:8000/articles/view/casa veremos:

casa

==============
Vistas o views
==============

Las vistas contienen el HTML proporcionado por su aplicación y separan la lógica
de su controlador/aplicación de su lógica de presentación. Las vistas se
almacenan en el directorio resources/views.

Una vista simple podría verse así:

<!-- View stored in resources/views/greeting.blade.php -->

<html>
    <body>
        <h1>Hello</h1>
    </body>
</html>

====================================
Crear una ruta y una vista sencillas
====================================

Crear una ruta
==============

En mysite/router/web.php agregamos lo siguiente:

Route::get('/hola', function () {
    return view('HolaMundo');
});

Como puede ver, el primer argumento pasado al asistente de vista corresponde al
nombre del archivo de vista en el directorio resources/views.

Crear una vista
===============

En mysite/resources/views/ creamos HolaMundo.blade.php

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Laravel</title>
    </head>
    <body>
        <p>Hola!!!</p>
    </body>
</html>

Ahora visitamos http://127.0.0.1:8000/hola y veremos "Hola!!!".

-----

Las vistas también pueden estar anidadas dentro de los subdirectorios del
directorio resources/views. La notación de "puntos" se puede utilizar para hacer
referencia a vistas anidadas. Por ejemplo, si su vista está almacenada en
resources/views/admin/profile.blade.php, puede hacer referencia a ella así:

Route::get('/admin', function () {
    return view('admin.profile');
});

ó

Route::get('/admin', function () {
    return view('admin.profile',[]);
});

Pasar datos a las vistas
========================

Se pueden pasar datos a la vista guardandolos en un arreglo en las rutas:

-----

web.php

Route::get('/', function () {
    return view('greeting', ['name' => 'James']);
});

Como puede ver, el primer argumento pasado al helper de la vista corresponde al
nombre del archivo de vista en el directorio resources/views. El segundo
argumento es una matriz de datos que deben estar disponibles para la vista. En
este caso, estamos pasando la variable de nombre, que se muestra en la vista
utilizando la sintaxis Blade.

-----

greeting.blade.php

<!DOCTYPE html>
<html lang="">
    <head>
        <meta charset="utf-8">
        <title>Laravel</title>
    </head>
    <body>
        <h1>Hello, {{ $name }}</h1>
    </body>
</html>

-----

Otro ejemplo:

return view('greetings', ['name' => 'Victoria']);

Al pasar información de esta manera, los datos deben ser una matriz con pares
clave/valor. Dentro de su vista, puede acceder a cada valor usando su clave
correspondiente, como <?php echo $key; ?>. Como alternativa a pasar una matriz
completa de datos a la función helper de la vista, puede usar el método with
para agregar datos individuales a la vista:

return view('greeting')->with('name', 'Victoria');

-----

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Laravel</title>
    </head>
    <body>
        <h1>Hello, {{ $name }}</h1>
        <br />
        <?php echo $name; ?>
    </body>
</html>

¿Qué es blade en laravel?
=========================

Blade es un motor de plantillas simple y a la vez poderoso proporcionado por
Laravel. A diferencia de otros motores de plantillas populares de PHP, Blade no
te impide utilizar código PHP plano en tus vistas.

=============
Controladores
=============

Crear un controlador desde la línea de comandos
===============================================

Existe varias formas de crear tu controlador, una es creándolo manualmente y
otra desde la línea de comando, personalmente prefiero este último método, es
cuestión de gustos. El comando a utilizar será la siguiente:

$ php artisan make:controller HolaMundo

Para verificar que se creó correctamente podemos ir a la ruta de nuestro
proyecto: /app/Http/Controllers/HolaMundo.php, observando el siguiente código:

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class HolaMundo extends Controller
{
    //
}

====================================================
Crear una ruta, un controlador y una vista sencillas
====================================================

Funciona hasta Laravel 7, con el 8 no funciona de esta manera a menos que se
especifique la ruta donde está el controlador.

1) En mysite/routes/web.php agregamos:

Route::get('/miruta','MiController@miFuncion');

Para Laravel 8:
Route::get('/miruta','App\Http\Controllers\MiController@miFuncion');

ó

use App\Http\Controllers\MiController;

Route::get('/miruta',[MiController::class, 'miFuncion']);

2) Creamos MiController.php en mysite7/app/Http/Controllers/ y debe contener lo
siquiente:

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class MiController extends Controller
{
    public function miFuncion() {
        return view('mivista');
    }
}

3) Creamos mivista.blade.php en mysite7/resources/views/mivista.blade.php con el
siguiente contenido:

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Laravel</title>
    </head>
    <body>
        <p>zzzz</p>
    </body>
</html>

4) Visitamos http://127.0.0.1:8000/miruta y deberíamos poder ver la vista
creada.

=======
Fuentes
=======

-http://blogger1889.blogspot.com/2017/07/hola-mundo-con-laravel.html

============================================================================
Crear una ruta que reciba parámetro y un controlador que reciba el parámetro
y muestre por pantalla el valor recibido.
============================================================================

web.php

use App\Http\Controllers\MyController;

Route::get('myroute/{id}',[MyController::class, 'myFuncition']);

-----

MyController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class MyController extends Controller
{
    public function myFuncition($id) {
        dd($id);
    }
}

-----

Si visitamos http://127.0.0.1:8000/myroute/1 debemos ver:

"1"

============
Función dd()
============

Es como un var dump, es un helper de Laravel.

Podemos usar dd() cuando necesitemos que el sistema nos devuelva algo para
probar:

dd("Mensajes de prueba");

-----

Obtener todo el contenido del objeto request

dd($request());

-----

dd($request->all());

Devuelve todos los datos de la request incluyendo:

-Datos de formulario (POST, PUT, PATCH)
-Query strings (GET parameters)
-Route parameters
-Archivos subidos (pero como instancias de UploadedFile)

-----

dd($request->input());

-Sin parámetros: Igual que all()
-Con parámetro: Devuelve un valor específico o valor por defecto
-NO incluye archivos en la colección cuando se usa sin parámetros

=================
Función hasFile()
=================

El método hasFile() nos sirve para comprar si estamos recibiendo un archivo
en el controlador a través del request, es decir si estamos enviando el
archivo desde un formulario o si se está recibiendo vacío o nulo.

if ($request->hasFile('photo')) {
    dd("Estoy recibiendo el archivo photo");
}
else {
   dd("No estoy recibiendo el archivo photo");
}

===============================================
Consultar la base de datos desde un controlador
===============================================

web.php

use App\Http\Controllers\TestController;

Route::get('view/{id}',[TestController::class, 'view']);

-----

TestController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Article;

class TestController extends Controller
{
    public function view($id) {
        $article = Article::find($id);
        dd($article);
    }
}

Si vamos al navegador y visitamos http://127.0.0.1:8000/view/1 veremos algo
como:

App\Article {#213 ▼
  #table: "articles"
  #fillable: array:4 [▶]
  #connection: "pgsql"
  #primaryKey: "id"
  #keyType: "int"
  +incrementing: true
  #with: []
  #withCount: []
  #perPage: 15
  +exists: true
  +wasRecentlyCreated: false
  #attributes: array:7 [▶]
  #original: array:7 [▶]
  #changes: []
  #casts: []
  #dates: []
  #dateFormat: null
  #appends: []
  #dispatchesEvents: []
  #observables: []
  #relations: []
  #touches: []
  +timestamps: true
  #hidden: []
  #visible: []
  #guarded: array:1 [▶]
}

Esto es porque ya tenemos una tabla Article que tiene guardados datos en la base
de datos.

====================================================================
Consutlar los datos relacionados a un artículo, desde el controlador
====================================================================

TestController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Article;

class TestController extends Controller
{
    public function view($id) {
        $article = Article::find($id);
        $article->category;
        $article->user;
        $article->tag;
        dd($article);
    }
}

Si visitamos http://127.0.0.1:8000/view/1 veremos:

App\Article {#213 ▼
  #table: "articles"
  #fillable: array:4 [▶]
  #connection: "pgsql"
  #primaryKey: "id"
  #keyType: "int"
  +incrementing: true
  #with: []
  #withCount: []
  #perPage: 15
  +exists: true
  +wasRecentlyCreated: false
  #attributes: array:7 [▶]
  #original: array:7 [▶]
  #changes: []
  #casts: []
  #dates: []
  #dateFormat: null
  #appends: []
  #dispatchesEvents: []
  #observables: []
  #relations: array:2 [▶]
  #touches: []
  +timestamps: true
  #hidden: []
  #visible: []
  #guarded: array:1 [▶]
}

Donde "#relations: array:2 [▶]" se despliega al darle click:

#relations: array:2 [▼
  "category" => App\Category {#214 ▶}
  "user" => App\User {#889 ▶}
]

y estos 2 ítems a su vez se pueden desplegar para ver los demás datos asociados.

==========================================================
Crear un registro en la base de datos desde un controlador
==========================================================

En este ejemplo vamos a crear un usuario en la base de datos.

-----

Routes.php

<?php

use App\Http\Controllers\TestController;

Route::get('create',[TestController::class, 'create']);

-----

TestController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Article;
use App\User;

class TestController extends Controller
{
    public function create() {
        $user = new User;
        $user->name='Argenis';
        $user->email='aosorio@mail.com';
        $user->password=bcrypt('123456');
        $user->save();
    }
}

Al visitar http://127.0.0.1:8000/create/ nos debe crear el registro en la base
de datos.

===============================================================
Actualizar un registro en la base de datos desde un controlador
===============================================================

En este ejemplo vamos a actualizar el email de un usuario registrado en la base
de datos cuyo id sea 1.

-----

Routes.php

<?php

use App\Http\Controllers\TestController;

Route::get('update',[TestController::class, 'update']);

-----

TestController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\User;

class TestController extends Controller
{
    public function update() {
        $user = User::find(1);
        $user->email='another@mail.com';
        $user->save();
        dd($user);
    }
}

Al visitar http://127.0.0.1:8000/update/ nos debe actualizar el email del
registro con id igual a 1 en la base de datos.

===============================================================================
Actualizar un registro en la base de datos desde un controlador pasandole el id
===============================================================================

En este ejemplo vamos a actualizar el email de un usuario registrado en la base
pasando el id desde la url.

-----

Routes.php

<?php

use App\Http\Controllers\TestController;

Route::get('update/{id}',[TestController::class, 'update']);

-----

TestController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\User;

class TestController extends Controller
{
    public function update($id) {
        $user = User::find($id);
        $user->email='xxx@mail.com';
        $user->save();
        dd($user);
    }
}

Al visitar http://127.0.0.1:8000/update/1 nos debe actualizar el el email del
registro en la base de datos que tenga el id igual a 1.

=============================================================
Eliminar un registro en la base de datos desde un controlador
=============================================================

En este ejemplo vamos a eliminar un usuario registrado en la base de datos cuyo
id sea 1.

-----

Routes.php

<?php

use App\Http\Controllers\TestController;

Route::get('delete',[TestController::class, 'delete']);

-----

TestController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\User;

class TestController extends Controller
{
    public function delete() {
        $user = User::find(4);
        $user->delete();
        dd($user);
    }
}

Al visitar http://127.0.0.1:8000/delete/ nos debe eliminar el registro en la
base de datos con el id igual a 4.

=============================================================================
Eliminar un registro en la base de datos desde un controlador pasándole el id
por la url como parámetro
=============================================================================

En este ejemplo vamos a eliminar un usuario registrado en la base de datos cuyo
id sera el que le pasemos por la url como parámetro.

-----

Routes.php

<?php

use App\Http\Controllers\TestController;

Route::get('delete/{id}',[TestController::class, 'delete']);

-----

TestController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\User;

class TestController extends Controller
{
    public function delete($id) {
        $user = User::find($id);
        $user->delete();
        //User::destroy($id);
        dd($user);
    }
}

Al visitar http://127.0.0.1:8000/delete/1 nos debe eliminar el registro en la
base de datos que tenga el id igual a 1.

También podriamos destruir el registro directamente con el modelo si tenemos su
ID:

User::destroy($id);

===============================================
Pasar valores a las vistas desde el controlador
===============================================

Route::get('article',[TestController::class, 'article']);

-----

class TestController extends Controller
{
    public function article() {
        $article = "Some content";
        return view('article', ['data'=>$article]);
    }
}

-----

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Article</title>
    </head>
    <body>
        <p>Article</p>
        <?php echo $data; ?>
    </body>
</html>

Si visitamos

http://127.0.0.1:8000/article veremos:

"Some content"

================================================================
Pasar valores a las vista desde el controlador mediante un query
================================================================

Route::get('article/{id}',[TestController::class, 'article']);

-----

class TestController extends Controller
{
    public function article($id) {
        $article = Article::find($id);
        return view('article', ['data'=>$article]);
    }
}

-----

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Article</title>
    </head>
    <body>
        <p>Article</p>
        <!-- Se pueden consultar los datos así -->
        <?php echo $data; ?>
        <br />
        <!-- O acceder a los datos del arreglo article -->
        <?php echo $data->title; ?>
    </body>
</html>

Si visitamos http://127.0.0.1:8000/article/1 veremos, siempre y cuando haya
datos en la base de datos:

Article
{"id":1,"title":"Noticia de \u00faltima hora","content":"Contenido de la noticia","user_id":1,"category_id":1,"created_at":"2021-05-06 03:25:24","updated_at":"2021-05-06 03:25:24"}
Noticia de última hora

===================================================
Rutas, Controladores y Vistas para un CRUD sencillo
===================================================

List de CRUD
============

Listar todos los registros guardaros:

Vamos a crear en nuestro archivo de rutas un grupo de rutas asociadas a cada uno
de los metodos (index, create, store, show, edit, update, delete), esto se hace
con una ruta de tipo Resource o recurso, modificando el archivo routes agregando
el siguiente codigo:

Route::resource('students', 'StudentController');

-----

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Student;
use App\Http\Requests\StudentRequest;

class StudentController extends Controller
{
    public function index()
    {
        $students = Student::get();
        return view('students.index')->with('students', $students);
    }
}

-----

resources/views/students/index.blade.php

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Students</title>
  </head>
  <body>
    <p>Students</p>
    @foreach ($students as $student)
      <p>
        -First name: {{ $student->first_name }}
        <br />
        -Last name: {{ $student->last_name }}
        <br />
        -Identification number: {{ $student->identification_number }}
      </p>
    @endforeach
  </body>
</html>

También podemos agregar una tabla html:

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Students</title>
  </head>
  <body>
    <p>List of students</p>
    <table border="1px" cellspacing="0px" style="width:100%;">
      <thead>
        <tr>
          <th class="text-center">ID</th>
          <th class="text-center">First name</th>
          <th class="text-center">Last name</th>
          <th class="text-center">Identification number</th>
          <th class="text-center">Actions</th>
        </tr>
      </thead>
      <tbody>
      @foreach ($students as $student)
      <tr>
        <td class="text-center">{{ $student->id }}</td>
        <td class="text-center">{{ $student->first_name }}</td>
        <td class="text-center">{{ $student->last_name }}</td>
        <td class="text-center">{{ $student->identification_number }}</td>
        <td>
        </td>
      </tr>
      @endforeach
      </tbody>
    </table>
  </body>
</html>

Create del CRUD
===============

Método store - Funcion de almacenamiento
========================================

Este metodo es donde despues de haber entrado a create se reciben los datos y se
guardan en la base de datos, para poder recibir la informacion en este ejemplo
vamos a usar la clase Request que significa peticion y es una clase que Laravel
agrega por nosotros cuando creamos el controlador, vamos a pasar por parametro
la peticion en el metodo definiendo que es una variable de la clase Request y
despues de eso podemos recuperar por el nombre del campo del formulario(atributo
name) la informacion enviada, entonces el metodo quedaria de la siguiente forma:

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Student;
use App\Http\Requests\StudentRequest;

class StudentController extends Controller
{
    public function index()
    {
        $students = Student::get();
        return view('students.index')->with('students', $students);
    }

    public function create()
    {
        return view('students.create');
    }

    public function store(Request $request)
    {
        $student = new Student($request->all());
        $student->save();
        return redirect()->route('students.index');
    }
}

-----

app/Http/Requests/Request.php

<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

abstract class Request extends FormRequest
{
    //
}

-----

resources/views/students/create.blade.php

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Create</title>
  </head>
  <body>
    <p>Create student</p>
    {!! Form::open([ 'route' => 'students.store', 'method' => 'POST']) !!}
      <div class="form-group">
        {!! Form::label('first_name', 'First name') !!}
        {!! Form::text('first_name', null) !!}
      </div>

      <div class="form-group">
        {!! Form::label('last_name', 'Last name') !!}
        {!! Form::text('last_name', null) !!}
      </div>

      <div class="form-group">
        {!! Form::label('identification_number', 'Identification number') !!}
        {!! Form::text('identification_number', null) !!}
      </div>

      <div class="form-group">
        {!! Form::submit('Save') !!}
      </div>
    {!! Form::close() !!}
  </body>
</html>

Para poder acceder a a create agregamos en la vista de index el siguiente enlace

<a href="{{ route('students.create') }}">NEW</a>

tal que:

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Students</title>
  </head>
  <body>
    <p>List of students</p>
    <a href="{{ route('students.create') }}">NEW</a>
    <table border="1px" cellspacing="0px" style="width:100%;">
      <thead>
        <tr>
          <th class="text-center">ID</th>
          <th class="text-center">First name</th>
          <th class="text-center">Last name</th>
          <th class="text-center">Identification number</th>
          <th class="text-center">Actions</th>
        </tr>
      </thead>
      <tbody>
      @foreach ($students as $student)
      <tr>
        <td class="text-center">{{ $student->id }}</td>
        <td class="text-center">{{ $student->first_name }}</td>
        <td class="text-center">{{ $student->last_name }}</td>
        <td class="text-center">{{ $student->identification_number }}</td>
        <td>
        </td>
      </tr>
      @endforeach
      </tbody>
    </table>
  </body>
</html>

create.blade.php también puede contener un formulario normal sin hacer uso de
Laravel Collective

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Create student</title>
  </head>
  <body>
    <h1>Create student</h1>
    <form action="{{ route('students.store') }}" method="POST">@csrf
      <div>
        <label>First name</label>
        <input type="text" name="first_name">
      </div>
      <div>
        <label>Last name</label>
        <input type="text" name="last_name">
      </div>
      <div>
        <label>Identification number</label>
        <input type="text" name="identification_number">
      </div>
      <button type="submit" >SAVE</button>
    </form>
  </body>
</html>

Update de CRUD
==============

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Student;
//use App\Http\Requests\StudentRequest;

class StudentController extends Controller
{
    /*
    |--------------------------------------------------------------------------
    | LIST
    |--------------------------------------------------------------------------
    */
    public function index()
    {
        $students = Student::get();
        return view('students.index')->with('students', $students);
    }

    /*
    |--------------------------------------------------------------------------
    | CREATE
    |--------------------------------------------------------------------------
    */
    public function create()
    {
        return view('students.create');
    }

    public function store(Request $request)
    {
        $student = new Student($request->all());
        $student->save();
        return redirect()->route('students.index');
    }

    /*
    |--------------------------------------------------------------------------
    | UPDATE
    |--------------------------------------------------------------------------
    */
    public function edit($id)
    {
        $student = Student::find($id);
        return view('students.edit')->with('student',$student);
    }

    public function update(Request $request, $id)
    {
        $student = Student::find($id);
        $student->first_name = $request->input('first_name');
        $student->last_name = $request->input('last_name');
        $student->identification_number = $request->input('identification_number');
        $student->save();
        return redirect()->route('students.index');
    }
}

-----

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Update</title>
  </head>
  <body>
    <p>Update student</p>
    {!! Form::model($student, ['route' => ['students.update', $student], 'method' => 'PUT']) !!}
      <div class="form-group">
        {!! Form::label('first_name', 'First name') !!}
        {!! Form::text('first_name', null) !!}
      </div>

      <div class="form-group">
        {!! Form::label('last_name', 'Last name') !!}
        {!! Form::text('last_name', null) !!}
      </div>

      <div class="form-group">
        {!! Form::label('identification_number', 'Identification number') !!}
        {!! Form::text('identification_number', null) !!}
      </div>

      <div class="form-group">
        {!! Form::submit('Save') !!}
      </div>
    {!! Form::close() !!}
  </body>
</html>

===================================================
Filtrar los datos de una consulta en el controlador
===================================================

En este ejmplo vamos a ordenar los reqistros por el ID pero de manera
descendente y también solo vamos a mostrar 3 registros.

public function index()
{
    $users = User::orderBy('id', 'ASC')->paginate(3);
    //$users = User::orderBy('id', 'DESC')->paginate(3);
    return view('users.index')->with('users', $users);
}

Mensaje cuando se guarda un formulario
======================================

Por ejemplo en el caso del formulario create y edit, cuando guardemos, podemos
enviar un mensaje a la vista con:

->with('info','Student was created!');

->with('info','Student data was updated');

Tal que:

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Student;
//use App\Http\Requests\StudentRequest;

class StudentController extends Controller
{
    /*
    |--------------------------------------------------------------------------
    | LIST
    |--------------------------------------------------------------------------
    */
    public function index()
    {
        $students = Student::get();
        return view('students.index')->with('students', $students);
    }

    /*
    |--------------------------------------------------------------------------
    | CREATE
    |--------------------------------------------------------------------------
    */
    public function create()
    {
        return view('students.create');
    }

    public function store(Request $request)
    {
        $student = new Student($request->all());
        $student->save();
        return redirect()->route('students.index')->with('info','Student was created!');
    }

    /*
    |--------------------------------------------------------------------------
    | UPDATE
    |--------------------------------------------------------------------------
    */
    public function edit($id)
    {
        $student = Student::find($id);
        return view('students.edit')->with('student',$student);
    }

    public function update(Request $request, $id)
    {
        $student = Student::find($id);
        $student->first_name = $request->input('first_name');
        $student->last_name = $request->input('last_name');
        $student->identification_number = $request->input('identification_number');
        $student->save();
        return redirect()->route('students.index')->with('info','Student data was updated!');
    }
}

Y agregamos en index que es la que va a recibir el mensaje lo sigueinte:

@if(Session::has('info'))
  {{ Session::get('info') }}
@endif

Tal que:

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Students</title>
  </head>
  <body>
    @if(Session::has('info'))
      Message: {{ Session::get('info') }}
    @endif
    <p>List of students</p>
    <a href="{{ route('students.create') }}">NEW</a>
    <table border="1px" cellspacing="0px" style="width:100%;">
      <thead>
        <tr>
          <th class="text-center">ID</th>
          <th class="text-center">First name</th>
          <th class="text-center">Last name</th>
          <th class="text-center">Identification number</th>
          <th class="text-center">Actions</th>
        </tr>
      </thead>
      <tbody>
      @foreach ($students as $student)
      <tr>
        <td class="text-center">{{ $student->id }}</td>
        <td class="text-center">{{ $student->first_name }}</td>
        <td class="text-center">{{ $student->last_name }}</td>
        <td class="text-center">{{ $student->identification_number }}</td>
        <td>
          <a href="{{ route('students.edit', $student->id) }}">UPDATE</a>
        </td>
      </tr>
      @endforeach
      </tbody>
    </table>
  </body>
</html>

Show del CRUD
=============

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Student;
//use App\Http\Requests\StudentRequest;

class StudentController extends Controller
{
    /*
    |--------------------------------------------------------------------------
    | LIST
    |--------------------------------------------------------------------------
    */
    public function index()
    {
        $students = Student::get();
        return view('students.index')->with('students', $students);
    }

    /*
    |--------------------------------------------------------------------------
    | CREATE
    |--------------------------------------------------------------------------
    */
    public function create()
    {
        return view('students.create');
    }

    public function store(Request $request)
    {
        $student = new Student($request->all());
        $student->save();
        return redirect()->route('students.index')->with('info','Student was created!');
    }

    /*
    |--------------------------------------------------------------------------
    | UPDATE
    |--------------------------------------------------------------------------
    */
    public function edit($id)
    {
        $student = Student::find($id);
        return view('students.edit')->with('student',$student);
    }

    public function update(Request $request, $id)
    {
        $student = Student::find($id);
        $student->first_name = $request->input('first_name');
        $student->last_name = $request->input('last_name');
        $student->identification_number = $request->input('identification_number');
        $student->save();
        return redirect()->route('students.index')->with('info','Student data was updated!');
    }

    /*
    |--------------------------------------------------------------------------
    | SHOW
    |--------------------------------------------------------------------------
    */
    public function show($id)
    {
        $student = Student::find($id);
        return view('students.show', compact('student'));
    }
}

-----

show.blade.php

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Show</title>
  </head>
  <body>
    <p>Show student</p>
    <p>
      First name: {{ $student->first_name }}
    </p>
    <p>
      Last name: {{ $student->last_name }}
    </p>
    <p>
      Identification number: {{ $student->identification_number }}
    </p>
  </body>
</html>

Delete del CRUD
===============

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Student;
//use App\Http\Requests\StudentRequest;

class StudentController extends Controller
{
    /*
    |--------------------------------------------------------------------------
    | LIST
    |--------------------------------------------------------------------------
    */
    public function index()
    {
        $students = Student::get();
        return view('students.index')->with('students', $students);
    }

    /*
    |--------------------------------------------------------------------------
    | CREATE
    |--------------------------------------------------------------------------
    */
    public function create()
    {
        return view('students.create');
    }

    public function store(Request $request)
    {
        $student = new Student($request->all());
        $student->save();
        return redirect()->route('students.index')->with('info','Student was created!');
    }

    /*
    |--------------------------------------------------------------------------
    | UPDATE
    |--------------------------------------------------------------------------
    */
    public function edit($id)
    {
        $student = Student::find($id);
        return view('students.edit')->with('student',$student);
    }

    public function update(Request $request, $id)
    {
        $student = Student::find($id);
        $student->first_name = $request->input('first_name');
        $student->last_name = $request->input('last_name');
        $student->identification_number = $request->input('identification_number');
        $student->save();
        return redirect()->route('students.index')->with('info','Student data was updated!');
    }

    /*
    |--------------------------------------------------------------------------
    | SHOW
    |--------------------------------------------------------------------------
    */
    public function show($id)
    {
        $student = Student::find($id);
        return view('students.show', compact('student'));
    }

    /*
    |--------------------------------------------------------------------------
    | DELETE
    |--------------------------------------------------------------------------
    */
    public function destroy($id)
    {
        $student = Student::find($id);
        $student->delete();
        return redirect()->route('students.index')->with('info','Student data was deleted!');
    }
}

-----

Agregado formualario para eliminar desde la columna actions

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Students</title>
  </head>
  <body>
    @if(Session::has('info'))
      Message: {{ Session::get('info') }}
    @endif
    <p>List of students</p>
    <a href="{{ route('students.create') }}">
      <button>NEW</button>
    </a>
    <table border="1px" cellspacing="0px" style="width:100%;">
      <thead>
        <tr>
          <th class="text-center">ID</th>
          <th class="text-center">First name</th>
          <th class="text-center">Last name</th>
          <th class="text-center">Identification number</th>
          <th class="text-center">Actions</th>
        </tr>
      </thead>
      <tbody>
      @foreach ($students as $student)
      <tr>
        <td class="text-center">{{ $student->id }}</td>
        <td class="text-center">{{ $student->first_name }}</td>
        <td class="text-center">{{ $student->last_name }}</td>
        <td class="text-center">{{ $student->identification_number }}</td>
        <td>
          <a href="{{ route('students.edit', $student->id) }}">
            <button>UPDATE</button>
          </a>
          <a href="{{ route('students.show', $student->id) }}">
            <button>SHOW</button>
          </a>
          <form action="{{ route('users.destroy', $user->id) }}" method="POST">
            @csrf
            @method('DELETE')
            <button type="submit" onclick="return confirm('Are you sure you want to delete the record? ');">DELETE</button>
          </form>
        </td>
      </tr>
      @endforeach
      </tbody>
    </table>
  </body>
</html>

===========================
CRUD de usuarios de Laravel
===========================

1) Creamos una ruta de recursos:

Route::resource('users','UserController');

2) Creamos un controlador:

$ php artisan make:controller UserController

3) Editar el controlador creado y agregar las funciones index, create, store,
edit, update, show, destroy correspondientes.

4) Crear las vistas correspondientes a cada función del controlador.

=====
Blade
=====

Blade es el motor de plantillas simple pero poderoso provisto con Laravel. A
diferencia de otros motores de plantillas PHP populares, Blade no le impide usar
código PHP simple en sus vistas. De hecho, todas las vistas de Blade se compilan
en código PHP simple y se almacenan en caché hasta que se modifican, lo que
significa que Blade agrega esencialmente cero gastos generales a su aplicación.

Los archivos de vista Blade usan la extensión de archivo .blade.php y
generalmente se almacenan en el directorio de resources/views.

¿Qué es blade en laravel?
=========================

Blade es un motor de plantillas simple y a la vez poderoso proporcionado por
Laravel. A diferencia de otros motores de plantillas populares de PHP, Blade no
te impide utilizar código PHP plano en tus vistas.

Usando blade en la vista
========================

Ejemplo:

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Article</title>
    </head>
    <body>
        <p>Article</p>
        <!-- Imprimiendo valores con blade -->
        {{ $article->title }}
    </body>
</html>

==================
Ciclo for en blade
==================

@for ($i=0; $i<=5; $i++)
  {{ $i }}
@endfor

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Article</title>
    </head>
    <body>
        @for ($i=0; $i<=5; $i++)
          {{ $i }}
        @endfor
    </body>
</html>

Nos imprime.

0 1 2 3 4 5

===========
if en blade
===========

@if (1 == 1)
  {{ "Es igual a 1" }}
@endif

=========================
if, elseif, else en blade
=========================

<?php $records=[1,2,3] ?>
@if (count($records) === 1)
    I have one record!
@elseif (count($records) > 1)
    I have multiple records!
@else
    I don't have any records!
@endif

Ejemplos prácticos:

@if ($student->id == 1)
  El ID del user es igual a 1
@endif

-----

@if ($student->id == 1)
    El ID del user es igual a 1
@elseif ($student->id == 2)
    El ID del user es igual a 2
@else
    El ID del user es diferente de 1 y de 2.
@endif

-----

@if ($student->id == 1)
    <button>1</button>
@elseif ($student->id == 2)
    <button>2</button>
@else
@endif

================
foreach en blade
================

<?php $numbers=[1,2,3,4,5] ?>

@foreach ($numbers as $number)
  {{ $number }}
@endforeach

Otro ejemplo:

Como tags es una arreglo, debemos recorrerlo:

Accedmos a los tags asociados a article y los mostramos.

@foreach ($article->tags as $tag)
  {{ $tag->name }}
@endforeach

-----

@foreach ($users as $user)
    <p>This is user {{ $user->id }}</p>
@endforeach

================
forelse en blade
================

@forelse ($users as $user)
    <li>{{ $user->name }}</li>
@empty
    <p>No users</p>
@endforelse

=====================
Comentarios en blade
=====================

Blade también le permite definir comentarios en sus vistas.  Sin embargo, a
diferencia de los comentarios HTML, los comentarios Blade no se incluyen en el
HTML devuelto por su aplicación:

{{-- This comment will not be present in the rendered HTML --}}

===============================
Herencia de plantilla con Blade
===============================

Dos de los principales beneficios de utilizar Blade son la herencia de
plantillas y las secciones. Para empezar, echemos un vistazo a un ejemplo
sencillo.

base.blade.php

<html>
  <head>
    <title>App Name - @yield('title')</title>
  </head>
  <body>
    @section('header')
      aaaaaaaaaaaa
    @show

    @section('content')
      11111111111
    @show

    @section('footer')
      11111111111
    @show
  </body>
</html>

Como puede ver, este archivo base contiene un marcado HTML típico. Sin embargo,
tome nota de las directiva @section. La directiva @section, como su nombre lo
indica, define una sección de contenido

Ahora que hemos definido un diseño base para nuestra aplicación, definamos una
página secundaria que herede el diseño.

Al definir una vista secundaria, utilice la directiva Blade @extends para
especificar qué diseño debe "heredar" la vista secundaria. Las vistas que
extienden un diseño Blade pueden inyectar contenido en las secciones del diseño
utilizando las directivas @section.

child.blade.php

@extends('base')

@section('title', 'xxxxxxxx')

@section('header')
  <p>header, header, header</p>
@endsection

@section('content')
  @parent
  <p>content, content, content</p>
@endsection

@section('footer')
  <p>footer, footer, footer</p>
@endsection

-----

Si se agrega en la vista child alguna sección, el contenido será mostrado en
detrimento de la sección master de la vista base.

En este ejemplo, la sección content utiliza la directiva @parent para agregar
(en lugar de sobrescribir) contenido a la seccion content. La directiva @parent
será reemplazada por el contenido del diseño cuando se renderice la vista.

===========================
Directivas de autenticación
===========================

Las directivas @auth y @guest pueden usarse para determinar rápidamente si el
usuario actual está autenticado o es un invitado:

@auth
    // The user is authenticated...
@endauth

@guest
    // The user is not authenticated...
@endguest

Si es necesario, puede especificar la protección de autenticación que se debe
verificar al usar las directivas @auth y @guest:

@auth('admin')
    // The user is authenticated...
@endauth

@guest('admin')
    // The user is not authenticated...
@endguest

Include en blade
================

Include sirve para incluir los contenidos de otras vistas dentro de una sección:

Ejemplo:

Creamos list.blade.php

<ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
</ul>

y la podemos incluir dentro del bloque content de la vista child:

@extends('base')

@section('title')
    Article
@endsection

@section('header')
    <h1>This is the child header secction</h1>
@endsection

@section('content')
    @include('list')
@endsection

@section('footer')
@endsection

Si revisamos la vista en el navegador veremos la lista incluída en el bloque
content.

Partials en blade
=================

Es una carpeta que se crea en las views donde se pueden almacenar secciones del
código que compone la plantilla, pero esta carpeta pueden ser diferentes
carpetas y las podemos llamar de muchas maneras.

La directiva @yield
===================

La directiva @yield se usa para mostrar el contenido de una sección determinada.

En otras palabras, los yields básicamente lo que hacen es crear secciones desde
nuestra plantilla, para luego rellenarlas desde la vista donde estén siendo
usadas.

En base:

<title>App Name - @yield('title')</title>

En child:

@section('title')
  Index
@endsection

ó

@section('title', 'Page Title')

La sección se llama title porque así le pusimos al yield.

Si visitamos a child con el navegador veremos en title

App Name - Page title

Otro ejemplo:

@yield se trae todas las propiedades de la etiqueta en que esté declarada
incluyendo la etiqueta misma

En base:

<h1 class="title">@yield('TitlePost')</h1>

En child:

@section('TitlePost')
Some text...
@endsection

Esto se traduce en el código fuente del child en el navegador en:

<h1 class="title">Some text...</h1>

-----

Pasando un segundo parámetro a yield, pondremos una cadena por defecto

Base:

<title>@yield('title', 'Default')</title>

Child:

@section('title', 'Index')

Se traduce en:

<title>Index</title>

Si se deja @section('title') mostrará:

<title>Default</title>

=========================================
Mostrar datos en la vista, otros ejemplos
=========================================

Siguiendo el ejemplo del blog, en article.blade.php tenemos:

<h1>{{ $article->title }}</h1>
<br />
<p>{{ $article->content }}</p>
<br />
Author: {{ $article->user->name }}
<br />
Category: {{ $article->category->name }}

De esta manera accedemos a los datos de la tabla articles y todos lode datos de
sus tablas asociadas.

Llamar un css a una plantilla blade
===================================

Los archivos CSS se pueden guardar en cualquier lugar pero Laravel por defecto
crea la carpeta CSS en public/css en icluso crea un app.css

Con solo incluír en la plantilla:

<link rel="stylesheet" type="text/css" href="/css/app.css">

ya tenemos acceso a esos estilos.

Aunque se recomienda usando ladirectiva asset:

<link rel="stylesheet" type="text/css" href="{{ asset('css/app.css') }}">

asset lo que hace es situarse en la carpeta public y navegar por las carpetas
que le indiquemos hasta conseguir el archivo definido, en este caso app.css.

==========
Campo CSRF
==========

Siempre que defina un formulario HTML en su aplicación, debe incluir un campo de
token CSRF oculto en el formulario para que el middleware de protección CSRF
pueda validar la solicitud. Puede usar la directiva @csrf Blade para generar el
campo de token:

<form method="POST" action="/profile">
    @csrf

    ...
</form>

============
Campo método
============

Dado que los formularios HTML no pueden realizar solicitudes PUT, PATCH o
DELETE, deberá agregar un campo _method oculto para falsificar estos verbos
HTTP.

La directiva @method Blade puede crear este campo por usted:

<form action="/foo/bar" method="POST">
    @method('PUT')

    ...
</form>

=================================
Integrar Bootstrap en un proyecto
=================================

Los archivos CSS se pueden guardar en cualquier lugar pero Laravel por defecto
crea la carpeta CSS en public/css en icluso crea un app.css

1) Descargar los archivos necesarios para usar Bootstrap (css, js, jquery).

2) Crer una carpeta bootstrap en my-app/public/

3) Pegar adentro las carpetas css y js de Bootstrap y también la de Jquery.

4) Crear una plantilla que será la plantilla base y llamar a bootstrap con
lo necesario, ejemplo:

<!-- Bootstrap core CSS-->
<link rel="stylesheet" type="text/css" href="{{ asset ('bootstrap/css/bootstrap.min.css') }}">

<!-- Bootstrap core JavaScript-->
<script src="{{ asset ('bootstrap/js/jquery/jquery-3.3.1.slim.min.js') }}" type="text/javascript"></script>
<script src="{{ asset ('bootstrap/js/popper.min.js') }}" type="text/javascript"></script>
<script src="{{ asset ('bootstrap/js/bootstrap.min.js') }}" type="text/javascript"></script>

asset lo que hace es situarse en la carpeta public y navegar por las carpetas
que le indiquemos hasta conseguir el archivo definido, en este caso app.css.

En Laravel 5.8.x
================

Bootstrap viene incluído en esta versión de Laravel, por lo que hay hay que
ejecutar la compilación de los paquetes de node con:

$ npm run dev

Esto generara una modificación de los archivos:

public/css/app.css
public/js/app.js

Por lo cual solo resta hacer el llamado de los archivos en la plantilla base,
ejemplo:

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>@yield('title')</title>
    <!-- Bootstrap core CSS-->
    <link rel="stylesheet" type="text/css" href="{{ asset ('css/app.css') }}">
    <!-- Bootstrap core JavaScript-->
    <script src="{{ asset ('js/app.js') }}" type="text/javascript"></script>
  </head>
  <body>
    <script>
    $(document).ready(function(){
      alert("¡Hola esto es una alerta!");
    });
    </script>
    @section('content')
      Base content...
    @show
  </body>
</html>

===========================================================================
Consultar la versión de Laravel y de PHP directamente en una plantilla html
===========================================================================

Laravel v{{ Illuminate\Foundation\Application::VERSION }}
<br />
PHP v{{ PHP_VERSION }}

==============
Kits de inicio
==============

Para darle una ventaja en la construcción de su nueva aplicación Laravel, nos
complace ofrecer kits de inicio de aplicaciones y autenticación. Estos kits
configuran automáticamente su aplicación con las rutas, controladores y vistas
que necesita para registrar y autenticar a los usuarios de su aplicación.

Si bien puede utilizar estos kits de inicio, no son obligatorios.  Eres libre de
crear tu propia aplicación desde cero simplemente instalando una copia nueva de
Laravel.

Laravel Breeze
==============

Laravel Breeze es una implementación mínima y simple de todas las funciones de
autenticación de Laravel, que incluyen inicio de sesión, registro,
restablecimiento de contraseña, verificación de correo electrónico y
confirmación de contraseña. La capa de vista predeterminada de Laravel Breeze
está formada por plantillas Blade simples diseñadas con Tailwind CSS.  Breeze
proporciona un maravilloso punto de partida para comenzar una nueva aplicación
de Laravel.

Primero, debe crear una nueva aplicación Laravel, configurar su base de datos y
ejecutar sus migraciones de base de datos:

$ php artisan migrate

Una vez que haya creado una nueva aplicación Laravel, puede instalar Laravel
Breeze usando Composer:

$ composer require laravel/breeze --dev

Después de que Composer haya instalado el paquete Laravel Breeze, puede ejecutar
el comando de artisan $ breeze:install. Este comando publica las vistas de
autenticación, las rutas, los controladores y otros recursos de su aplicación.

Laravel Breeze publica todo su código en su aplicación para que tenga control
total y visibilidad sobre sus características e implementación. Después de
instalar Breeze, también debe compilar sus activos para que el archivo CSS de su
aplicación esté disponible:

$ php artisan breeze:install

$ npm install

$ npm run dev

$ php artisan migrate

A continuación, puede navegar a las URL /login o /register de su aplicación en
su navegador web. Todas las rutas de Breeze se definen en el archivo
routes/auth.php.

Breeze & Inertia
================

Laravel Breeze también ofrece una implementación de frontend Inertia.js
impulsada por Vue. Para usar la inercia stack, pase la opción --inertia al
ejecutar el comando breeze: install Artisan:

$ php artisan breeze:install --inertia

$ npm install

$ npm run dev

$ php artisan migrate

======================
Nombres para las rutas
======================

Las rutas con nombre permiten la generación conveniente de URL o
redireccionamientos para rutas específicas. Puede especificar un nombre para una
ruta encadenando el método de nombre en la definición de ruta:

Route::get('/user/profile', function () {
    //
})->name('profile');

También puede especificar nombres de ruta para las acciones del controlador:

Route::get(
    '/user/profile',
    [UserProfileController::class, 'show']
)->name('profile');

==========
Middleware
==========

El middleware proporciona un mecanismo conveniente para inspeccionar y filtrar
las solicitudes HTTP que ingresan a su aplicación.  Por ejemplo, Laravel incluye
un middleware que verifica que el usuario de su aplicación esté autenticado. Si
el usuario no está autenticado, el middleware redirigirá al usuario a la
pantalla de inicio de sesión de su aplicación.  Sin embargo, si el usuario está
autenticado, el middleware permitirá que la solicitud continúe en la aplicación.

Se puede escribir middleware adicional para realizar una variedad de tareas
además de la autenticación. Por ejemplo, un middleware de registro puede
registrar todas las solicitudes entrantes en su aplicación. Hay varios
middleware incluidos en el marco de Laravel, incluido el middleware para la
autenticación y la protección CSRF. Todos estos middleware se encuentran en el
directorio app/Http/Middleware.

===============================
Migraciones de la base de datos
===============================

Las migraciones son como un control de versiones para su base de datos, lo que
le permite a su equipo definir y compartir la definición del esquema de la base
de datos de la aplicación. Si alguna vez ha tenido que decirle a un compañero de
equipo que agregue manualmente una columna a su esquema de base de datos local
después de extraer sus cambios desde el control de fuente, se ha enfrentado al
problema que resuelven las migraciones de base de datos.

La fachada (facade) del esquema de Laravel proporciona soporte independiente de
la base de datos para crear y manipular tablas en todos los sistemas de base de
datos compatibles con Laravel. Normalmente, las migraciones utilizarán esta
fachada para crear y modificar tablas y columnas de bases de datos.

Generando migraciones
=====================

Puede utilizar el comando make:migration de artisan para generar una migración
de base de datos. La nueva migración se colocará en su directorio
database/migraciones. Cada nombre de archivo de migración contiene una marca de
tiempo que permite a Laravel determinar el orden de las migraciones:

$ php artisan make:migration create_flights_table

Laravel usará el nombre de la migración para intentar adivinar el nombre de la
tabla. Si Laravel puede determinar el nombre de la tabla a partir del nombre de
la migración, Laravel completará previamente el archivo de migración generado
con la tabla especificada. De lo contrario, simplemente puede especificar la
tabla en el archivo de migración anualmente.

Si desea especificar una ruta personalizada para la migración generada, puede
usar la opción --path al ejecutar el comando make:migration. La ruta dada debe
ser relativa a la ruta base de su aplicación.

Ejemplo
=======

Agregar el campo "type" a la tabla por defecto User de Laravel. Esta
modificación se realiza manualmente sobre el archivo User.php.

<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreateUsersTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->enum('type',['member','admin'])->default('member');
            $table->rememberToken();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('users');
    }
}

-----

Generar una nueva migración y crear una tabla llamada categories

$ php artisan make:migration add_categories_table --create=categories

Esto nos crea una estructura de migración básica, a la cual le agregamos el
campo "name" de tipo string y con un máximo de caracteres de 60, esta
modificación se realiza manualmente sobre el archivo.

Al crearla la migracion con --create=categories nos agrega campos por defecto en
la función up() y down() así como el método Schema.

<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AddCategoriesTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('categories', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string('name', 60);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('categories');
    }
}

Al crearla la migracion sin --create=categories nos crea la estrucuta de la
función up() y down() vacías.

<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AddCategoriesTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        //
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        //
    }
}

===========================
Estructura de una migración
===========================

Una clase de migración contiene dos métodos: up y down. El método up se usa para
agregar nuevas tablas, columnas o índices a su base de datos, mientras que el
método down debe revertir las operaciones realizadas por el método up.

=======================
Rolling Back Migrations
=======================

Para revertir la última operación de migración, puede utilizar el comando
rollback. Este comando revierte el último "lote" de migraciones, que puede
incluir varios archivos de migración:

$ php artisan migrate:rollback

Puede revertir un número limitado de migraciones proporcionando la opción al
comando de reversión. Por ejemplo, el siguiente comando revertirá las últimas
cinco migraciones:

$ php artisan migrate:rollback --step=5

El comando migrate:reset revertirá todas las migraciones de su aplicación:

$ php artisan migrate:reset

Ejemplo:

Cuando ejecutas una migración en Laravel, estás alterando la estructura de la
base de datos. Si realizas un rollback, estás revirtiendo esa última migración y
restaurando la estructura anterior de la base de datos.

Por ejemplo, si tienes una migración que agrega un campo "city" a la tabla
"profiles", y luego ejecutas el comando "php artisan migrate", se agregará el
campo a la tabla. Pero si luego realizas un rollback con el comando
"php artisan migrate:rollback", se eliminará ese campo de la tabla.

En cuanto a los datos, si se realiza un rollback después de agregar un campo,
los datos ingresados en ese campo se perderán. En el ejemplo que mencionaste, si
agregaste el campo "age" a la tabla "profiles" y luego realizas un rollback, se
eliminará el campo y cualquier dato ingresado en él se perderá.

==============================================
Restricciones de Foreign Key o lláves foráneas
==============================================

Laravel también proporciona soporte para crear restricciones de clave foránea,
que se utilizan para forzar la integridad referencial a nivel de la base de
datos. Por ejemplo, definamos una columna user_id en la tabla de publicaciones
que hace referencia a la columna id en una tabla de usuarios:

Schema::table('posts', function (Blueprint $table) {
    $table->unsignedBigInteger('user_id');

    $table->foreign('user_id')->references('id')->on('users');
});

También puede especificar la acción deseada para las propiedades "on delete" y
"on update" de la restricción:

$table->foreign('user_id')
      ->references('id')->on('users')
      ->onDelete('cascade');

Para eliminar una clave foránea, puede utilizar el método dropForeign. Las
restricciones de clave externa utilizan la misma convención de nomenclatura que
los índices. Entonces, concatenamos el nombre de la tabla y las columnas en la
restricción y luego agregaremos el sufijo "_foreign":

$table->dropForeign('posts_user_id_foreign');

O bien, puede pasar un valor de matriz que utilizará automáticamente el nombre
de restricción convencional al soltar:

$table->dropForeign(['user_id']);

Puede habilitar o deshabilitar las restricciones de clave externa dentro de sus
migraciones mediante los siguientes métodos:

Schema::enableForeignKeyConstraints();

Schema::disableForeignKeyConstraints();

Ejemplo de campo tipo integer para coumnas de tipo entero
=========================================================

$table->integer('votes');

Ejemplos de asignar relaciones entre tablas
===========================================

<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AddArticlesTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('articles', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string('title');
            $table->text('content');
            /* Asignando las relaciones de los Artículos con las categorías y
            los usuarios */
            $table->unsignedInteger('user_id');
            $table->unsignedInteger('category_id');
            $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
            $table->foreign('category_id')->references('id')->on('categories')->onDelete('cascade');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('articles');
    }
}

Ejemplo de relaciones Many to Many o muchos a muchos
====================================================

<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AddTagsTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('tags', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string('name');
            $table->timestamps();
        });
        /* Ejemplo de una relación muchos a muchos Many To Many
        para Articles $ Tags */
        Schema::create('article_tag', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->unsignedInteger('article_id');
            $table->unsignedInteger('tag_id');
            $table->foreign('article_id')->references('id')->on('articles');
            $table->foreign('tag_id')->references('id')->on('tags');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('tags');
    }
}

===============
Crear un modelo
===============

El nombre de los modelos debe ír como el nombre de la tabla pero en singular,
si tengo una tabla Categories mi modelo se debe llamar Category.

$ php artisan make:model Category

Al crear un modelo, se crea el archivo Category.php en /app/Category.php

Campos $fillable
================

Son los campos permitidos para mostrar los objetos json y suelen ser los mismos
campos definidos en las migraciones:

Ejemplo de un modelo de Artículo que se relaciona con categorías:

**Migración**

<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AddArticlesTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('articles', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string('title');
            $table->text('content');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('articles');
    }
}

**Modelo**

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    protected $table = "articles";
    protected $fillable = ['title','content','user_id','category_id'];
}

Luego, se ejecutan las migraciones para ver que todo esté bien:

$ php artisan migrate

======
Tinker
======

Tinker es un poderoso REPL (Read - Eval - Print - Loop) para Laravel

REPL son programas que están a la espera de que se les escriba comandos para ser
ejecutados continuamente, de ahí el nombre de
lectura - evaluación - impresión - bucle.

Este paquete se instala por defecto en Laravel.

Es una línea de comando que permite hacer pruebas, para acceder a ella tipeamos:

$ php artisan tinker

y si accedimos correctamente nos muestra:

Psy Shell v0.9.12 (PHP 7.4.15 — cli) by Justin Hileman
>>>

Ahora, como prueba, vamos a crear una varible y vamos guardar un arreglo dentro
de ella que contenga datos relacionados al modelo User.php

Crear un nuevo usuario
======================

>>> $user = ['name'=>'Carlos Portrait','email'=>'cportrait@mail.com','password'=>bcrypt('123456')]

Le damos enter y nos muestra nuestro arreglo:

=> [
     "name" => "Carlos Portrait",
     "email" => "cportrait@mail.com",
     "password" => "$2y$10$2VueR70ZHixDULSxIqZM8uCDbmT1rImpZsirYLzKNpRi7UdBTcaxG",
   ]
>>>

bcrypt() es una función para encriptar contraseñas y es usada por defecto en
Laravel.

Ahora vamos a intentar guardar esos datos de nuestra varible dentro de la tabla
users de la base de datos:

Llamamos al namespace \App\User y luego usamos la función create() que le vamos
a pasar como parametro nuestra variable $user creada en el paso anterior:

>>> \App\User::create($user);

=> App\User {#3940
     name: "Carlos Portrait",
     email: "cportrait@mail.com",
     updated_at: "2021-05-04 16:51:15",
     created_at: "2021-05-04 16:51:15",
     id: 1,
   }
>>>

ó directamente le pasamos los datos en la función

$user = User::create(['name'=>'José Prieto','email'=>'jprieto@mail.com','password'=>bcrypt('123456')]);

Con esto el dato quedó guardado en la tabla users de la base de datos.

Si queremos consultar el valor de una variable creada lo hacemos de la siguiente
manera:

>>> $user

Actualizar la contraseña de un usuario
======================================

$ php artisan tinker

> use App\Models\User;

> $user = User::find(13);

= App\Models\User {#6791
    id: 13,
    name: "José",
    email: "jose@mail.com",
    username: "jose",
    #password: "$2y$10$t3IphI6d/qeKJLBJD6Ua4OTa5JaCOS0O1GOO4ctfR6Zh6BYRvsSCa",
    created_at: "2023-02-15 14:59:10",
    updated_at: "2023-02-15 14:59:10",
    deleted_at: null,
  }

> $user->password = bcrypt('123456');
= "$2y$10$BeJc12CdbXOl2ofC7UY27eGVkRJgvofGUr87IbJPBYiuF2o0HFBEO"

> $user->save();
= true

ahora el usuario jose tiene la contraseña 123456.

Consultar todos los usuarios o todos los registros de cualquier tabla
=====================================================================

>>> $users = \App\User::all();

Le damos enter:

=> Illuminate\Database\Eloquent\Collection {#3875
     all: [
       App\User {#4084
         id: 1,
         name: "Carlos Portrait",
         email: "cportrait@mail.com",
         email_verified_at: null,
         type: "member",
         created_at: "2021-05-04 16:51:15",
         updated_at: "2021-05-04 16:51:15",
       },
     ],
   }
>>>

ó

>>> $categories = \App\Category::all();

Consultar un registro específico por su clave foránea o id
===========================================================

>>> $user = User::find(1);

Otro ejemplo:

>>> $article = App\Article::find(1);

Lanzar una excepción si una búsqueda no tiene resultado
=======================================================

A veces, es posible que desee lanzar una excepción si no se encuentra un modelo.
Para hacer esto, puede usar el método firstOrFail()

>>> $model = User::findOrFail(3);

Illuminate/Database/Eloquent/ModelNotFoundException with message 'No query results for model [App/User] 3'

Actualización un dato de un objeto guardado
===========================================

Para actualizar un modelo, puede recuperarlo, cambiar un atributo y usar el
método save:

>>> $user = User::find(1);

ó

$tag = App\Tag::find(1);

>>> $user->email = 'john@foo.com';

>>> $user->save();

Borrar un registro guardado
===========================

Se usa la función delete() sobre el resultado de la búsqueda:

>>> $user = User::find(1);

>>> $user->delete();

Crear una categoría con el ejemplo del blog
===========================================

Desde la consola de Tinker creamos una variable y le decimos que vamos a crear
un nuevo registro y en el modelo que le indiquemos:

>>> $category = new App\Category();

Ahora, una Categoría contiene un campo nombre, entonces vamos a crear una nueva
categoría "Noticias":

>>> $category->name='Noticias';

Resultado:

=> "Noticias"

Ahora guardamos la operación que estamos realizando con:

>>> $category->save();

Resultado:

=> true

Ahora vamos a consultar la lista de categorías guardadas a ver si se guardo
de verdad la categoría noticias:

>>> $categories = \App\Category::all();

=> Illuminate\Database\Eloquent\Collection {#3155
     all: [
       App\Category {#3162
         id: 1,
         name: "Noticias",
         created_at: "2021-05-05 16:08:02",
         updated_at: "2021-05-05 16:08:02",
       },
     ],
   }

Crear un artículo con el ejemplo del blog
=========================================

>>> $article = new App\Article();

>>> $article->title='Noticia de última hora';

>>> $article->content='Contenido de la noticia';

>>> $article->category_id=1;

>>> $article->user_id=1;

>>> $article->save();

Crear una etiqueta con el ejemplo del blog
==========================================

>>> $tag = new App\Tag();

>>> $tag->name='Sucesos';

>>> $tag->save();

>>> $tags = \App\Tag::all();

Consultar cada valor de un objeto guardado
==========================================

>>> $article = App\Article::find(1);

=> App\Article {#4098
     id: 1,
     title: "Noticia de última hora",
     content: "Contenido de la noticia",
     user_id: 1,
     category_id: 1,
     created_at: "2021-05-06 02:03:07",
     updated_at: "2021-05-06 02:03:07",
   }

>>> $article

=> App\Article {#4098
     id: 1,
     title: "Noticia de última hora",
     content: "Contenido de la noticia",
     user_id: 1,
     category_id: 1,
     created_at: "2021-05-06 02:03:07",
     updated_at: "2021-05-06 02:03:07",
   }

>>> $article->id

=> 1

>>> $article->title

=> "Noticia de última hora"

>>> $article->tags

=> Illuminate\Database\Eloquent\Collection {#3161
     all: [],
   }

Luego de consultar los tags si volvemos a ejecutar $article nos sale el arreglo
de los tags:

>>> $article

=> App\Article {#3160
     id: 1,
     title: "Noticia de última hora",
     content: "Contenido de la noticia",
     user_id: 1,
     category_id: 1,
     created_at: "2021-05-06 02:03:07",
     updated_at: "2021-05-06 02:03:07",
     tags: Illuminate\Database\Eloquent\Collection {#3161
       all: [],
     },
   }
>>>

Ejemplo de crear un objeto cuando la relación es muchos a muchos
================================================================

Para establecer una relación de muchos a muchos entre registros guardados se
usa la función attach().

En el siguiente ejemplo vamos a relacionar el tag con id=1 al artículo
consultado.

>>> $article->tags()->attach(1);

Se puede comprobar el registro guardado consultando la tabla article_tag.

=========================
Relaciones en los modelos
=========================

Por supuesto, las tablas de su base de datos probablemente estén relacionadas
entre sí. Por ejemplo, una publicación de blog puede tener muchos comentarios o
un pedido puede estar relacionado con el usuario que lo realizó. Eloquent
facilita la gestión y el trabajo con estas relaciones.

Laravel admite muchos tipos de relaciones:

1. Uno a Uno:
- Relación: HasOne
- Reverso: BelongsTo
- Ejemplo: Un usuario tiene un perfil.

2. Uno a Muchos:
- Relación: HasMany
- Reverso: BelongsTo
- Ejemplo: Un autor tiene muchos libros.

3. Muchos a Muchos:
- Relación: BelongsToMany
- Reverso: BelongsToMany
- Ejemplo: Un post tiene muchas etiquetas y una etiqueta puede estar asociada
con varios posts.

4. Polimórfica Uno a Uno o Uno a Muchos:
- Relación: MorphOne, MorphMany
- Reverso: MorphTo
- Ejemplo: Una imagen puede pertenecer a un usuario o un post.

5. Polimórfica Muchos a Muchos:
- Relación: MorphToMany
- Reverso: MorphToMany
- Ejemplo: Varios modelos, como videos y fotos, pueden estar etiquetados con
diferentes etiquetas.

Ejemplo de relación One To Many (Uno a muchos)
==============================================

Una categoría puede tener muchos artículos, entonces en el modelo Category.php
debemos crear una función pública que lleve por nombre el nombre de la tabla a
la cual se va a relacionar y en plural "articles".

En el return se usa la función hasMany y se le pasa la clase con la cuál se va a
establecer la relación App\Article.

public function articles()
{
    return $this->hasMany('App\Article');
}

Ejemplo plasmado en Category.php:

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Category extends Model
{
    protected $table = "categories";
    protected $fillable = ['name'];

    public function articles()
    {
        return $this->hasMany('App\Article');
    }
}

Con esto ya estaría plasmada la relación por parte de las Categorías, pero se
requiere también hacerlo del lado inverso, es decir ahora hay que editar el
modelo Article.php

Creamos una función pública con el nombre de tabla a la cual se va a relacionar
pero en singular "category()" ya que recordemos que un artículo solo va a
pertenecer a una sola categoría.

En el return se usa la función belongsTo y se le pasa la clase con la cuál se
va a establecer la relación App\Category.

Ejemplo en Article.php

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    protected $table = "articles";
    protected $fillable = ['title','content','user_id','category_id'];

    public function category()
    {
        return $this->belongsTo('App\Category');
    }
}

También en este ejemplo vamor a relacionar los usuarios con los artículos.

Un usuario puede escribir varios artículos, y un artículo solo puede estar
relacionado con un solo usuario, entonces vamos a editar User.php agregando una
función pública articles() en plural como ya hemos comentado

public function articles()
{
    return $this->hasMany('App\Article');
}

El ejemplo completo de User.php sería:

<?php

namespace App;

use Illuminate\Notifications\Notifiable;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Foundation\Auth\User as Authenticatable;

class User extends Authenticatable
{
    use Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'name', 'email', 'password',
    ];

    /**
     * The attributes that should be hidden for arrays.
     *
     * @var array
     */
    protected $hidden = [
        'password', 'remember_token',
    ];

    /**
     * The attributes that should be cast to native types.
     *
     * @var array
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
    ];

    public function articles()
    {
        return $this->hasMany('App\Article');
    }
}

Ahora hay que hacer la relación inversa, por lo que vamos a editar Article.php
y agregamos la función user():

public function user()
{
    return $this->belongsTo('App\User');
}

Ejemplo completo:

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    protected $table = "articles";
    protected $fillable = ['title','content','user_id','category_id'];

    public function category()
    {
        return $this->belongsTo('App\Category');
    }

    public function user()
    {
        return $this->belongsTo('App\User');
    }
}

Ahora, siguiendo con el ejemplo del blog, vamos a estableder una relación entre
las imágenes y los artículos, un artículo puede contener varias imágenes por lo
cual la relación es hasMany, entonces, vamos a Article.php y agregamos una
función publica images()

public function images()
{
    return $this->hasMany('App\Image');
}

Ejemplo completo en Article.php

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    protected $table = "articles";
    protected $fillable = ['title','content','user_id','category_id'];

    public function category()
    {
        return $this->belongsTo('App\Category');
    }

    public function user()
    {
        return $this->belongsTo('App\User');
    }

    public function images()
    {
        return $this->hasMany('App\Image');
    }
}

De igual forma hay que establecer la relación inversa en Image.php creando la
función pública article() en singular ya que las imágenes van relacionadas a un
solo artículo.

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Image extends Model
{
    protected $table = "images";
    protected $fillable = ['name','article_id'];

    public function article()
    {
        return $this->belongsTo('App\Article');
    }
}

Ejemplo de relación Many to Many o muchos a muchos
==================================================

Un artículo puede tener muchas etiquetas, por lo cuál la función que se crea se
referencia en plural, en Article.php.

y en el return se usaría la función belongsToMany()

public function tags()
{
    return $this->belongsToMany('App\Tag');
}

Ejemplo completo de Article.php:

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    protected $table = "articles";
    protected $fillable = ['title','content','user_id','category_id'];

    public function category()
    {
        return $this->belongsTo('App\Category');
    }

    public function user()
    {
        return $this->belongsTo('App\User');
    }

    public function images()
    {
        return $this->hasMany('App\Image');
    }

    public function tags()
    {
        return $this->belongsToMany('App\Tag');
    }
}

Ahora hay que declarar la relación en Tag.php, se declara la función pública
articles() en plural ya que una etiqueta puede ser usada en muchos artículos.

Ejemplo completo de Tag.php

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Tag extends Model
{
    protected $table = "tags";
    protected $fillable = ['name'];

    public function articles()
    {
        return $this->belongsToMany('App\Article');
    }
}

Ver las los datos relacionados de las tablas desde tinker
=========================================================

En este ejemplo, veremos los datos relacionados entre Artículos y Categorías.

>>> $article = App\Article::find(1);

=> App\Article {#3166
     id: 1,
     title: "Noticia de última hora",
     content: "Contenido de la noticia",
     user_id: 1,
     category_id: 1,
     created_at: "2021-05-06 03:25:24",
     updated_at: "2021-05-06 03:25:24",
   }

>>> $article->category

=> App\Category {#3150
     id: 1,
     name: "Noticias",
     created_at: "2021-05-06 03:24:51",
     updated_at: "2021-05-06 03:24:51",
   }

Para ver los datos como un arreglo:

>>> $article->category->toArray()
=> [
     "id" => 1,
     "name" => "Noticias",
     "created_at" => "2021-05-06 03:24:51",
     "updated_at" => "2021-05-06 03:24:51",
   ]
>>>

Ver los datos del artículo:

>>> $article

=> App\Article {#3166
     id: 1,
     title: "Noticia de última hora",
     content: "Contenido de la noticia",
     user_id: 1,
     category_id: 1,
     created_at: "2021-05-06 03:25:24",
     updated_at: "2021-05-06 03:25:24",
     category: App\Category {#3150
       id: 1,
       name: "Noticias",
       created_at: "2021-05-06 03:24:51",
       updated_at: "2021-05-06 03:24:51",
     },
   }
>>>

============================================
Service Providers o Proveedores de servicios
============================================

Los proveedores de servicios son el lugar central de todas las aplicaciones de
arranque de Laravel. Su propia aplicación, así como todos los servicios
centrales de Laravel, se arrancan a través de proveedores de servicios.

Pero, ¿qué queremos decir con "bootstrapped"?  En general, nos referimos al
registro de cosas, incluido el registro de enlaces de contenedores de servicios,
detectores de eventos, middleware e incluso rutas.  Los proveedores de servicios
son el lugar central para configurar su aplicación.

Si abre el archivo config/app.php incluido con Laravel, verá una matriz de
proveedores. Estas son todas las clases de proveedores de servicios que se
cargarán para su aplicación. De forma predeterminada, un conjunto de proveedores
de servicios centrales de Laravel se enumeran en esta matriz. Estos proveedores
arrancan los componentes centrales de Laravel, como el mailer, la cola, la caché
y otros.  Muchos de estos proveedores son proveedores "diferidos", lo que
significa que no se cargarán en cada solicitud, sino solo cuando los servicios
que brindan sean realmente necesarios.

Escribiendo un proveedor de servicio
====================================

Todos los proveedores de servicios amplían la clase
Illuminate\Support\ServiceProvider.  La mayoría de los proveedores de servicios
contienen un registro y un método de inicio.  Dentro del método de registro,
solo debe vincular cosas en el contenedor de servicios.  Nunca debe intentar
registrar ningún detector de eventos, rutas o cualquier otra función dentro del
método de registro.

Artisan CLI puede generar un nuevo proveedor a través del comando make:provider

$ php artisan make:provider RiakServiceProvider

======================================
Creando un crud con Laravel desde cero
======================================

1) Crear el proyecto:

$ composer create-project --prefer-dist laravel/laravel laravel-5-crud "5.8.*"

2) Crear la base de datos y configurarla en el .env

3) Crear una migración con la tabla a la que le aplicaremos el crud:

$ php artisan make:migration add_students_table --create=students

4) Editar la migración agregando los campos que llevará la tabla.

5) Ejecutar la migración de la base de datos.

$ php artisan migrate

Esto nos crea las tablas (students, students_id_seq) en la base de datos,
chequear si esto se realizo correctamente.

6) Crear un modelo, debe tener el mismo nombre que la migración pero en plural:

$ php artisan make:model Student

7) Editar el modelo creado agregando el nombre de la table en la base de datos
y los campos fillables.

8) Usar la consola de tinker para probar si se guardan registros correctamente
en la base de datos.

9) Crear un una ruta, un controlador y una vista para el CRUD.

$ php artisan make:controller Student

10) Probar una consulta básica a los datos de la base de datos desde un
controlador.

11) Crear la ruta Route::resource('students','StudentController');

12) Escribir las funciones index, create, store, show, edit, update, delete en
el controlador.

==================
Laravel Collective
==================

El paquete HTML de Laravel Collective viene con un generador de HTML y FORM que
le permite manejar formularios fáciles de administrar en sus archivos blade, así
como un intrincado modelo de enlace a sus formularios.

1) Instalación

$ composer require "laravelcollective/html":"^5.8.0"

2) Agregue su nuevo proveedor a la matriz de proveedores de config/app.php:

'providers' => [
  // ...
  Collective\Html\HtmlServiceProvider::class,
  // ...
],

Finalmente, agregue dos alias de clase a la matriz de alias de config/app.php:

'aliases' => [
  // ...
    'Form' => Collective\Html\FormFacade::class,
    'Html' => Collective\Html\HtmlFacade::class,
  // ...
],

3) Agregua un formulario en tu vista:

{{ Form::open(['url' => 'foo/bar']) }}
    //
{{ Form::close() }}

Campo select
============

echo Form::select('size', ['L' => 'Large', 'S' => 'Small']);

Generating A Drop-Down List With Selected Default

Campo select con valor default
==============================

echo Form::select('size', ['L' => 'Large', 'S' => 'Small'], 'S');

Diferencias en la sintaxis del paquete
======================================

{!!  !!} equivale a <?php ?> y este no se muestra en el HTML.

{{ }} equivale a <?php echo ""; ?> y este si se muestra en el HTML.

Ejemplos:

{!! Form::open() !!}
{!! Form::close() !!}

Nos renderiza en el código fuente html:

<form method="POST" action="http://127.0.0.1:8000/students/create" accept-charset="UTF-8"><input name="_token" type="hidden" value="xxxxxxxxxxxxxxx">
</form>

================================
Aceptar datos vacíos en un campo
================================

Se usa el método nullable() en las migraciones, tal que:

public function up()
{
    Schema::create('students', function (Blueprint $table) {
        $table->bigIncrements('id');
        $table->string('first_name', 60)->nullable();
        $table->string('last_name', 60)->nullable();
        $table->string('identification_number', 60)->nullable();
        $table->timestamps();
    });
}

Con eso ya deja guardar un campo vacío.

====================================================
Validacion de errores y capturar errores en la vista
====================================================

La directiva @error puede usarse para verificar rápidamente si existen mensajes
de error de validación para un atributo dado. Dentro de una directiva @error,
puede hacer eco de la variable $ message para mostrar el mensaje de error:

En el controlador validamos que los campos del formulario sean requeridos:

public function store(Request $request)
{
    $request->validate([
        'first_name' => 'required',
        'last_name' => 'required',
        'identification_number' => 'required',
    ]);

    $student = new Student($request->all());
    $student->save();
    return redirect()->route('students.index')->with('info','Student was created!');
}

En la vista capturamos y recorremos todos los erroes que se activen:

@if(count($errors))
  <ul>
    @foreach($errors->all() as $error)
      <li>{{ $error }}</li>
    @endforeach
  </ul>
@endif

ó

@if ($errors->any())
  <p>Por favor corrige los siguientes errores</p>
  <ul>
    @foreach ($errors->all() as $error)
      <li>{{ $error }}</li>
    @endforeach
  </ul>
@endif

Con el método any() preguntamos si hay algún error en la vista. A través del
método all() obtenemos todos los errores.

Si guardamos el formulario con los campos vacíos nos dirá:

The first name field is required.
The last name field is required.
The identification number field is required.

Si queremos capturar cada error individualmente sera con:

@error('first_name')
  {{ $message }}
@enderror

@error('last_name')
  {{ $message }}
@enderror

Otras validaciones
==================

Validar que el campo sea requerido y tenga como mínimo 3 caracteres:

'first_name' => 'required|min:3',

The first name must be at least 3 characters.

-----

Validar que un número o la edad sea mayor que 18 años.

$this->validate($request, [
    'age' => ['required','gt:18'],
],
[
    'age.required' => 'La edad es obligatoria',
    'age.gt' => 'La edad debe ser mayor de 18 años',
]);

-----

Nota cómo separamos cada regla de validación con una barra horizontal |.

Además si la regla requiere un argumento lo especificamos con :. Múltiples
argumentos se separan con ,. También podemos usar la sintaxis de arreglo:

$request->validate([
    'title' => ['required', 'min:3', 'unique:notes'],
]);

Incluso algunas reglas más complejas se pueden especificar a través de métodos o
una combinación de cadenas y métodos dentro de un arreglo:

use Illuminate\Validation\Rule;

$request->validate([
    'title' => ['required', 'max:200', Rule::unique('notes')],
]);

-----

Validar que el campo sea tipo email.

'email' => 'required|email|unique:clients',

The last name must be a valid email address.

-----

'email' => 'required|email|unique:clients',

Quiere decir que el email es requerido y sera único dentro de la tabla clients

-----

'register' => 'required_if:type,empresa'

En este caso el campo register solo es requerido cuando se haya seleccionado
‘empresa’ en el campo anterior dado que type es de tipo select, pero también
puede aplicar a un campo de texto:

'last_name' => 'required_if:first_name,pedro',

El campo de apellido es obligatorio cuando el nombre es pedro.

Mensajes personalizados para las validaciones
=============================================

Se agrega en un arreglo en la función validate, tal que:

,[
  'first_name.required' => 'El nombre es obligatorio',
  'last_name.required' => 'El apellido es obligatorio',
]);

Ejemplo:

public function store(Request $request)
{
    $request->validate([
        'first_name' => 'required',
        'last_name' => 'required',
        'identification_number' => 'required',
    ], [
        'first_name.required' => 'El nombre es obligatorio',
        'last_name.required' => 'El apellido es obligatorio',
    ]);

    $student = new Student($request->all());
    $student->save();
    return redirect()->route('students.index')->with('info','Student was created!');
}

Otro ejemplo:

$this->validate($request, [
      'active'      => 'boolean',
      'username'    => 'required|unique:users,username|alpha|max:25',
      'full_name'   => 'required',
      'email'       => 'required|email|max:255|unique:users',
      'password'    => 'required|confirmed|min:8|max:30',
      'permissions' => 'array|min:1',
      'roles'       => 'array|min:1',
      'country'     => 'required',
      'state'       => 'required',
      'city'        => 'required',
      'area_code'   => 'nullable|string'
], [
      'username.unique'    => 'El nombre de usuario ya esta registrado.',
      'username.max'       => 'El nombre de usuario no debe ser mayor a 25 caracteres.',
      'username.alpha'     => 'El nombre de usuario no debe contener caracteres especiales o espacios.',
      'full_name.required' => 'El nombre completo es obligatorio.',
      'email.email'        => 'El correo electrónico no es valido.',
      'country.required'   => 'El campo pais es obligatorio.',
      'state.required'     => 'El campo estado es obligatorio.',
      'city.required'      => 'El campo ciudad es obligatorio.',
      'permissions.min'    => 'El usuario debe tener almenos un permiso.',
      'roles.min'          => 'El usuario debe tener almenos un rol.',
]);

Otro ejemplo:

$this->validateRules = [
    'name'      => ['required', 'max:200'],
    'title'     => ['required', 'max:200'],
    'date'      => ['required', 'max:200', 'date', 'before_or_equal:'.date('d-m-Y')],
    'page'      => ['required', 'max:200', 'regex:/(^[0-9_-])/u'],
    'url'       => ['required', 'max:200','url'],
    'doi'       => ['nullable', 'max:200','url']
];

/** Define los mensajes de validación para las reglas del formulario */

$this->messages = [
    'name.required'   => 'El campo nombre del periódico es obligatorio.',
    'name.max'        => 'El campo nombre del periódico no debe ser mayor de 200 carácteres.',
    'title.required'  => 'El campo título es obligatorio.',
    'title.max'       => 'El campo título no debe ser mayor de 200 carácteres.',
    'date.required'   => 'El campo fecha de publicación es obligatorio.',
    'date.max'        => 'El campo fecha de publicación no debe ser mayor de 200 carácteres.',
    'page.required'   => 'El campo paginas es obligatorio.',
    'page.max'        => 'El campo paginas no debe ser mayor de 200 caracteres.',
    'page.regex'        => 'El formato del campo paginas es invalido, debe tener solo números y guiones. ',
    'url.required'    => 'El campo url es obligatorio.',
    'url.max'         => 'El campo url no debe ser mayor de 200 carácteres.',
    'url.url'         => 'El campo url es inválido. Ejemplo válido: http://www.nombreDeDominio.com o https://www.nombreDeDominio.com.',
    'doi.max'         => 'El campo doi no debe ser mayor de 200 carácteres.',
    'doi.url'         => 'El campo doi es inválido. Ejemplo válido: http://www.nombreDeDominio.com o https://www.nombreDeDominio.com.',
];

Más validaciones en la documentación oficial:

https://laravel.com/docs/8.x/validation#rule-max

====================
La función compact()
====================

La función compact se usa ampliamente en Laravel, no confunda esto con una
función de Laravel porque no lo es, esta es una función PHP. Entonces with() le
permite pasar variables a una vista y compact() crea una matriz a partir de
variables existentes que se le dan como argumentos de cadena.

Ejemplo:

$user = User::all();
return view('index', compact('user'));

================================================
Ejemplo de relación entre categorías y artículos
================================================

Una categoría puede tener varios artículos asociados, pero un artículo solo
puede estar asociado a una categoría, por lo tanto la relación

1) Generar una nueva migración y crear una tabla llamada categories:

$ php artisan make:migration add_categories_table --create=categories

2) Editar la migración y agregar los campos necesarios.

3) Generar una nueva migración y crear una tabla llamada articles:

$ php artisan make:migration add_articles_table --create=articles

4) Editar la migración y agregar los campos necesarios, incluyendo los campos
para las foreign keys.

5) Crear un modelo para las categorías:

$ php artisan make:model Category

6) Editar el modelo creado agregando los campos fillables y la función que
establece la relacion con los artículos.

7) Crear un modelo para los artículos:

$ php artisan make:model Article

8) Editar el modelo creado agregando los campos fillables inlcuyendo el campo
que relaciona el artículo con una categoría y la función que establece la
relacion con la categoría.

Para comprobar que las relaciones estén bien, se recomienda probar desde Tinker:

Crear categorías desde la consola de Tinker
===========================================

$category = new App\Category();

$category->name='Noticias';

$category->save();

$categories = \App\Category::all();

Crear artículos desde la consola de Tinker
==========================================

$article = new App\Article();

$article->title='Noticia de última hora';

$article->content='Contenido de la noticia';

$article->category_id=1;

$article->save();

$articles = \App\Article::all();

Ejemplo completo en:

-https://github.com/argenisosorio/laravel-5-crud/tree/relationships

=================
El método pluck()
=================

El método pluck recupera todos los valores de una clave determinada:

$collection = collect([
    ['product_id' => 'prod-100', 'name' => 'Desk'],
    ['product_id' => 'prod-200', 'name' => 'Chair'],
]);

$plucked = $collection->pluck('name');

$plucked->all();

// ['Desk', 'Chair']

====================================
Actualizar lista de paquetes de node
====================================

Este comando actualizará todos los paquetes listados a la última versión.

$ npm update


Si está utilizando Postgres, la palabra clave ILIKE se puede usar en lugar de
LIKE para que la coincidencia no distinga entre mayúsculas y minúsculas de
acuerdo con la configuración regional activa. Esto no está en el estándar SQL
pero es una extensión de PostgreSQL.

Ejemplo:

User::where('name, 'ILIKE', $search)->get();

========================================
Devolviendo un json desde un controlador
========================================

class ProjectController extends Controller
{
    /*
    |--------------------------------------------------------------------------
    | LIST
    |--------------------------------------------------------------------------
    */
    public function index()
    {
        $projects = Project::get();
        //return view('projects.index', compact('projects'));
        return response()->json(['projects'=>$projects], 200);
    }
}

Ejemplo de respuesta:

{"projects":[{"id":3,"name":"Project 1","introduction":"xxxxxxx","created_at":"2021-06-02T16:57:08.000000Z","updated_at":"2021-06-21T02:47:16.000000Z"},{"id":5,"name":"Project 2","introduction":"yyyyyyyyyyyyy","created_at":"2021-06-02T16:57:15.000000Z","updated_at":"2021-06-21T02:47:27.000000Z"},{"id":6,"name":"Project 3","introduction":"zzzzzzzzzzz","created_at":"2021-06-02T16:57:19.000000Z","updated_at":"2021-06-21T02:47:36.000000Z"}]}

==============================
Construyendo un comando propio
==============================

Los comandos personalizados se colocarán en el directorio app/Console/Commands

Para crear uno, cree una clase de comando con:

php artisan make:command Greetings --command=greetings

Esto creara el archivo Greetings.php en el directorio app/Console/Commands

El archivo genrado con el comando se puede llamar como nosotros deseemos y el
--comand= será para definir como usaremos nuestro comando en la consola.

El contenido por defecto del archivo será:

<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;

class Greetings extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'greetings';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Command description';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return int
     */
    public function handle()
    {
        return 0;
    }
}

La clase principal depende del nombre que hayamos usado en el comando de
generación del archivo, ya el resto es agregar las instrucciones que queremos
que se ejecuten cuando usemos nuestro comando.

Ejemplo, vamos a agregar un Hello world en la función handle:

<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;

class Greetings extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'greetings';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Command description';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return int
     */
    public function handle()
    {
        print("\n Hello world!!! \n\n");

        //return 0;
    }
}

Para usar el comando creado ejecutamos:

$ php artisan greetings

===============================
Iniciando un servidor WebSocket
===============================

En pocas palabras, una conexión WebSocket es una conexión persistente entre un
navegador y el servidor. Permite la comunicación bidireccional: el servidor
puede enviar mensajes al navegador y el navegador, el cliente, puede responder a
través de la misma conexión. Esto difiere del Ajax normal, que es solo una
comunicación unidireccional: solo el cliente puede preguntar cosas al servidor.

Una vez que haya configurado sus aplicaciones WebSocket y la configuración de
Pusher, puede iniciar el servidor Laravel WebSocket emitiendo el comando
artisan:

$ php artisan websockets:serve

Usando otro puerto:

$ php artisan websockets:serve --port=3030

=======================================
Redirigir a inicio desde un controlador
=======================================

return redirect()->to('/');

==================================
Enviar correos o emails en Laravel
==================================

Enviar emails desde un correo Gmail
===================================

Laravel está preconfigurado por defecto para poder conectarnos con cualquier
proveedor que use el protocolo SMTP (Protocolo para transferencia simple de
correo es un protocolo de red utilizado para el intercambio de mensajes de
correo electrónico entre computadoras u otros dispositivos.) como Gmail por
ejemplo.

Además también está preparado para comunicarse con otros proveedores que no usan
ese protocolo sino APIS como: Mailgun, Postmark, Amazon SES y sendmail. Aunque
Laravel permite conectarse con cualquier proveedor de servicio de correo, claro
está, haciendo las respectivas configuraciones adicionales.

Probando envio de correo con cuenta Gmail
=========================================

1) Configurar la cuenta de Gmail para que permite el acceso a aplicaciones poco
seguras desde https://myaccount.google.com/lesssecureapps

Info más extensa sobre el tema desde:
https://programacionymas.com/blog/como-enviar-mails-correos-desde-laravel
incluyendo la verificación ded 2 pasos.

2) Cuando ya está configurada la cuenta de correo solo tienes que decirle a
Laravel qué datos usar para enviar mails a través de esta cuenta Gmail.

En la carpeta config existe un archivo mail.php. Aquí se encuentran todas las
variables asociadas al envío de mails.

Dentro de este archivo de configuración, encontramos:

'driver' => env('MAIL_DRIVER', 'smtp'),

Esta línea le dice a Laravel que el driver que debes usar se encuentra definido
dentro del archivo .env bajo el nombre MAIL_DRIVER. Pero, si no lo encuentras,
usa smtp por defecto.

De la misma forma podemos leer las siguientes líneas:

'host' => env('MAIL_HOST', 'smtp.mailgun.org'),
'port' => env('MAIL_PORT', 587),
'encryption' => env('MAIL_ENCRYPTION', 'tls'),
'username' => env('MAIL_USERNAME'),
'password' => env('MAIL_PASSWORD'),
'timeout' => null,
'auth_mode' => null,

De esto último:

-host y port se asocian con el servidor SMTP.

-from determina a nombre de quién se envía el correo.

-username y password son las credenciales de la cuenta Gmail.

Por lo tanto, estos datos los vamos a poner dentro de nuestro archivo .env.

Además también debemos configurar las varibles MAIL_FROM_ADDRESS y
MAIL_FROM_NAME, ambas en el archivo .env, estas variables describen el email del
remitente y el nombre

¿Por qué en el archivo .env y no directamente en mail.php?

Nos conviene definir estos valores en .env porque así podemos tener
configuraciones distintas: por ejemplo, usar nuestro correo corporativo de Gmail
en producción, pero usar el log de forma local para hacer pruebas.

Además, las credenciales siempre deben definirse en el archivo .env, ya que este
archivo no forma parte del código fuente (al usar GIT este archivo es ignorado,
por lo que cada persona que tenga acceso al código, podrá usar la configuración
que más le convenga).

Ya para finalizar tenemos estos datos en nuestro .env:

MAIL_DRIVER=smtp
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USERNAME=micorreo@gmail.com
MAIL_PASSWORD=miclave
MAIL_ENCRYPTION=tls
MAIL_FROM_ADDRESS=micorreo@gmail.com
MAIL_FROM_NAME="nombre_del_remitente"

Estos, permitirán a nuestra app Laravel enviar mails a través del correo Gmail.

Por defecto tenemos en MAIL_HOST configurado el valor smtp.mailtrap.io, lo que
hace referencia a Mailtrap, que es un servidor SMTP falso para que su equipo de
desarrollo pueda probar, ver y compartir correos electrónicos enviados desde los
entornos de preproducción y probar con datos reales sin el riesgo de enviar spam
a clientes reales. Lo que ofrece este servicio es poder interceptar los correos
que se envíen desde la aplicación para poder ver como se ven si le llegaran a
los clientes de la aplicación, básicamente es para evitar el espam cuando se
prueba en un entorno de producción.

Envío de mails
==============

1) Al crear aplicaciones de Laravel, cada tipo de correo electrónico enviado por
su aplicación se representa como una clase "mailable". Estas clases se almacenan
en el directorio app/Mail. No se preocupe si no ve este directorio en su
aplicación, ya que se generará cuando cree su primera clase mailable usando
el comando:

$ php artisan make:mail Prueba

Esto nos creara el archivo Prueba.php en la ruta app/Mail/

y su contenido por defecto es:

-----

<?php

namespace App\Mail;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Mail\Mailable;
use Illuminate\Queue\SerializesModels;

class Prueba extends Mailable
{
    use Queueable, SerializesModels;

    /**
     * Create a new message instance.
     *
     * @return void
     */
    public function __construct()
    {
        //
    }

    /**
     * Build the message.
     *
     * @return $this
     */
    public function build()
    {
        return $this->view('view.name');
    }
}

-----

Ahora vamos a editar el archivo agregando la variable $subject dentro de la
clase Padre, al igual que vamos a editar la vista en la cual vamos a tener el
el contenido de nuestro correo, emails.index tal que:

-----

<?php

namespace App\Mail;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Mail\Mailable;
use Illuminate\Queue\SerializesModels;

class Prueba extends Mailable
{
    use Queueable, SerializesModels;

    public $subject = "Este es un mensaje";

    /**
     * Create a new message instance.
     *
     * @return void
     */
    public function __construct()
    {
        //
    }

    /**
     * Build the message.
     *
     * @return $this
     */
    public function build()
    {
        return $this->view('emails.index');
    }
}

-----

emails.index no exite por lo cual vamos a la carpeta views y crearmos la carpeta
emails, luegro dentro de email creamos una vista con nombre index.blade.php cuyo
contenido puede ser:

-----

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Prueba Email</title>
  </head>
  <body>
    <h1>Título del correo</h1>
    <p>Éste es el contenido del correo</p>
  </body>
</html>

-----

Ahora debemos ir al achivo de rutas y crearemos una nueva, tal que:

Route::get('sendmail', function () {
    $correo = new Prueba;
    Mail::to('email-de-quien-recibida-el-mensaje@gmail.com')->send($correo);

    return "Mensaje enviado";
});

Como vemos, debemos configurar el correo de quien recibirá el mensaje, además
debemos usar algunas clases en la parte superior, tal que:

use App\Mail\Prueba;
use Illuminate\Support\Facades\Mail;

Donde prueba fue el Maillable que creamos con el comando.

Además agregamos un return "Mensaje enviado"; para saber que se envió el correo
correctamente

Nuestro archivo de rutas quedaría así:

-----

<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\ProjectController;
use App\Mail\Prueba;
use Illuminate\Support\Facades\Mail;


Route::get('/', function () {
    return view('welcome');
});

Route::get('sendmail', function () {
    $correo = new Prueba;
    Mail::to('argenisosorio10@gmail.com')->send($correo);
    return "Mensaje enviado";
});

-----

Ya solo queda navegar hasta /sendmail y probar que se envió el correo
correctamente

Otra forma
==========

Esta vez, solo vamos a poner el contenido del ejemplo anterior de la ruta, pero
en el controlador. Igual hay que crear el mailable con el comando, editar el
archivo creado con el comando, crear la vista que será el contenido del correo y
lo demás de los pasos anteriores, lo que varia es lo siguiente:

1) Crear una ruta:

Route::get('/sendmail',[MyController::class, 'sendmail']);

2) Crear un controlador:

-----

<?php

namespace App\Http\Controllers;

use App\Models\Project;
use Illuminate\Http\Request;
use App\Mail\Prueba;
use Illuminate\Support\Facades\Mail;

class ProjectController extends Controller
{
    public function sendmail(Request $request){
        $correo = new Prueba;
        Mail::to('argenisosorio10@gmail.com')->send($correo);
        return "Mensaje enviado";
    }
}

-----

Si navegamos a /sendmail debería envíar el correo.

=================================
Envío de correo mediante notify()
=================================

notify() siempre va enviar un correo por defecto a un objeto email del cual
reciba datos, por ejemplo:

$user->notify(new UserRegistered());

Donde $user es el usuario de Laravel el cual tiene un campo email.

Pero si se quiere enviar un correo a otro correo que no sea el de usuario,
se puede construir un arreglo temporal pasa que notify() encuentre el valor
email que le indiquemos, ejemplo:

// Enviar correo electrónico a la dirección que viene de $request->another_email
(new User)->forceFill(['email' => $request->another_email])
->notify(new UserRegistered());

=========================
Campo select en una vista
=========================

En el controlador:

use App\Models\User;

/*
|--------------------------------------------------------------------------
| CREATE
|--------------------------------------------------------------------------
*/
public function create()
{
    //$users = User::orderBy('name', 'ASC')->pluck('name', 'id');
    $users = User::all();
    return view('dashboards.create')->with('users', $users);
}

En la vista:

<select name="user_id">
  @foreach ($users as $user)
    <option value="{{ $user->id }}">{{ $user->name }}</option>
  @endforeach
</select>

=================================================
Artisan Error: Failed to listen on localhost:8000
=================================================

$ ps -ef | grep php

Then kill the process

$ kill -9 xxxxxxxx

===================
Instalar Laravel/ui
===================

Actualizar la versión de Laravel en el proyecto con:

$ composer upodate

Instale el paquete laravel/ui

$ composer require laravel/ui

Para chequear que esté correctamente instalado debemos chequear el archivo
composer.json

=====================================================
Cómo configurar y usar Vue en su aplicación Laravel 8
=====================================================

En versiones anteriores de Laravel, Vue se configuraba automáticamente con cada
nueva instalación. Sin embargo, en las versiones más recientes, debe
configurarlo usted mismo.

Afortunadamente, el paquete laravel/ui proporciona una manera fácil de
configurar Vue en su aplicación Laravel.

Siga los siguientes pasos para configurar Vue en su aplicación Laravel.

1) Crear una nueva aplicación Laravel

2) Instale el paquete laravel/ui con:

$ composer require laravel/ui

3) Instale el andamio Vue:

El paquete laravel/ui tiene algunos comandos Artisan útiles que automáticamente
distribuirán todo lo que necesita para comenzar.

$ php artisan ui vue

Notará que realiza algunos cambios en tu aplicación ya que se modificaron
algunos archivos y se agregaron algunos directorios y archivos.

4) Compile los archivos

Finalmente, deberá instalar las dependencias recién agregadas y compilarlas.

$ npm install && npm run dev

$ npm install laravel-mix@latest

$ npm install vue-loader --save-dev --legacy-peer-deps

Nota: si está ejecutando esto por primera vez, es posible que Mix necesite
instalar dependencias adicionales que se incorporarán automáticamente. Si ve un
mensaje de error, simplemente ejecute npm run dev nuevamente.

5) Incluya /js/app.js en su vista

Su archivo app.js se compilará y guardará en public/js/app.js.  Como estamos
usando Laravel Mix para compilarlo, podemos usar el método auxiliar mix() para
generar la ruta correcta para nosotros. Se recomienda usar el ayudante mix()
para que se use el nombre de archivo adecuado si está usando el control de
versiones.

<script src="{{ mix('/js/app.js') }}"></script>

6) Agregue el elemento raíz Vue a su HTML

Asegúrese de tener también un elemento raíz con una identificación de aplicación
para su andamio HTML. De lo contrario, Vue no sabrá dónde montar los
componentes.

<div id="app">
<example-component></example-component>
</div>

Registro de componentes de Vue de un solo archivo

El paquete laravel/ui creará un nuevo directorio en resources/js/components.
Aquí es donde puede agregar nuevos componentes de Vue. Notarás que el paquete
laravel/ui agregó un archivo ExampleComponent.vue allí.

Una vez que cree su archivo de componente, deberá registrarlo con Vue. En
Laravel, puedes hacerlo en tu archivo app.js principal (resources/js/app.js).

Notará que ExampleComponent ya está registrado.

Vue.component('example-component', require('./components/ExampleComponent.vue').default);

Otra forma de llamar el componente:

Vue.component('example-component', () => import('./components/ExampleComponent.vue'));

Siéntase libre de crear subdirectorios en su directorio resources/js/components/
para organizar sus archivos. Solo asegúrese de que la ruta en su método
require() coincida con la estructura de su directorio.

Vue.component('admin-login-component', require('./components/Admin/AdminLoginComponent.vue').default);\

Listo, su vista debería quedar tal que así:

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <div id="app">
      <example-component></example-component>
    </div>
    <script src="{{ mix('/js/app.js') }}"></script>
  </body>
</html>

Con esto debería poder ver su componente desde el navegador.

Fuente
======

https://diegooo.com/vue-como-configurar-y-usar-en-laravel-8/

==========================================================
El error Laravel Mix unknown option '--hide-modules' error
==========================================================

Update Laravel Mix

$ npm install laravel-mix@latest

Update Your NPM Scripts in package.json

Before

"scripts": {
    "dev": "npm run development",
    "development": "cross-env NODE_ENV=development node_modules/webpack/bin/webpack.js --progress --hide-modules --config=node_modules/laravel-mix/setup/webpack.config.js",
    "watch": "npm run development -- --watch",
    "watch-poll": "npm run watch -- --watch-poll",
    "hot": "cross-env NODE_ENV=development node_modules/webpack-dev-server/bin/webpack-dev-server.js --inline --hot --disable-host-check --config=node_modules/laravel-mix/setup/webpack.config.js",
    "prod": "npm run production",
    "production": "cross-env NODE_ENV=production node_modules/webpack/bin/webpack.js --no-progress --hide-modules --config=node_modules/laravel-mix/setup/webpack.config.js"
},

After

"scripts": {
    "dev": "npm run development",
    "development": "mix",
    "watch": "mix watch",
    "watch-poll": "mix watch -- --watch-options-poll=1000",
    "hot": "mix watch --hot",
    "prod": "npm run production",
    "production": "mix --production"
},

laravel-mix
===========

Laravel Mix proporciona una API limpia y fluida para definir básicos de paquetes
web pasos compilación de para sus aplicaciones. Mix admite varios
preprocesadores comunes de CSS y JavaScript.

Mix trabaja con Webpack por debajo, solo que permite olvidarse de todas sus
complejidades de configuración y uso. Con un código muy sencillo Mix permite
realizar las operaciones que se suelen hacer con Webpack en la mayoría de las
aplicaciones.

Laravel Mix apareció a partir de Laravel 5.4, para sustituir a Laravel Elixir.
Además, dada la filosofía de Laravel, de ofrecer todo un stack desacoplado de
utilidades, esta herramienta se puede usar independientemente del framework. Es
decir, está completamente integrada con Laravel, pero también la podríamos usar
en cualquier otro proyecto que requiera el trabajo con Javascript y CSS.

=============================================================
Modificar tablas ya existentes con las migraciones de Laravel
=============================================================

Modificar una tabla
===================

Para agregar una columna a una tabla, modificamos la migración ya existente. En
nuestro caso añadimos un campo profession con un limite de 100 caracteres a la
tabla users:

<?php
//...
Schema::create('users', function (Blueprint $table) {
    $table->increments('id');
    $table->string('name');
    $table->string('email')->unique();
    $table->string('profession', 100)->nullable(); // Agregamos una nueva columna
    $table->string('password');
    $table->rememberToken();
    $table->timestamps();
});

Modificar un campo ya existente
===============================

Para modificar un campo ya existente, por ejemplo el limite de caracteres del
campo profession, agregamos el nuevo valor en la migración:

<?php
//...
Schema::create('users', function (Blueprint $table) {
    // ...
    $table->string('profession', 50)->nullable(); // Cambiamos el límite de 100 a 50
    // ...
});

Modificar migraciones
=====================

Al realizar una modificación en la migración original tenemos el problema de que
los comandos reset y refresh eliminaran el contenido de las tablas en la base de
datos. Para evitar esto podemos (utilizando el comando make:migration) crear una
nueva migración y agregar desde ahí las modificaciones que necesitamos:

$ php artisan make:migration add_profession_to_users

Es una buena practica que el nombre de la migración sea descriptivo y haga
referencia a lo que vamos a hacer. En este caso add_profession_to_users indica
que queremos agregar el campo profession a la tabla users.

Dentro del método up() de la migración en lugar de usar el método create del
facade Schema utilizaremos table y pasaremos como primer argumento el nombre de
la tabla que queremos modificar:

<?php
//...
Schema::table('users', (Blueprint $table)) {
    $table->string('profession', 50)->nullable();
});

Dentro de la función indicamos el campo que queremos agregar.

En el método down() especificamos la acción inversa, en este caso eliminar la
columna que agregamos en el método up():

<?php
//...
Schema::table('users', function (Blueprint $table) {
    $table->dropColumn('profession');
});

Con el método dropColumn eliminamos de la tabla la columna especificada como
argumento.

Luego:

$ php artisan migrate

Modificar el nombre de una columna existente
============================================

Creamos una migración que indique que vamos a modificar un campo de la tabla
users por ejemplo.

$ php artisan make:migration update_field_to_users_table

Para cambiar el nombre de una columna, puede utilizar el método renameColumn
proporcionado por el modelo del generador de esquemas. Antes de cambiar el
nombre de una columna, asegúrese de haber instalado la biblioteca doctrine/dbal
a través del administrador de paquetes Composer:

$ composer require doctrine/dbal

Para que funcione con SQLITE se debe instalar una versión específica:

$ composer require doctrine/dbal:2.13

Luego agregamos lo siguiente en el método up() de la migración creada:

Schema::table('users', function (Blueprint $table) {
    $table->renameColumn('from', 'to');
});

El ejemplo real sería:

Schema::table('users', function (Blueprint $table) {
    $table->renameColumn('name', 'complete_name');
});

y en el método down() sería:

Schema::table('users', function (Blueprint $table) {
    $table->renameColumn('complete_name', 'name');
});

Luego:

$ php artisan migrate

¡Entonces wollah! acaba de cambiar el nombre de name a complete_name.

Actualizar atributos de columna en una nueva migración
======================================================

1) Creamos una migración que indique que vamos a modificar un campo de la tabla
users por ejemplo.

$ php artisan make:migration update_field_to_users_table

2) Modificamos la migración.

El método change() le permite modificar el tipo y los atributos de las columnas
existentes. Por ejemplo, es posible que desee aumentar el tamaño de una columna.
Para ver el método change() en acción, aumentemos el tamaño de la columna nombre
de 25 a 50. Para lograr esto, simplemente definimos el nuevo estado de la
columna y luego llamamos al método change():

Schema::table('users', function (Blueprint $table) {
    $table->string('name', 50)->change();
});

También podríamos modificar una columna para que sea anulable:

Schema::table('users', function (Blueprint $table) {
    $table->string('name', 50)->nullable()->change();
});

====================================
Modificar una migración directamente
====================================

Si realizamos una modificación directamente en una migración, y ejecutamos
php artisan migrate, debería detectar el cambio, pero a veces no lo toma, para
resolver esto debemos borrar un registro de la tabla migrations, el registro
tendra como texto el nombre de la migración creada, por lo cual, un ejemplo
sería:

my_db=# DELETE FROM migrations WHERE migration='2022_02_07_153244_add_new_fields_to_articles';

Luego de esto ejecutamos:

$ php artisan migrate

Y se debería ejecutar de nuevo eso migración y ahí si aplicar los cambios.

Fuente
======

https://styde.net/modificar-tablas-ya-existentes-con-las-migraciones-de-laravel/

===============================================
Definir y usar el tipo de dato JSON en Eloquent
===============================================

En el archivo de migraciones se agrega un campo como el siguiente:

$table->json('field_name');

Y en su modelo, agrega el campo a la propiedad $casts para indicarle a Eloquent
que lo deserialice de JSON en una matriz PHP:

class SomeModel extends Model
{
  protected $casts = [
    'field_name' => 'array'
  ];
}

Ejemplo:

class GlobalData extends Model
{
    use HasFactory;

    protected $table = 'global_data';
    public $timestamps = true;

    protected $fillable = [
        'prefix',
        'name',
        'description',
        'document_types',
    ];

    protected $casts = [
        'document_types' => 'array',
    ];
}

===============================================================
El error These credentials do not match our records en el login
===============================================================

Cuando se hace el nuevo registro, se debe encriptar la contraseña con el helper
bcrypt o Hask, recuerdemos que el Auth de laravel para Autenticar usa Hash, y el
requisito es que la contraseña este encriptada.

Ejemplo:

use Illuminate\Support\Facades\Hash;

Hash::make($password)

==============
updateOrCreate
==============

El método updateOrCreate intenta encontrar un modelo que coincida con las
restricciones pasadas como primer parámetro. Si se encuentra un modelo
coincidente, actualizará la coincidencia con los atributos pasados como segundo
parámetro. Si no se encuentra ningún modelo coincidente, se creará un nuevo
modelo con las restricciones pasadas como primer parámetro y los atributos
pasados como segundo parámetro.

Puede refactorizar este fragmento de código:

$user = User::where('email', request('email'))->first();
if ($user !== null) {
    $user->update(['name' => request('name')]);
} else {
    $user = User::create([
      'email' => request('email'),
      'name' => request('name'),
    ]);
}

Para esto usamos el método updateOrCreate:

$user = User::updateOrCreate(
    ['email' =>  request('email')],
    ['name' => request('name')]
);

Otro ejemplo:

Se usa el mismo formulario de store para guardar un nuevo registro o actualizar
uno guardado.

/*
|--------------------------------------------------------------------------
| STORE
|--------------------------------------------------------------------------
*/
public function store(Request $request)
{
    $request->validate([
        'name' => 'required',
        'introduction' => 'required',
    ]);

    $project = Project::updateOrCreate(
    [
        'name' =>  request('name')
    ],
    [
        'introduction' => request('introduction')
    ]
    );
    return redirect()->route('projects.index')->with('success', 'Project created successfully.');
}

========================================
Guardar y actualizar campos de tipo json
========================================

Models
======

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Project extends Model
{
    use HasFactory;

    protected $table = 'projects';
    public $timestamps = true;

    protected $fillable = [
        'name',
        'introduction',
        'meta'
    ];

    protected $casts = [
        'meta' => 'array'
    ];
}

Controller
==========

<?php

namespace App\Http\Controllers;

use App\Models\Project;
use Illuminate\Http\Request;

class ProjectController extends Controller
{
    /*
    |--------------------------------------------------------------------------
    | LIST
    |--------------------------------------------------------------------------
    */
    public function index()
    {
        $projects = Project::get();
        return view('projects.index', compact('projects'));
    }

    /*
    |--------------------------------------------------------------------------
    | CREATE
    |--------------------------------------------------------------------------
    */
    public function create()
    {
        return view('projects.create');
    }

    /*
    |--------------------------------------------------------------------------
    | STORE
    |--------------------------------------------------------------------------
    */
    public function store(Request $request)
    {
        $data_meta = $request->only('member_name','member_dni');
        $meta = json_encode($data_meta);
        Project::create(
            [
                'name' => $request->name,
                'introduction' => $request->introduction,
                'meta' => $meta,
            ]
        );
        return redirect()->route('projects.index')->with('success', 'Project created successfully.');
    }

    /*
    |--------------------------------------------------------------------------
    | EDIT
    |--------------------------------------------------------------------------
    */
    public function edit(Project $project)
    {
        $meta = json_decode($project->meta);
        return view('projects.edit', compact('project', 'meta'));
    }

    /*
    |--------------------------------------------------------------------------
    | UPDATE
    |--------------------------------------------------------------------------
    */
    public function update(Request $request, Project $project)
    {
        $request->validate([
            'name' => 'required',
            'introduction' => 'required',
            'member_name' => 'required',
            'member_dni' => 'required',
        ]);
        $data_meta = $request->only('member_name','member_dni');
        $meta = json_encode($data_meta);
        $data = Project::find($project);
        foreach ($data as $data_request) {
            $data_request->name = $request->name;
            $data_request->introduction = $request->introduction;
            $data_request->meta = $meta;
            $data_request->save();
        }
        return redirect()->route('projects.index')->with('success', 'Project updated successfully');
    }

    /*
    |--------------------------------------------------------------------------
    | SHOW
    |--------------------------------------------------------------------------
    */
    public function show(Project $project)
    {
        return view('projects.show', compact('project'));
    }

    /*
    |--------------------------------------------------------------------------
    | DELETE
    |--------------------------------------------------------------------------
    */
    public function destroy(Project $project)
    {
        $project->delete();
        return redirect()->route('projects.index')->with('success', 'Project deleted successfully');
    }
}

Create
======

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Create project</title>
  </head>
  <body>
    <h1>Create project</h1>
    @if(count($errors))
      <ul>
        @foreach($errors->all() as $error)
          <li>{{ $error }}</li>
        @endforeach
      </ul>
    @endif
    <form action="{{ route('projects.store') }}" method="POST">@csrf
      <div>
        <label>Name:</label>
        <input type="text" name="name">
      </div>
      <br>
      <div>
        <label>Introduction:</label>
        <input type="text" name="introduction">
      </div>
      <br>
      <div>
        <label>Members:</label>
        <br>
        Name
        <input type="text" name="member_name">
        <br>
        DNI
        <input type="text" name="member_dni">
      </div>
      <br>
      <button type="submit" >SAVE</button>
    </form>
  </body>
</html>

edit
====

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Update project</title>
  </head>
  <body>
    <h1>Update project</h1>
    @if(count($errors))
      <ul>
        @foreach($errors->all() as $error)
          <li>{{ $error }}</li>
        @endforeach
      </ul>
    @endif
    <form action="{{ route('projects.update', $project->id) }}" method="POST"> @csrf @method('PUT')
      <div>
        <label>Name:</label>
        <input type="text" name="name" value="{{ $project->name }}">
      </div>
      <br>
      <div>
        <label>Introduction:</label>
        <input type="text" name="introduction" value="{{ $project->introduction }}">
      </div>
      <br>
      <div>
        <label>Members:</label>
        <br>
        Name
        <input type="text" name="member_name" value="{{ $meta->member_name }}">
        <br>
        DNI
        <input type="text" name="member_dni" value="{{ $meta->member_dni }}">
      </div>
      <br>
      <button type="submit" >SAVE</button>
      <br>
    </form>
  </body>
</html>

index
=====

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>List of projects</title>
  </head>
  <body>
    @if(Session::has('success'))
      Message: {{ Session::get('success') }}
    @endif
    <h1>List of projects</h1>
    <a href="{{ route('projects.create') }}">
      <button>NEW</button>
    </a>
    <br />
    <br />
    <table border="1px" cellspacing="0px" style="width:100%;">
      <thead>
        <tr>
          <th class="text-center">ID</th>
          <th class="text-center">Name</th>
          <th class="text-center">Introduction</th>
          <th class="text-center">Members</th>
          <th class="text-center">Actions</th>
        </tr>
      </thead>
      <tbody>
      @foreach ($projects as $project)
      <tr>
        <td class="text-center">{{ $project->id }}</td>
        <td class="text-center">{{ $project->name }}</td>
        <td class="text-center">{{ $project->introduction }}</td>
        <td class="text-center">{{ $project->meta }}</td>
        <td>
          <a href="{{ route('projects.edit', $project->id) }}">
            <button>UPDATE</button>
          </a>
          <a href="{{ route('projects.show', $project->id) }}">
            <button>SHOW</button>
          </a>
          <form action="{{ route('projects.destroy', $project->id) }}" method="POST">
            @csrf
            @method('DELETE')
            <button type="submit" onclick="return confirm('Are you sure you want to delete the record? ');">DELETE</button>
          </form>
        </td>
      </tr>
      @endforeach
      </tbody>
    </table>
  </body>
</html>

=====================================
Guardar la fecha actual como datetime
=====================================

Use Carbon\Carbon;

$student = Student::create([
    'registered_at' => Carbon::now(),
]);

Esto guarda este formato:

2021-12-24

==================================================================
Editar la plantilla que contiene el texto del email password reset
==================================================================

$ php artisan vendor:publish --tag=laravel-notifications

Ese comando genero esto:

Copied Directory
[/vendor/laravel/framework/src/Illuminate/Notifications/resources/views] To
[/resources/views/vendor/notifications]

Publishing complete.

Dentro está email.blade.php que es donde está el texto.

Luego:

$ php artisan vendor:publish --tag=laravel-mail

Ese comando genero esto:

Copied Directory [/vendor/laravel/framework/src/Illuminate/Mail/resources/views] To [/resources/views/vendor/mail]
Publishing complete.

Publishing complete.

En los directorios generados están los templates que se deben modificar.

Recomendación
=============

Lo mejor es crear un archivo es.json en el directorio /resources/lang/es.json

{
    "Reset Password Notification": "Notificación de restablecimiento de contraseña",
    "You are receiving this email because we received a password reset request for your account.": "Ha recibido este mensaje porque se solicitó un restablecimiento de contraseña para su cuenta.",
    "Reset Password": "Restablecer contraseña",
    "This password reset link will expire in :count minutes.": "Este enlace de restablecimiento de contraseña expirará en :count minutos.",
    "If you did not request a password reset, no further action is required.": "Si no ha solicitado el restablecimiento de contraseña, omita este mensaje de correo electrónico.",
    "Regards": "Saludos",
    "If you're having trouble clicking the \":actionText\" button, copy and paste the URL below\ninto your web browser:": "Si tiene problemas para hacer clic en el botón \":actionText\", copie y pegue la siguiente URL \nen su navegador web:",
    "If you’re having trouble clicking the \":actionText\" button, copy and paste the URL below\ninto your web browser:": "Si tiene problemas para hacer clic en el botón \":actionText\", copie y pegue la siguiente URL \nen su navegador web:",
    "All rights reserved.": ""
}

Esto traducirá todo lo necesario para es siempre y cuando esto esté configuraco
en config/app.php 'locale' => 'es',

Ejemplo de un es.json muy completo:

https://github.com/Laravel-Lang/lang/blob/master/locales/es/es.json

=================================
Ejecutar una migración específica
=================================

$ php artisan migrate --path=/database/migrations/full_migration_file_name_migration.php

=================================================================
ERROR in ./node_modules/bootstrap/dist/js/bootstrap.esm.js 6:0-41
=================================================================

Este error da al ejecutar npm run dev, se soluciona ejecutando lo siguiente:

$ npm i @popperjs/core

=========================
El error de popperjs/core
=========================

Module not found: Error: Can't resolve '@popperjs/core'

Este error da al ejecutar npm run dev, se soluciona ejecutando lo siguiente:

$ npm i @popperjs/core

$ npm run dev

===============
Laravel Sanctum
===============

Laravel Sanctum proporciona un sistema de autenticación liviano para SPA
(aplicaciones de una sola página), aplicaciones móviles y API simples basadas en
token. Sanctum permite que cada usuario de su aplicación genere múltiples tokens
de API para su cuenta. A estos tokens se les pueden otorgar habilidades/ámbitos
que especifican qué acciones pueden realizar los tokens.

Cómo funciona
=============

Laravel Sanctum existe para resolver dos problemas separados. Discutamos cada
uno antes de profundizar en la biblioteca.

API tokens
==========

Primero, Sanctum es un paquete simple que puede usar para emitir tokens API a
sus usuarios sin la complicación de OAuth. Esta función está inspirada en GitHub
y otras aplicaciones que emiten "tokens de acceso personal". Por ejemplo,
imagine que la "configuración de la cuenta" de su aplicación tiene una pantalla
en la que un usuario puede generar un token API para su cuenta. Puede usar
Sanctum para generar y administrar esos tokens. Estos tokens suelen tener un
tiempo de caducidad muy largo (años), pero el usuario puede revocarlos
manualmente en cualquier momento.

Laravel Sanctum ofrece esta función almacenando tokens de API de usuario en una
sola tabla de base de datos y autenticando las solicitudes HTTP entrantes a
través del encabezado de Autorización que debe contener un token de API válido.

Autenticación SPA
=================

En segundo lugar, Sanctum existe para ofrecer una forma sencilla de autenticar
aplicaciones de una sola página (SPA) que necesitan comunicarse con una API
potenciada por Laravel. Estos SPA pueden existir en el mismo repositorio que su
aplicación Laravel o pueden ser un repositorio completamente separado, como un
SPA creado con Vue CLI o una aplicación Next.js.

Para esta función, Sanctum no utiliza tokens de ningún tipo. En su lugar,
Sanctum utiliza los servicios de autenticación de sesión basados en cookies
integrados de Laravel. Por lo general, Sanctum utiliza la protección de
autenticación web de Laravel para lograr esto. Esto proporciona los beneficios
de la protección CSRF, la autenticación de sesión y protege contra la fuga de
las credenciales de autenticación a través de XSS.

Sanctum solo intentará autenticarse usando cookies cuando la solicitud entrante
se origine desde su propia interfaz de SPA. Cuando Sanctum examina una solicitud
HTTP entrante, primero buscará una cookie de autenticación y, si no hay ninguna
presente, Sanctum luego examinará el encabezado de Autorización en busca de un
token de API válido.

Notas
=====

Está perfectamente bien usar Sanctum solo para la autenticación de token
API o solo para la autenticación SPA.  El hecho de que use Sanctum no significa
que deba usar las dos funciones que ofrece.

Las versiones más recientes de Laravel ya incluyen Laravel Sanctum. Sin embargo,
si el archivo composer.json de su aplicación no incluye laravel/sanctum, puede
seguir las instrucciones de instalación a continuación.

1) Instalación

Puede instalar Laravel Sanctum a través del administrador de paquetes Composer:

$ composer require laravel/sanctum

2) A continuación, debe publicar los archivos de configuración y migración de
Sanctum mediante el comando vendor:publish Artisan. El archivo de configuración
de sanctum se colocará en el directorio /config de su aplicación:

$ php artisan vendor:publish --provider="Laravel\Sanctum\SanctumServiceProvider"

La salida del comando debe ser algo como esto:

Copied Directory [/vendor/laravel/sanctum/database/migrations] To [/database/migrations]
Copied File [/vendor/laravel/sanctum/config/sanctum.php] To [/config/sanctum.php]
Publishing complete.

Esto quiere decir que se creó la migración el archivo de configuración de
sanctum y también la migración donde se van a almacenar los tokens que
proporcione a los usuarios que inicien sesión o se registren en el sistema.

3) Finalmente, debe ejecutar las migraciones de su base de datos. Sanctum creará
una tabla de base de datos en la que almacenar tokens API:

$ php artisan migrate

Emisión de tokens de API
========================

Sanctum le permite emitir tokens de API/tokens de acceso personal que pueden
usarse para autenticar solicitudes de API en su aplicación. Al realizar
solicitudes con tokens de API, el token debe incluirse en el encabezado de
autorización como un token de portador.

4) Para comenzar a emitir tokens para los usuarios, su modelo de Usuario debe
usar el rasgo Laravel\Sanctum\HasApiTokens:

use Laravel\Sanctum\HasApiTokens;

class User extends Authenticatable
{
    use HasApiTokens, HasFactory, Notifiable;
}

Para esta práctica se crearan solo 3 endpoints, para registrar, para autenticar
y un tercero para ubicar al usuario autenticado actualmente.

5) Ahora hay que crear un nuevo controlador desde donde se van a crear los
métodos para este ejemplo:

$ php artisan make:controller AuthController

Esto nos crea /app/Http/Controllers/AuthController.php

Modificamos AuthController.php, agregamos el método register que permitira
recibir solicitudes donde se envie la data de un usuario a ser registrado de tal
manera que:

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use App\Models\User;

class AuthController extends Controller
{
    /*
    |--------------------------------------------------------------------------
    | Register, method that allows receiving data from a request, validating it
    | and storing it in the users and tokens table, it returns a json response
    | with the assigned token.
    |--------------------------------------------------------------------------
    */
    public function register(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|string|email|max:255|unique:users',
            'password' => 'required|string|min:8',
        ]);

        $user = User::create([
            'name' => $request['name'],
            'email' => $request['email'],
            'password' => Hash::make($request['password'])
        ]);

        $token = $user->createToken('auth_token')->plainTextToken;

        return response()->json([
            'access_token' => $token,
            'token_type' => 'Bearer'
        ], 200);
    }
}

y agregamos la ruta al controlador en routes/api.php

<?php

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;
use App\Http\Controllers\AuthController;

/*
|--------------------------------------------------------------------------
| API Routes
|--------------------------------------------------------------------------
*/

Route::middleware('auth:api')->get('/user', function (Request $request) {
    return $request->user();
});

Route::post('register', [AuthController::class, 'register']);

Ahora para probarla podemos hacer una solicitud http post a
http://127.0.0.1:8000/api/register con axios, tal que:

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Register example</title>
  <script src="https://unpkg.com/vue@2"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
</head>
<body>
<div id="app">
  <form method="post" @submit.prevent="register">
    <label class="label">Name</label>
    <div>
      <input
        v-model="name"
        type="text"
        name="name"
      />
    </div>
    <label class="label">Email</label>
    <div>
      <input
        v-model="email"
        type="email"
        name="email"
      />
    </div>
    <label class="label">Password</label>
    <div>
      <input
        v-model="password"
        type="password"
        name="password"
      />
    </div>
    <br>
    <button type="submit" class="button">
      Register
    </button>
  </form>
</div>
<script type="text/javascript">
var app = new Vue({
  el: "#app",
  data: {
    name: '',
    email: '',
    password: ''
  },
  methods: {
    register () {
      const userData = {
        name: this.name,
        email: this.email,
        password: this.password
      }
      const header = {
        headers: {
          'Content-Type': 'application/json;charset=UTF-8',
          'Access-Control-Allow-Origin': '*',
          'Content-Language': 'en'
        }
      }
      axios.post('http://127.0.0.1:8000/api/register', userData, header)
        .then((response) => {
          console.log(response)
          alert('Success')
        })
        .catch((error) => {
          console.log(this.name)
          console.log(error)
          alert('Access denied')
        })
    }
  }
});
</script>
</body>
</html>

Al hacer el post debería responder un alert con Success y haber creado un nuevo
usuario en la tabla users de la base de datos así como haber almacenado un token
en la tabla personal_access_token.

y la respuesta json debe ser:

{
	"access_token": "1|xxxxxxxxxxxxxx",
	"token_type": "Bearer"
}

6) Ahora agregamos el método login que permitira recibir solicitudes donde se
envie la data de un usuario a ser autenticado de tal manera que:

use Illuminate\Support\Facades\Auth;

/*
|--------------------------------------------------------------------------
| Login, method that receives data from a request, compares it with the data
| stored in the database and returns a json response.
|--------------------------------------------------------------------------
*/
public function login(Request $request)
{
  $attr = $request->validate([
      'email' => 'required|string|email|max:255',
      'password' => 'required|string|min:8',
  ]);

  if (!Auth::attempt($attr)) {
      return response()->json([
          'message' => 'The data is invalid',
      ], 401);
  }
  else {
      $user = User::where('email', $request['email'])->firstOrFail();

      $token = $user->createToken('auth_token')->plainTextToken;

      return response()->json([
          'access_token' => $token,
          'token_type' => 'Bearer'
      ], 200);
  }
}

y en el archivo de rutas api.php agregamos una nueva:

use App\Http\Controllers\AuthController;

Route::post('login', [AuthController::class, 'login']);

De esta manera, ahora podemos probar, registrando un usuario primero y luego
haciendo una solicitud post con datos para probar la autenticación, ejemplo:

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Login example</title>
  <script src="https://unpkg.com/vue@2"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
</head>
<body>
<div id="app">
  <form method="post" @submit.prevent="login">
    <label class="label">Email</label>
    <div class="control">
      <input
        v-model="email"
        type="email"
        name="email"
      />
    </div>
    <label class="label">Password</label>
    <div class="control">
      <input
        v-model="password"
        type="password"
        name="password"
      />
    </div>
    <br>
    <button type="submit" class="button">
      Log In
    </button>
  </form>
</div>
<script type="text/javascript">
var app = new Vue({
  el: "#app",
  data: {
    email: '',
    password: ''
  },
  methods: {
    login () {
      const userData = {
        email: this.email,
        password: this.password
      }
      const header = {
        headers: {
          'Content-Type': 'application/json;charset=UTF-8',
          'Access-Control-Allow-Origin': '*',
          'Content-Language': 'en'
        }
      }
      axios.post('http://127.0.0.1:8000/api/login', userData, header)
        .then((response) => {
          console.log(response)
          alert('Success')
        })
        .catch((error) => {
          console.log(error)
          alert('Access denied')
        })
    }
  }
});
</script>
</body>
</html>

Al hacer el post debería responder con Success y haber creado un nuevo token en
la tabla personal_access_token que indica que está autenticado.

y la respuesta json debe ser:

{
	"access_token": "1|xxxxxxxxxxxxxx",
	"token_type": "Bearer"
}

Fuente
======

-https://www.youtube.com/watch?v=n-J3zw4OWmI&t=509s
-Ejemplo completo en: https://github.com/argenisosorio/laravel-8-sanctum-example

Protegiendo Rutas
=================

Para proteger las rutas de modo que todas las solicitudes entrantes deban ser
autenticadas, debe adjuntar la protección de autenticación de sanctum a sus
rutas protegidas dentro de sus archivos de ruta routes/web.php y routes/api.php.

Esta protección garantizará que las solicitudes entrantes se autentiquen como
solicitudes con estado autenticadas por cookies o que contengan un encabezado de
token de API válido si la solicitud es de un tercero.

Es posible que se pregunte por qué le sugerimos que autentique las rutas dentro
del archivo routes/web.php de su aplicación mediante el uso de sanctum guard.

Recuerde, Sanctum primero intentará autenticar las solicitudes entrantes
utilizando la cookie de autenticación de sesión típica de Laravel. Si esa
cookie no está presente, Sanctum intentará autenticar la solicitud utilizando un
token en el encabezado de Autorización de la solicitud. Además, la autenticación
de todas las solicitudes con Sanctum garantiza que siempre podamos llamar al
método tokenCan en la instancia de usuario actualmente autenticada:

use Illuminate\Http\Request;

Route::middleware('auth:sanctum')->get('/user', function (Request $request) {
    return $request->user();
});

Otra definición
===============

Para proteger las rutas de modo que todas las solicitudes entrantes deban
autenticarse, debe adjuntar la protección de autenticación sanctum a sus rutas
API dentro de su archivo routes/api.php. Esta protección se asegurará de que las
solicitudes entrantes se autentiquen como solicitudes autenticadas con estado de
su SPA o contengan un encabezado de token API válido si la solicitud es de un
tercero:

Route::middleware('auth:sanctum')->get('/user', function (Request $request) {
    return $request->user();
});

Otra forma, más usada:

Route::group(['middleware' => ['auth:sanctum']], function() {
    Route::resource('projects', ProjectController::class);
});

Fuente
======

https://laravel.com/docs/9.x/sanctum

==========
Laravel ui
==========

El paquete laravel ui proporciona los pasos simples para el andamiaje de
autenticación. Es simple en la interfaz de usuario, fácil de instalar.

1) Instalar Laravel UI

Acceda al proyecto Laravel ya creado en la terminal y escriba el comando dado.

$ composer require laravel/ui

Nota: esto instalará la última versión de laravel ui, la cual no es compatible
con Laravel 8.0.0 o menores, si se requiere para esa versión o menores puede
especificar la versión a instalar con el comando:

$ composer require laravel/ui "^3.0"

2) Una vez que se ha instalado el paquete laravel/ui, debe instalar el scaffolding
frontend usando el comando ui artisan:

$ php artisan ui bootstrap --auth

Esto realiza lo siguiente:

Modificados:

package.json
resources/js/bootstrap.js
routes/web.php
webpack.mix.js

Nuevos:

app/Http/Controllers/Auth/
app/Http/Controllers/HomeController.php
resources/sass/
resources/views/auth/
resources/views/home.blade.php
resources/views/layouts/

3) Después de este comando, debe ejecutar el comando

$ npm install && npm run dev

Generará archivos compilados CSS y JS para el sistema de autenticación.

Si da problemas, en este ejemplo se uso Laravel 8 y "sass-loader": "^7.1.0",
modificar en el package.json y probar de nuevo el comando.

4) Ejecutar migración

A continuación, debemos ejecutar el comando de migración para generar tablas en
la base de datos. Abra la terminal y ejecute este comando artesanal.

$ php artisan migrate

5) Prueba de aplicación

Abra el proyecto en la terminal y escriba el comando para iniciar el servidor de
desarrollo

$ php artisan serve

Urls:

http://127.0.0.1:8000/
http://127.0.0.1:8000/login
http://127.0.0.1:8000/register
http://127.0.0.1:8000/home

Fuente
======

https://diegooo.com/laravel-ui-autenticacion-de-laravel-8/

===============
Laravel fortify
===============

Es un sistema de autenticación backend para Laravel "Agnostic frontend", es
decir que no importa que tecnología se use en el frontend, ya se vuejs, react,
angular.

No provee ninguna vista con formularios ni nada, solo provee rutas y
controladores necesarios para:

-Iniciar sesión y cerrar sesión:
-Registrar usuarios:
-Restablecer contraseñas:
-Verificar validéz del correo electrónico del usuario
-Confirmación de contraseña
-Actualizar los datos del usuario
-Actualizar contraseña
-Autenticación de 2 factores

Los controladores de estas acciones están en:

/vendor/laravel/fortify/src/Http/Controllers

Todas estas caracteristaicas se puede habilitar o deshabilitar en el archivo de
configuración de fortify config/fortify.php:

'features' => [
    Features::registration(),
    Features::resetPasswords(),
    Features::emailVerification(),
    Features::updateProfileInformation(),
    Features::updatePasswords(),
    Features::twoFactorAuthentication([
        'confirmPassword' => true,
    ]),
],

Este archivo de configuración lo obtenemos al ejecutar:

$ php artisan vendor:publish --provider="Laravel\Fortify\FortifyServiceProvider"

Además de eso nos va a generar otra serie de archivos que permitira personalizar
las funcionalidades del paquete.

Después de instalar Fortify, puede ejecutar el php artisan route:list para ver
las rutas que tiene registradas Fortify.

Dado que Fortify no proporciona su propia interfaz de usuario, debe combinarse
con su propia interfaz de usuario que realiza solicitudes a las rutas que
registra.

No es necesario que use Fortify para usar las funciones de autenticación de
Laravel. Siempre puede interactuar manualmente con los servicios de
autenticación de Laravel siguiendo la documentación oficial disponible.

Laravel Fortify esencialmente toma las rutas y los controladores de Laravel
Breeze y los ofrece como un paquete que no incluye una interfaz de usuario. Esto
le permite montar rápidamente la implementación de back-end de la capa de
autenticación de su aplicación sin estar atado a ninguna opinión de front-end en
particular.

¿Cuándo debo usar Fortify?
==========================

Cuando queramos implementar la interfaz de usuario (login, register, reset
password, etc) nosotros mismos.

Quizás se esté preguntando cuándo es apropiado usar Laravel Fortify. Primero, si
está utilizando uno de los kits de inicio de aplicaciones como Laravel Breeze,
no necesita instalar Laravel Fortify ya que todos los kits de inicio de
aplicaciones de Laravel ya brindan una implementación de autenticación completa.

Si no está utilizando un kit de inicio de aplicaciones y su aplicación necesita
funciones de autenticación, tiene dos opciones: implementar manualmente las
funciones de autenticación de su aplicación o usar Laravel Fortify para
proporcionar la implementación de back-end de estas funciones.

Si elige instalar Fortify, su interfaz de usuario realizará solicitudes a las
rutas de autenticación de Fortify que se detallan en esta documentación para
autenticar y registrar usuarios.

Si elige interactuar manualmente con los servicios de autenticación de Laravel
en lugar de usar Fortify, puede hacerlo siguiendo la documentación oficial
disponible.

Laravel Fortificar y Laravel Sanctum
====================================

Algunos desarrolladores se confunden con respecto a la diferencia entre Laravel
Sanctum y Laravel Fortify. Debido a que los dos paquetes resuelven dos problemas
diferentes pero relacionados, Laravel Fortify y Laravel Sanctum no son paquetes
mutuamente excluyentes ni competidores.

Laravel Sanctum solo se ocupa de administrar tokens de API y autenticar a los
usuarios existentes mediante tokens o cookies de sesión. Sanctum no proporciona
ninguna ruta que gestione el registro de usuarios, el restablecimiento de
contraseñas, etc.

Si está intentando construir manualmente la capa de autenticación para una
aplicación que ofrece una API o sirve como back-end para una aplicación de una
sola página (SPA), es muy posible que utilice Laravel Fortify (para registro de
usuarios, restablecimiento de contraseña, etc.) y Laravel Sanctum
(administración de tokens API, autenticación de sesión).

Instalación
===========

Para comenzar, instale Fortify usando el administrador de paquetes de Composer:

$ composer require laravel/fortify

Luego, publique los recursos de Fortify usando el vendor:publishmando:

$ php artisan vendor:publish --provider="Laravel\Fortify\FortifyServiceProvider"

Este comando publicará las acciones de Fortify en app/Actions, se creará si no
existe. además, creara el FortifyServiceProvider, que es el archivo de
configuración y todas las migraciones de bases de datos necesarias se publicarán.

A continuación, debe migrar su base de datos:

$ php artisan migrate

El proveedor de servicios de Fortify
====================================

El comando de publicación también creará
app\Providers\FortifyServiceProviderclase. Debe asegurarse de que esta clase
esté registrada en el arreglo providers de la aplicación, en el archivo
config/app.php.

El proveedor de servicios de Fortify registra las acciones que Fortify publicó
e indica a Fortify que las use cuando Fortify ejecute sus respectivas tareas.

Características de Fortify
==========================

El archivo de configuración config/fortify.php contiene un arreglo con las
features.

Este arreglo define qué rutas/características de backend expondrá Fortify de
forma predeterminada.

Si no está utilizando Fortify en combinación con Laravel Jetstream , le
recomendamos que solo habilite las siguientes funciones, que son las funciones
básicas de autenticación proporcionadas por la mayoría de las aplicaciones de
Laravel:

'features' => [
    Features::registration(),
    Features::resetPasswords(),
    Features::emailVerification(),
],

Deshabilitar vistas
===================

De forma predeterminada, Fortify define rutas destinadas a devolver vistas, como
una pantalla de inicio de sesión o una pantalla de registro. Sin embargo, si
está creando una aplicación de una sola página impulsada por JavaScript, es
posible que no necesite estas rutas. Por esa razón, puede deshabilitar estas
rutas por completo configurando el valor de configuración dev views dentro de su
archivo de configuración config/fortify.php en false:

'views' => false,

Desactivación de vistas y restablecimiento de contraseña
========================================================

Si elige deshabilitar las vistas de Fortify e implementará funciones de
restablecimiento de contraseña para su aplicación, aún debe definir una ruta
llamada password.reset que es responsable de mostrar la vista de
"restablecimiento de contraseña" de su aplicación. Esto es necesario porque
Laravel Illuminate\Auth\Notifications\ResetPasswordnotificación generará la URL
de restablecimiento de contraseña a través de la ruta password.reset nombrada.

Autenticación
=============

Para comenzar, debemos indicarle a Fortify cómo devolver nuestra vista de
"inicio de sesión". Recuerde, Fortify es una biblioteca de autenticación sin
periféricos. Si desea una implementación de frontend de las funciones de
autenticación de Laravel que ya están completas para usted, debe usar un kit de
inicio de aplicación.

Toda la lógica de representación de la vista de autenticación se puede
personalizar utilizando los métodos apropiados disponibles a través de la clase
Laravel\Fortify\Fortify. Por lo general, debe llamar a este método desde el
boot de su aplicación App\Providers\FortifyServiceProvider. Fortify se
encargará de definir la ruta /login que devuelve esta vista.

use Laravel\Fortify\Fortify;

/**
 * Bootstrap any application services.
 *
 * @return void
 */
public function boot()
{
    Fortify::loginView(function () {
        return view('auth.login');
    });

    // ...
}

Su plantilla de inicio de sesión debe incluir un formulario que realice una
solicitud POST a /login. El endpoint /login  espera una cadena email, username y
un password. El nombre del campo de correo electrónico / nombre de usuario debe
coincidir con el valor de username dentro del archivo de configuración
config/fortify.php.

Si el intento de inicio de sesión tiene éxito, Fortify lo redirigirá al URI
configurado a través de la opción home configurada dentro de su archivo de
configuración fortify. Si la solicitud de inicio de sesión fue una solicitud
XHR, se devolverá una respuesta HTTP 200.

Si la solicitud no tuvo éxito, el usuario será redirigido a la pantalla de
inicio de sesión y los errores de validación estarán disponibles para usted a
través de la página compartida.

Personalización de la autenticación de usuario
==============================================

Fortify recuperará y autenticará automáticamente al usuario en función de las
credenciales proporcionadas y la protección de autenticación que está
configurada para su aplicación. Sin embargo, es posible que a veces desee tener
una personalización completa sobre cómo se autentican las credenciales de inicio
de sesión y cómo se recuperan los usuarios. Afortunadamente, Fortify le permite
lograr esto fácilmente usando el método Fortify::authenticateUsing.

Este método acepta un cierre que recibe la solicitud HTTP entrante. El cierre es
responsable de validar las credenciales de inicio de sesión adjuntas a la
solicitud y devolver la instancia de usuario asociada. Si las credenciales no
son válidas o no se puede encontrar ningún usuario, nullo false debe ser
devuelto por el cierre. Por lo general, este método debe llamarse desde el
método boot de su FortifyServiceProvider:

use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Laravel\Fortify\Fortify;

/**
 * Bootstrap any application services.
 *
 * @return void
 */
public function boot()
{
    Fortify::authenticateUsing(function (Request $request) {
        $user = User::where('email', $request->email)->first();
 
        if ($user &&
            Hash::check($request->password, $user->password)) {
            return $user;
        }
    });

    // ...
}

Guardia de autenticación
========================

Puede personalizar la protección de autenticación utilizada por Fortify dentro
de la configuración de su aplicación. Sin embargo, debe asegurarse de que la
protección configurada sea una implementación de
Illuminate\Contracts\Auth\StatefulGuard. Si está intentando usar Laravel Fortify
para autenticar un SPA, debe usar el valor predeterminado de guardia web en
combinación con Laravel Sanctum.

Personalización de la canalización de autenticación
===================================================

Laravel Fortify autentica las solicitudes de inicio de sesión a través de una
canalización de clases invocables. Si lo desea, puede definir una canalización
personalizada de clases a través de las cuales se deben canalizar las
solicitudes de inicio de sesión. Cada clase debe tener un método __invoke que
recibe la entrada Illuminate\Http\Request y, como middleware, una variable $next
que se invoca para pasar la solicitud a la siguiente clase en la canalización.

Para definir su tubería personalizada, puede usar el método
Fortify::authenticateThrough. Este método acepta un cierre que debería devolver
la matriz de clases para canalizar la solicitud de inicio de sesión. Por lo
general, este método debe llamarse desde el bootmétodo de su clase
App\Providers\FortifyServiceProvider.

El siguiente ejemplo contiene la definición de canalización predeterminada que
puede usar como punto de partida al realizar sus propias modificaciones:

use Laravel\Fortify\Actions\AttemptToAuthenticate;
use Laravel\Fortify\Actions\EnsureLoginIsNotThrottled;
use Laravel\Fortify\Actions\PrepareAuthenticatedSession;
use Laravel\Fortify\Actions\RedirectIfTwoFactorAuthenticatable;
use Laravel\Fortify\Fortify;
use Illuminate\Http\Request;

Fortify::authenticateThrough(function (Request $request) {
    return array_filter([
            config('fortify.limiters.login') ? null : EnsureLoginIsNotThrottled::class,
            Features::enabled(Features::twoFactorAuthentication()) ? RedirectIfTwoFactorAuthenticatable::class : null,
            AttemptToAuthenticate::class,
            PrepareAuthenticatedSession::class,
    ]);
});

Personalización de redireccionamientos
======================================

Si el intento de inicio de sesión tiene éxito, Fortify lo redirigirá al URI
configurada a través de la opción home. Si la solicitud de inicio de sesión fue
una solicitud XHR, se devolverá una respuesta HTTP 200. Después de que un
usuario cierra la sesión de la aplicación, el usuario será redirigido a la
/ODIO.

Si necesita una personalización avanzada de este comportamiento, puede enlazar
implementaciones del LoginResponse y LogoutResponse en el contenedor de
servicios. Por lo general, esto debe hacerse dentro del método register de su
clase App\Providers\FortifyServiceProvider:

use Laravel\Fortify\Contracts\LogoutResponse;

/**
 * Register any application services.
 *
 * @return void
 */
public function register()
{
    $this->app->instance(LogoutResponse::class, new class implements LogoutResponse {
        public function toResponse($request)
        {
            return redirect('/');
        }
    });
}

Registro
========

Para comenzar a implementar la funcionalidad de registro de nuestra aplicación,
debemos indicarle a Fortify cómo devolver nuestra vista de "registro". Recuerde,
Fortify es una biblioteca de autenticación sin periféricos. Si desea una
implementación de frontend de las funciones de autenticación de Laravel que ya
están completas para usted, debe usar un kit de inicio de aplicación.

Toda la lógica de renderizado de vistas de Fortify se puede personalizar usando
los métodos apropiados disponibles a través de la clase Laravel\Fortify\Fortify.
Por lo general, debe llamar a este método desde el método boot de su clase
App\Providers\FortifyServiceProvider:

use Laravel\Fortify\Fortify;

/**
 * Bootstrap any application services.
 *
 * @return void
 */
public function boot()
{
    Fortify::registerView(function () {
        return view('auth.register');
    });

    // ...
}

Fortify se encargará de definir la ruta /register que devuelve esta vista. Tu
plantilla register debe incluir un formulario que realice una solicitud POST al
endopoint /register definido por Fortify.

el endpoint /register espera una cadena name, cadena de dirección de correo
electrónico/nombre de usuario, password, y password_confirmation.fortifyarchivo
de configuración.

Si el intento de registro tiene éxito, Fortify redirigirá al usuario al URI
configurado a través de la opción home configurada dentro de su aplicación
archivo de configuración de fortify. Si la solicitud de inicio de sesión fue una
solicitud XHR, se devolverá una respuesta HTTP 200.

Si la solicitud no tuvo éxito, el usuario será redirigido a la pantalla de
registro y los errores de validación estarán disponibles para usted a través de
la página compartida. $errors Variable de plantilla de hoja, o, en el caso de
una solicitud XHR, los errores de validación se devolverán con una respuesta
HTTP 422.

Personalización del registro
============================

El proceso de validación y creación de usuarios se puede personalizar
modificando la acción App\Actions\Fortify\CreateNewUser que se generó cuando
instaló Laravel Fortify.

Restablecimiento de contraseña
==============================

Solicitud de un enlace de restablecimiento de contraseña

Para comenzar a implementar la funcionalidad de restablecimiento de contraseña
de nuestra aplicación, debemos indicarle a Fortify cómo devolver nuestra vista
de "contraseña olvidada". Recuerde, Fortify es una biblioteca de autenticación
sin periféricos. Si desea una implementación de frontend de las funciones de
autenticación de Laravel que ya están completas para usted, debe usar un kit de
inicio de aplicación.

Toda la lógica de renderizado de vistas de Fortify se puede personalizar
utilizando los métodos apropiados disponibles a través de la clas
Laravel\Fortify\Fortify. Por lo general, debe llamar a este método desde el
método bootm de su clase App\Providers\FortifyServiceProvider:

use Laravel\Fortify\Fortify;

/**
 * Bootstrap any application services.
 *
 * @return void
 */
public function boot()
{
    Fortify::requestPasswordResetLinkView(function () {
        return view('auth.forgot-password');
    });

    // ...
}

Fortify se encargará de definir el endpont /forgot-password que devuelve esta
vista. Tu plantilla forgot-password debe incluir un formulario que realice una
solicitud POST al endpoint /forgot-password.

El endpont /forgot-password espera una cadena email. El nombre de este
campo/columna de la base de datos debe coincidir con el valor email de
configuración dentro de su aplicación fortify.

Protegiendo Rutas
=================

Para especificar que una ruta o grupo de rutas requiere que el usuario haya
verificado su dirección de correo electrónico, debe adjuntar el código integrado
de Laravel. verifiedmiddleware a la ruta. Este middleware está registrado dentro
de su la clase App\Http\Kernel:

Route::get('/dashboard', function () {
    // ...
})->middleware(['verified']);

===========================================================
Instalando y configurando fortify en un proyecto de Laravel
===========================================================

1- En un proyecto ya creado y limpio, chqueamos las rutas que trae el proyecto
con:

$ php artisan route:list -c

+----------+----------+----------------------------------------------+
| Method   | URI      | Action                                       |
+----------+----------+----------------------------------------------+
| GET|HEAD | /        | Closure                                      |
| GET|HEAD | api/user | Closure                                      |
+----------+----------+----------------------------------------------+

Veremos que nos muestra la ruta a la raíz (/) y la ruta (api/user) que nos
devuelve el usuario autenticado.

2- Instalar fortify en su última versión:

$ composer require laravel/fortify

3.1- Instalar una versión específica de fortify, para laravel 8 sería la 1.8:

$ composer require laravel/fortify 1.8

3- Luego de realizar la instalación, chequeamos las rutas de nuevo y veremos
todas las rutas que nos instala fortify por defecto:

$ php artisan route:list -c
+----------+---------------------------------+---------------------------------------------------------------------------------+
| Method   | URI                             | Action                                                                          |
+----------+---------------------------------+---------------------------------------------------------------------------------+
| GET|HEAD | /                               | Closure                                                                         |
| GET|HEAD | api/user                        | Closure                                                                         |
| POST     | email/verification-notification | Laravel\Fortify\Http\Controllers\EmailVerificationNotificationController@store  |
| GET|HEAD | email/verify                    | Laravel\Fortify\Http\Controllers\EmailVerificationPromptController@__invoke     |
| GET|HEAD | email/verify/{id}/{hash}        | Laravel\Fortify\Http\Controllers\VerifyEmailController@__invoke                 |
| GET|HEAD | forgot-password                 | Laravel\Fortify\Http\Controllers\PasswordResetLinkController@create             |
| POST     | forgot-password                 | Laravel\Fortify\Http\Controllers\PasswordResetLinkController@store              |
| POST     | login                           | Laravel\Fortify\Http\Controllers\AuthenticatedSessionController@store           |
| GET|HEAD | login                           | Laravel\Fortify\Http\Controllers\AuthenticatedSessionController@create          |
| POST     | logout                          | Laravel\Fortify\Http\Controllers\AuthenticatedSessionController@destroy         |
| POST     | register                        | Laravel\Fortify\Http\Controllers\RegisteredUserController@store                 |
| GET|HEAD | register                        | Laravel\Fortify\Http\Controllers\RegisteredUserController@create                |
| POST     | reset-password                  | Laravel\Fortify\Http\Controllers\NewPasswordController@store                    |
| GET|HEAD | reset-password/{token}          | Laravel\Fortify\Http\Controllers\NewPasswordController@create                   |
| POST     | two-factor-challenge            | Laravel\Fortify\Http\Controllers\TwoFactorAuthenticatedSessionController@store  |
| GET|HEAD | two-factor-challenge            | Laravel\Fortify\Http\Controllers\TwoFactorAuthenticatedSessionController@create |
| POST     | user/confirm-password           | Laravel\Fortify\Http\Controllers\ConfirmablePasswordController@store            |
| GET|HEAD | user/confirm-password           | Laravel\Fortify\Http\Controllers\ConfirmablePasswordController@show             |
| GET|HEAD | user/confirmed-password-status  | Laravel\Fortify\Http\Controllers\ConfirmedPasswordStatusController@show         |
| PUT      | user/password                   | Laravel\Fortify\Http\Controllers\PasswordController@update                      |
| PUT      | user/profile-information        | Laravel\Fortify\Http\Controllers\ProfileInformationController@update            |
| POST     | user/two-factor-authentication  | Laravel\Fortify\Http\Controllers\TwoFactorAuthenticationController@store        |
| DELETE   | user/two-factor-authentication  | Laravel\Fortify\Http\Controllers\TwoFactorAuthenticationController@destroy      |
| GET|HEAD | user/two-factor-qr-code         | Laravel\Fortify\Http\Controllers\TwoFactorQrCodeController@show                 |
| GET|HEAD | user/two-factor-recovery-codes  | Laravel\Fortify\Http\Controllers\RecoveryCodeController@index                   |
| POST     | user/two-factor-recovery-codes  | Laravel\Fortify\Http\Controllers\RecoveryCodeController@store                   |
+----------+---------------------------------+---------------------------------------------------------------------------------+

4- Publicar los archivos de configuración con el siguiente comando:

$ php artisan vendor:publish --provider="Laravel\Fortify\FortifyServiceProvider"

La salida deber ser esta:

Copied File [/vendor/laravel/fortify/stubs/fortify.php] To [/config/fortify.php]
Copied File [/vendor/laravel/fortify/stubs/CreateNewUser.php] To [/app/Actions/Fortify/CreateNewUser.php]
Copied File [/vendor/laravel/fortify/stubs/FortifyServiceProvider.php] To [/app/Providers/FortifyServiceProvider.php]
Copied File [/vendor/laravel/fortify/stubs/PasswordValidationRules.php] To [/app/Actions/Fortify/PasswordValidationRules.php]
Copied File [/vendor/laravel/fortify/stubs/ResetUserPassword.php] To [/app/Actions/Fortify/ResetUserPassword.php]
Copied File [/vendor/laravel/fortify/stubs/UpdateUserProfileInformation.php] To [/app/Actions/Fortify/UpdateUserProfileInformation.php]
Copied File [/vendor/laravel/fortify/stubs/UpdateUserPassword.php] To [/app/Actions/Fortify/UpdateUserPassword.php]
Copied Directory [/vendor/laravel/fortify/database/migrations] To [/database/migrations]
Publishing complete.

Podemos chequear los cambios con git status:

$ git status
Archivos sin seguimiento:
  (usa "git add <archivo>..." para incluirlo a lo que se será confirmado)
	app/Actions/
	app/Providers/FortifyServiceProvider.php
	config/fortify.php
	database/migrations/2014_10_12_200000_add_two_factor_columns_to_users_table.php

5- Ahora vamos a /config/app.php y agregamos a
App\Providers\FortifyServiceProvider::class, en el arreglo 'providers' => []
tal que:

/*
 * Application Service Providers...
 */
App\Providers\AppServiceProvider::class,
App\Providers\AuthServiceProvider::class,
// App\Providers\BroadcastServiceProvider::class,
App\Providers\EventServiceProvider::class,
App\Providers\RouteServiceProvider::class,
App\Providers\FortifyServiceProvider::class,

6- Revisemos el archivo de configuración config/fortify.php y repasemos sus
variables:

'guard' => 'web', // guard que va a utilizar fortify para autenticar usuarios.

'passwords' => 'users', // Configuración de password que utilizará fortify para
restablecer las contraseñas.

'username' => 'email', // Nombre del campo username que fortify usara para
autenticar el usuario.

'email' => 'email', // Nombre del campo email que fortify usara para restablecer
la contraseña.

'home' => RouteServiceProvider::HOME, // Es la ruta a la que serán
redireccionados los usuarios autenticados. es decir a la ruta home que está
en app/Providers/RouteServiceProvider.php:

public const HOME = '/home';

'prefix' => '', // Es el prefijo que le podemos poner a las rutas de fortify,
por ejemplo si ponemos api, las rutas de fortify serían así:

$ php artisan route:list --columns=method,uri
+----------+------------------------------------+
| Method   | URI                                |
+----------+------------------------------------+
| GET|HEAD | /                                  |
| POST     | api/forgot-password                |
| GET|HEAD | api/forgot-password                |
| POST     | api/login                          |

'domain' => null, // Si lo dejamos en null, va a usar el valor por defecto que
haya en la variable APP_URL del archivo .env.

'middleware' => ['web'], // Define el middleware que se aplicará a las rutas de
fortify.

'views' => true, // Determinar si registrar o no las rutas que devuelven las
vistas, si se va a usar fortify para una API se puede deshabilitar esa opción.

'features' => [] // Son las características de fortify que podemos habilitar o
deshabilitar según convenga.

7- Ahora vamos a revisar el archivo app/Providers/FortifyServiceProvider.php

En el método boot vemos 4 registros de acciones:

Fortify::createUsersUsing(CreateNewUser::class);
Fortify::updateUserProfileInformationUsing(UpdateUserProfileInformation::class);
Fortify::updateUserPasswordsUsing(UpdateUserPassword::class);
Fortify::resetUserPasswordsUsing(ResetUserPassword::class);

La acción createUsersUsing se encuentra en app/Actions/Fortify/CreateNewUser.php
Para crear un usuario se va a usar esa acción. Los mismo para las demás
acciones, con la funcionalidad estandar.

8- Revisamos migrations/2014_10_12_200000_add_two_factor_columns_to_users_table.php
Donde vemos que agrega dos nuevos campos a la tabla users, correspondientes a la
autenticación de 2 factores que se puede configurar para los usuarios.

9- Al instalar fortify se habilitarán en la ruta / desde la interfaz, enlaces
Log in y Register, antes no aparecían y ahora si porque en la vista genérica
welcome están los condicionales @if (Route::has('login')) y @if
(Route::has('register')) que verifican si está definida la ruta login o
register.

Si le damos click al login, nos muestra este error en el navegador web:

Target [Laravel\Fortify\Contracts\LoginViewResponse] is not instantiable

Esto quiere decir que o hay una vista creada que de una respuesta a esa petición.

10- Vamos a crearla esa vista, vamos a /app/Providers/FortifyServiceProvider.php
y en el método boot agregamos Fortify::loginView('login');, tal que:

public function boot()
{
    Fortify::loginView('login');
    Fortify::createUsersUsing(CreateNewUser::class);
    Fortify::updateUserProfileInformationUsing(UpdateUserProfileInformation::class);
    Fortify::updateUserPasswordsUsing(UpdateUserPassword::class);
    Fortify::resetUserPasswordsUsing(ResetUserPassword::class);

    RateLimiter::for('login', function (Request $request) {
        return Limit::perMinute(5)->by($request->email.$request->ip());
    });

    RateLimiter::for('two-factor', function (Request $request) {
        return Limit::perMinute(5)->by($request->session()->get('login.id'));
    });
}

Si le damos click al login, nos muestra este error en el navegador web:

View [login] not found.

Que es diferente al primer error que se nos mostraba al darle click, este nuevo
error significa que no encuentra la vista login.

Podemos crear una carpeta llamada auth para guardar esta vista, la ruta sería:

/resources/views/auth y dentro creamos login.blade.php y es ahí donde vamos
a crear el formulario del login. y en el método boot sería:

Fortify::loginView('auth.login');

Ahora si visitamos http://127.0.0.1:8000/login ya deberiamos ver nuestra vista
vacía de login.blade.php.

11- Agregamos lo siguiente a la vista login:

<form action="{{ route('login') }}" method="POST">
    @csrf
    <label>
        <input type="email" name="email" placeholder="email">
        @error('email') <div>{{ $message }}</div> @enderror
    </label>
    <label>
        <input type="password" name="password" placeholder="password">
        @error('password') <div>{{ $message }}</div> @enderror
    </label>
    <input type="submit" value="Login">
</form>

Para poder probarlo debe haber un usuario registrado en la base de datos.
Si nos autenticamos correctamente nos manda a /home que es lo que tenemos
configurado en /app/Providers/RouteServiceProvider.php.

Para probar y ver los datos del usuario autenticado simplemente creamos la ruta
y la vista home o usamos la vista welcome y agregamos {{ auth()->user() }}
al html, esto nos imprime algo como esto:

{"id":1,"name":"admin","email":"admin@mail.com","email_verified_at":null,"created_at":null,"updated_at":null,"two_factor_secret":null,"two_factor_recovery_codes":null}

Para cerrar sesión simplemente hay que crear un formulario que apunte a la ruta
logout de fortify en alguna vista:

<form action="{{ route('logout') }}" method="POST">
    @csrf
    <button>Logout</button>
</form>

Al darle click cierra la sesión.

==================================================
Cómo usar el componente de traducciones de Laravel
==================================================

Laravel nos proporciona una manera fácil de traducir nuestras aplicaciones a
diferentes idiomas. En este tutorial aprenderemos a trabajar con la
internacionalización de nuestros proyecto con este framework.

Las traducciones de un proyecto de Laravel se guardan en el directorio
resources/lang/ donde se encontrará un directorio por cada idioma disponible por
la aplicación, por defecto viene incluido el idioma inglés (directorio «en»).

Laravel trae 4 archivos con traducciones para el idioma inglés de una
aplicación: auth.php, pagination.php, passwords.php y validation.php, pero
podemos agregar otros idiomas de una manera sencilla usando el repositorio de
GitHub Laravel-lang > https://github.com/caouecs/Laravel-lang, en el cual se
encuentra las traducciones de dichos archivos del framework en 50 idiomas. Para
usarlo tan solo tenemos que descargar el archivo .zip del repositorio, copiar el
directorio del idioma que nos interesa y pegarlo en el directorio
resources/lang/ de nuestro proyecto.

Cada archivo retorna un array con un conjunto de strings siguiendo el formato
‘clave’  => ‘valor’ que traducen la aplicación. Por ejemplo, si quisiéramos
crear un archivo llamado resources/lang/es/mesagges.php sería:

<?php
return [
    welcome' => 'Bienvenido a nuestra aplicación '
];

Dicho archivo también lo deberíamos crear en los otros directorios de idiomas
presentes en nuestra aplicación, en ingles sería resources/lang/en/mesagges.php:

<?php
return [
    welcome' => 'Welcome to our application'
];

Configuración
=============

Para establecer el idioma por defecto de una aplicación debemos ir al archivo
config/app.php y configurar la opción locale. Por ejemplo, para establecer el
español como idioma por defecto:

'locale' => 'es',
// 'locale' => 'en',

Es decir, el valor colocado debe coincidir con el nombre del directorio del
idioma.

También, Laravel proporciona la opción fallback_locale en la cual se establece
el idioma a usar en caso que el idioma activo no tenga la traducción respectiva.

Por ejemplo, habiendo establecido español como lenguaje predeterminado colocamos
el inglés cuando no se obtenga la traducción en el idioma español:

'fallback_locale' => 'en',

Uso
===

Para trabajar con las traducciones hacemos uso del helper trans() que recibe
como parámetro la clave utilizando la notación de puntos (dot notation), es
decir, siguiendo la nomenclatura archivo.clave, donde archivo es el nombre del
archivo y clave es el elemento que queremos traducir.

Por ejemplo, si queremos traducir la palabra welcome al español, ponemos estas
etiquetas en la plantilla de blade:

{{ __('mesagges.welcome') }}

@lang('mesagges.welcome')

{{ trans('mesagges.welcome') }}

Los resultados son:

Bienvenido a nuestra aplicación

Bienvenido a nuestra aplicación

Bienvenido a nuestra aplicación

Fuente
======

https://styde.net/como-usar-el-componente-de-traducciones-de-laravel/

==============================
El archivo VerifyCsrfToken.php
==============================

En este archiv están las URIs que deben o pueden excluirse de la verificación
CSRF, es decir que puedan usarse formularios sin que se quejen porque falta el
token de verificación.

/app/Http/Middleware/VerifyCsrfToken.php

=============================================================
Obtener los datos del usuario y el id del usuario autenticado
=============================================================

use Illuminate\Support\Facades\Auth;

// Obtener el usuario actualmente autenticado...
$user = Auth::user();

// Obtener el ID del usuario actualmente autenticado...
$id = Auth::id();

===============================================================
Funcionalidad de cambio de contraseña de un usuario autenticado
===============================================================

Ruta:

// Ruta que recibe los datos de la nueva contraseña del usuario.
Route::post('user-password-edit', [UserController::class, 'passwordEdit']);

Controlador:

/**
  * Método que recibe los datos y actualiza la nueva contraseña de los
  * usuarios.
  *
  * @method passwordEdit
  */
public function passwordEdit(Request $request)
{
    $request->validate(
    [
        'password' => 'required|min:8',
        'password_confirmation' => 'required|min:8|same:password'
    ],
    [
        'password.required' => 'El campo nueva contraseña es obligatorio',
        'password.min' => 'El campo nueva contraseña debe contener al menos 8 caracteres',
        'password_confirmation.required' => 'El campo confirmar contraseña es obligatorio',
        'password_confirmation.min' => 'El campo confirmar contraseña es obligatorio',
        'password_confirmation.same' => 'Los campos nueva contraseña y confirmar contraseña deben coincidir',
    ]);

    $id = Auth::id();
    $user = User::find($id);
    $user->password = Hash::make($request->input('password'));
    $user->save();
}

Controlador incluyendo el campo password actual:

public function passwordEdit(Request $request)
{
    $request->validate(
    [
        'old_password' => 'required|min:8|password',
        'new_password' => 'required|min:8',
        'password_confirmation' => 'required|min:8|same:new_password'
    ],
    [
        'old_password.required' => 'El campo contraseña actual es obligatorio',
        'old_password.min' => 'El campo contraseña actual debe contener al menos 8 caracteres',
        'new_password.required' => 'El campo nueva contraseña es obligatorio',
        'new_password.min' => 'El campo nueva contraseña debe contener al menos 8 caracteres',
        'password_confirmation.required' => 'El campo confirmar contraseña es obligatorio',
        'password_confirmation.min' => 'El campo confirmar contraseña es obligatorio',
        'password_confirmation.same' => 'Los campos nueva contraseña y confirmar contraseña deben coincidir',
        'old_password.password' => 'La contraseña actual es incorrecta',
    ]);

    $id = Auth::id();
    $user = User::find($id);
    if ($request->input('old_password')) {
        if (Hash::check($request->input('old_password'), $user->password)) {
            $id = Auth::id();
            $user = User::find($id);
            $user->password = Hash::make($request->input('new_password'));
            $user->save();
        }
    }
}

=================================================
Si el sistema redirecciona la url a popper.js.map
=================================================

ir a webpack.mix.js y agragrar .sourceMaps() tal que:

mix.js('resources/js/app.js', 'public/js')
    .sourceMaps()
    .vue()
    .sass('resources/sass/app.scss', 'public/css');

==================================================
Enviar mensajes o notificaciones flash al template
==================================================

En el controlador:

use Illuminate\Support\Facades\Session;

ó

use Session;

Session::flash('message', "Special message goes here");

En el template:

@if (Session::has('message'))
  <div class="alert alert-info">{{ Session::get('message') }}</div>
@endif

================================
Validar solo números en un campo
================================

'cédula' => ['required','digits_between:1,15'],

1,15 es el rango de dígitos requeridos

'cedula.digits_between' => 'La cédula de identidad debe contener solo números',

Método softDeletes()
====================

El método softDeletes lo que hace es agregar una columna de nombre deleted_at
que es nullable por defecto pero cuando reciba un valor guardara un TIMESTAMP
con una precisión opcional (dígitos totales). Esta columna está destinada a
almacenar la marca de tiempo deleted_at necesaria para la funcionalidad de
"eliminación suave" de Eloquent o "eliminación lógica" es decir que un registro
no es eliminado completamente de la base de datos, sino que se desactiva y puede
ser recuperado en caso de que se necesite, también sirve para hacer seguimiento
de los registros eliminados:

Implementación
==============

Agregramos $table->softDeletes(); en la tabla de la migración que se requiera:

public function up()
{
    Schema::create('projects', function (Blueprint $table) {
        $table->id();
        $table->string('name', 255)->nullable();
        $table->string('introduction', 500)->nullable();
        $table->timestamp('created_at')->useCurrent();
        $table->timestamp('updated_at')->nullable();
        $table->softDeletes();
    });
}

Y en el modelo agregagos

use Illuminate\Database\Eloquent\SoftDeletes;

use HasFactory, SoftDeletes;

Tal que:

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Model;

class Project extends Model
{
    use HasFactory, SoftDeletes;

    protected $table = 'projects';
    public $timestamps = true;

    protected $fillable = [
        'name',
        'introduction',
    ];
}

Luego php artisan migrate y listo, probar revisando las tablas y eliminando un
registro.

=================================================
Usando doble where en una consulta de controlador
=================================================

$users = DB::table('users')
    ->where('votes', '=', 100)
    ->where('age', '>', 35)
    ->get();

==========================================
Validar tamaño y tipo extensión de archivo
==========================================

public function store(Request $request)
{
    $this->validate(
        $request,
        [
            'refusal_file' => ['required', 'min:1', 'max:5120', 'mimes:pdf,docx,doc,odt'],
        ],
        [
            'refusal_file.required' => 'El acta de negativa familiar es obligatoria',
            'refusal_file.max' => 'El acta de negativa familiar no debe pesar más de 5MB',
            'refusal_file.mimes' => 'El acta de negativa familiar debe ser un archivo de tipo: pdf, docx, doc, odt',
        ]
    );

    DB::transaction(function () use ($request) {
        $file_path = $request->file('refusal_file')->store('public/refusal');
        Donor::updateOrCreate(
            [
                'id' => $request->donor_id,
            ],
            [
                'url_family_refusal_file' => $file_path,
            ]
        );
    });

    return $this->success('success');
}

======================================
Guardar archivos en laravel file input
======================================

1) Agregamos el campo document en la migración:

public function up()
{
    Schema::create('projects', function (Blueprint $table) {
        $table->string('document', 200)->nullable();
    });
}

2) Agregamos el campo document en el modelo como fillable:

protected $fillable = [
    'document'
];

3) Agregamos el campo document en el método store

public function store(Request $request)
{
    $request->validate([
        'document' => 'required',
        'document' => 'mimes:jpeg,gif,bmp,png'
    ]);

    $file_path = $request->file('document')->store('public/projects');
    Project::create([
        'document' => $file_path
    ]);
    return redirect()->route('projects.index')->with('success', 'Project created successfully.');
}

4) Agregamos el campo document en el formulario:

<form action="{{ route('projects.store') }}" method="POST" enctype="multipart/form-data">@csrf
  <div>
    <label>Document</label>
    <input type="file" name="document" />
  </div>
  <button type="submit">SAVE</button>
</form>

5) Si guardamos un archivo .png por ejemplo, no conservara su nombre original
y en la base de datos se guardara como public/projects/Dnv5HKKkarOhMGJIOdQP.png
por ejemplo, sin embargo el archivo integro se almacenará en
my-project/storage/app/public, pero para que pueda ser visualizado en el
navegador se debe hacer un enlace simbólico con el siguiente comando:

$ php artisan storage:link

El comando "php artisan storage:link" en Laravel crea un enlace simbólico entre
la carpeta de almacenamiento pública y la carpeta de almacenamiento privada.
Esto permite acceder a los archivos almacenados en la carpeta de almacenamiento
privada a través de una URL pública. Es útil cuando se necesita mostrar imágenes
u otros archivos almacenados en Laravel a través del navegador.

La salida sería:

The [/home/user/my-project/public/storage] link has been connected to
[/home/user/my-project/storage/app/public].
The links have been created.

Esto quiere decir que la imagen ahora se encuentra en
my-project/public/storage/projects/Dnv5HKKkarOhMGJIOdQP.png

Y desde el navegador será accesible desde:

http://127.0.0.1:8000/storage/projects/Dnv5HKKkarOhMGJIOdQP.png

======================
float() en migraciones
======================

El primer parámetro es el nombre del campo, el segundo parámetro corresponde al
máximo de dígitos y el tercero al máximo número de decimales.

$table->float('amount', 8, 2);

======================================================================
Obtener el valor de una variable del archivo .env desde un controlador
======================================================================

En el archivo .env declaramos SEND_MAILS=true

Ahora en el controlador declaramos:

$send_mails = env('SEND_MAILS');

Ahora la variable $send_mails tendra el valor de la variable del .env

Comprobar si está presente en el .env
=====================================

if (null !== env('SEND_MAILS')) {
    dd("está presente SEND_MAILS en el .env");
}
else {
    dd("No está presente SEND_MAILS en el .env");
}

Ejemplo
=======

Si es true, enviar email

if ($send_mails === true) {
    $user->notify(new UserRegistered($password));
}

Caso práctico real
==================

En el .env:

# Indica cuando la aplicación debe enviar correos electrónicos.
SEND_MAILS=true

-----

Crear una función helper en app/Helpers.php

/* Determina si la aplicación debe enviar correos electrónicos */
if (!function_exists('shouldSendMails')) {
    function shouldSendMails()
    {
        // Si SEND_MAILS no existe en .env, retorna true
        if (env('SEND_MAILS') === null) {
            return true;
        }

        // Si existe, retorna su valor convertido a booleano
        return env('SEND_MAILS') === 'true' || env('SEND_MAILS') === true;
    }
}

-----

En el controlador:

// Determina si la aplicación debe enviar el correo electrónico.
if (shouldSendMails()) {
    // Enviar notificación...
}

=============================================================
Obtener el valor de una variable del archivo .env desde blade
=============================================================

Si estás utilizando el archivo .env para configurar una URL de tu aplicación
Laravel y deseas utilizarla en tus vistas de Blade, puedes hacerlo de la
siguiente manera:

Ejemplo la variable WEB_URL=XXXX

Sería así:

<link rel="stylesheet" type="text/css" href="{{ env('WEB_URL') }}/bootstrap/css/bootstrap.min.css">

Con env('WEB_URL'), Laravel recuperará el valor de la variable WEB_URL
directamente del archivo .env. Esto te permitirá utilizar la URL base que has
configurado en tu archivo .env en el enlace de los estilos CSS.

Asegúrate de haber guardado los cambios en tu archivo .env y, si es necesario,
reiniciar tu servidor para que los cambios se reflejen correctamente en tu
aplicación Laravel.

Fuente
======

ChatGPT

=========================================
Tipo de dato enum en migración de Laravel
=========================================

Voy a mostrarte cómo usar el tipo de dato enum en Laravel dentro de una
migración. Será muy sencillo.

Primero debemos estar dentro de un archivo de migración y tener una variable de
tipo Blueprint que representa a la tabla. Después, invocamos a enum cuya
sintaxis es:

enum("columna", ["valores", "que", "puede", "tener"]);

Enum restringe el tipo de dato que puede tener la columna por lo cual si se
intenta guardar un nuevo valor que no está en el arreglo de datos de enum
dará problemas, es por esto que se puede cambiar el tipo de dato de la columna
mediante una migración nueva, cambiar la columna de enum a string para que
acepte nuevos valores.

Cambiando el tipo de dato enum por string
=========================================

Migración original:

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateDonorsTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('donors', function (Blueprint $table) {
            $table->enum('donorSchema', ['P', 'T']);
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('donors');
    }
}

-----

Nueva migración cambiando enum por string:

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class UpdateFieldDonorSchemaToNullableInDonorTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::table('donors', function (Blueprint $table) {
          $table->string('donorSchema')->nullable()
            ->comment('Donación de órganos parcial o total')->change();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::table('donors', function (Blueprint $table) {
            $table->enum('donorSchema', ['P', 'T'])
                ->comment('Donación de órganos parcial o total');
        });
    }
}

Si de casualidad lo anterior no funciona es porque no se borró la restricción
del campo, a pesar de que cambió su tipo de dato, eso por eso que hay que
eliminar la restricción (Para saber cual es la restricción, Laravel te la hará
saber mediante la excepción que te de por el navegador web, algunas es posibles
verlas analizando la tabla desde el gestor de la base de datos, pero otras no)
con algo como lo siguiente:

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class UpdateFieldToUsersTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        DB::statement("ALTER TABLE users DROP CONSTRAINT users_role_check");
        DB::getDoctrineSchemaManager()->getDatabasePlatform()->registerDoctrineTypeMapping('enum', 'string');
        Schema::table('users', function (Blueprint $table) {
            $table->string('role')
            ->nullable()
            ->default('USR')
            ->change();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
    }
}

Revisar las restricciones revisando la estructura de la tabla desde Postgres.

Fuente
======

https://stackoverflow.com/questions/33496518/how-to-change-enum-type-column-in-laravel-migration

=============================================================================
Validación de que el rif que viene por $request sea único en la base de datos
tomando en cuenta mayúsculas y minúsculas
=============================================================================

Muestra un mensaje personalizado.

$rifSupplier = PurchaseSupplier::whereRaw("LOWER(rif) = ?", strtolower($request->rif))->first();

$rules = [
    'person_type'                    => ['required'],
    'company_type'                   => ['required'],
    'rif'                            => [
        'required',
        'size:10',
        new RifRule,
        Rule::when($rifSupplier, function ($attribute, $value, $fail) {
            $fail('El campo rif ya ha sido registrado.');
        }),
    ],
]

Validación personalizada en Laravel
===================================

Si $message es true, salta el mensaje de valiadción

/* Validación de que no pueda registrarse un nuevo trabajador si no  hay
* cargos disponibles */

/* Obtener el valor de number_positions_assigned del PayrollPosition
relacionado */
$position = PayrollPosition::find($request->payroll_position_id);
$numberPositionsAssigned = $position->number_positions_assigned ? $position->number_positions_assigned : 0;

// Contar cuántos registros de PayrollEmployment ya están relacionados con el cargo
$existingEmploymentsCount = $position->payrollEmployments()->count();

if ($numberPositionsAssigned - $existingEmploymentsCount <= 0) {
    $message = true;
    $this->validate(
        $request,
        [
            'payroll_position_id' => [
                Rule::when($message, function ($attribute, $value, $fail) {
                    if ($value) {
                        $fail('No hay disponibilidad para el cargo que está intentando registrar');
                    }
                }),
            ],
        ],
    );
}
else {
    $message = false;
}

==================================
Relaciones polimórficas en Laravel
==================================

Podríamos empezar a definir las relaciones polomórficas como las que se
establecen entre distintos modelos y un modelo común. El modelo común sería como
una cualidad que comparten los diferentes modelos. Estos son distintos pero van
a presentar un comportamiento, una capacidad, una cualidad, un aspecto similar.

Cierto que es algo dificil de entender con la mera definición, así que vamos a
apoyarla con un ejemplo lo más simple posible, que nos permita entenderlo.

Pensemos en la siguiente situación. Desarrollamos una aplicación que va a
contemplar, entre otros modelos, usuarios y stands (esos que te encuentas en los
congresos, eventos, …).

No es dificil imaginar que podemos necesitar que la aplicación contemple la
posibilidad de añadir a un usuario una imagen (su foto por ejemplo, a modo de
avatar). Y tampoco es dificil imaginar que tendremos que contemplar la
posibilidad de añadir alguna imagen o imagenes de cada stand.

Pues bien, recordando la definición inicial, los modelos diferentes serían los
usuarios y los stands. Y el modelo común, esa cualidad similar de ambos, sería
la posiblidad de contemplar una o más imágenes.

Por tanto, voy a necesitar almacenar las imagenes de usuarios y stands en el
sistema de ficheros del servidor donde esté alojada la aplicación. Y necesitaré
igualmente tablas en base de datos para relacionar imágenes con sus
‘propietarios’ ya sean usuarios o stands.

Nuestro primer boceto de estructura sería el siguiente:

usuarios:
id
nombre
apellidos
email

usuarios_imagenes:
id
idusuario
descripcion
archivo

stands:
id
titulo
dimensiones

stands_imagenes:
id
idstand
descripcion
archivo

Vemos que las estructuras necesarias para las imágenes son iguales salvo que
apuntan a diferentes modelos. ¿Qué pasaría si tuviera más modelos en mi
aplicación con la necesidad de asociarles imágenes? Necesitaríamos una
estructura de imágenes para cada modelo?

Todo este comportamiento común (tener imagenes asociadas) e infraestructura en
servidor y base de datos, debe hacernos pensar en un principio que debe estar
siempre presente en el desarrollo, la reutilización.

Relaciones polimórficas al rescate
==================================

Las relaciones polimórficas nos permiten implementar ese comportamiento común
(la capacidad de tener asociadas imágenes) una vez y reutilizar todo para todos
los modelos que tengan ese comportamiento.

Esta sería nuestra estructura con relaciones polimórficas:

usuarios:
id
nombre
apellidos
email

stands:
id
titulo
dimensiones

imagenes:
id
modelo_id
modelo_type
descripcion
archivo

Ahora en vez de tener una estructura de datos específica para almacenar las
imágenes por cada modelo, tenemos una sola. En esta única estructura indicamos,
el identificador del propietario de la imagen y también el tipo, o sea, el
modelo. El campo modelo_id contemplará el identificador del usuario o stand,
mientras que el campo modelo_type determinará el modelo propietario de la
imagen.

Por lo tanto:

Un usuario podrá tener imágenes asociadas

Un stand podrá tener imágenes asociadas

Una imágen podrá pertenecer a un usuario o un stand.

Implementación en Laravel
=========================

Aclarar que existen tres tipos de relaciones polimóificas: uno a uno, uno a
muchos y muchos a muchos. En la documentación oficial de Laravel podrás
encontrar ejemplo de cada uno, pero aquí nos estamos centrando en la relación
uno a muchos (un usuario/stand puede tener varias imágenes y una imagen
pertenece a sólo un usuario/stand).

Migraciones
===========

Schema::create('imagenes', function (Blueprint $table) {
    $table->id();
    $table->unsignedBigInteger('modelo_id');
    $table->string('modelo_type');
    $table->longText('descripcion')->nullable();
    $table->string('archivo');
});

Schema::create('usuarios', function (Blueprint $table) {
    $table->id();
    $table->string('nombre');
    $table->string('apellidos');
    $table->string('email');
});

Schema::create('stands', function (Blueprint $table) {
    $table->id();
    $table->string('titulo');
    $table->string('dimensinoes');
});

Modelos

// app/Usuario.php

<?php

namespace App;
use Illuminate\Database\Eloquent\Model; 

class Usuario extends Model {
    /**
    * Devuelve todas las imagenes del usuario.
    */
    public function imagenes() {
        return $this->morphMany('App\Imagen', 'modelo');
    }
}

// app/Stand.php

<?php

namespace App;
use Illuminate\Database\Eloquent\Model; 

class Stand extends Model {
    /**
    * Devuelve todas las imagenes del stand.
    */
    public function imagenes() {
        return $this->morphMany('App\Imagen', 'modelo');
    }
}

// app/Imagen.php

<?php

namespace App;
use Illuminate\Database\Eloquent\Model; 

class Imagen extends Model {
    /**
    * Devuelve el modelo propietario de la imagen
    */
    public function modelo() {
        return $this->morphTo();
    }
}

Tanto el modelo usuario como el modelo stand tendrán el método imagenes, que
devuelve las imágenes asociadas al usaurio o stand.

El método hace uso de morphMany al que se le indica el modelo común (App\Imagen)
así como una cadena de texto que Laravel necesita para determinar cuáles son los
campos en la estructura que relacionan las imágenes con sus propietarios.
Indicando ‘modelo’, Laravel sabrá que estos campos son ‘modelo_id’ y
‘modelo_type’.

En una relación uno a uno, en vez de morphMany utilizariamos el método morphTo.
Para más información consulta la documentación oficial de Laravel.

Por su parte en el modelo Imagen se contempla el método modelo, que retornará el
modelo propietario de la imagen simplemente llamando al método morphTo.

Conclusión
==========

Cada vez que intuyamos un comportamiento común entre distintos modelos podremos
analizar la posiblidad de resolverlos con relaciones polimórficas.

Por ejemplo:

Comentar posts, videos, imágenes, … (son todos comentables)

Asociar documentos una solicitud, a un presupuesto, a una factura, …

Guardar un registro de la evolución o progreso de un proyecto, de un evento, un
video, …

Evaluar un examen, un trabajo, una tesis, … (son todos evaluables)

Fuente
======

https://virtumedia.wordpress.com/2020/04/10/relaciones-polimorficas-en-laravel/

==============
$table->morphs
==============

En Laravel, el método $table->morphs('XXX') es un atajo (shortcut) que crea dos
columnas en la tabla de la base de datos para soportar una relación polimórfica.

Estas columnas son:

XXX_id: Un campo de tipo unsignedBigInteger que almacena el ID del modelo
relacionado.

XXX_type: Un campo de tipo string que almacena el nombre de la clase del modelo
relacionado.

¿Para qué sirve?

Este método se utiliza cuando una tabla necesita estar relacionada con múltiples
modelos (tablas) de manera dinámica. Por ejemplo, si tienes una tabla comments
que puede estar asociada tanto a posts como a videos, usarías una relación
polimórfica.

Ejemplo de uso:

Supongamos que tienes una tabla images que puede estar asociada tanto a users
como a products. La migración podría verse así:

Schema::create('images', function (Blueprint $table) {
    $table->id();
    $table->string('url');
    $table->morphs('imageable'); // Esto crea imageable_id y imageable_type
    $table->timestamps();
});

¿Qué hace exactamente morphs('XXX')?

Crea dos columnas:

XXX_id: Un campo de tipo unsignedBigInteger que almacena el ID del modelo
relacionado.

XXX_type: Un campo de tipo string que almacena el nombre de la clase del modelo
relacionado (por ejemplo, App\Models\User o App\Models\Product).

Ejemplo de datos:

Si una imagen está asociada a un User con ID 1, la tabla images tendría:

imageable_id = 1

imageable_type = 'App\Models\User'

Si una imagen está asociada a un Product con ID 5, la tabla images tendría:

imageable_id = 5

imageable_type = 'App\Models\Product'

Relación polimórfica en los modelos

En los modelos de Laravel, debes definir la relación polimórfica. Por ejemplo:

En el modelo Image:

class Image extends Model
{
    public function imageable()
    {
        return $this->morphTo();
    }
}

En el modelo User:

class User extends Model
{
    public function images()
    {
        return $this->morphMany(Image::class, 'imageable');
    }
}

En el modelo Product:

class Product extends Model
{
    public function images()
    {
        return $this->morphMany(Image::class, 'imageable');
    }
}

¿Cómo se usa en la práctica?:

Guardar una imagen para un usuario:

$user = User::find(1);
$user->images()->create(['url' => 'path/to/image.jpg']);

Guardar una imagen para un producto:

$product = Product::find(5);
$product->images()->create(['url' => 'path/to/image.jpg']);

Obtener las imágenes de un usuario o producto:

$user = User::find(1);
$images = $user->images; // Devuelve todas las imágenes asociadas al usuario

Resumen

$table->morphs('XXX') crea dos columnas: XXX_id y XXX_type.

Se utiliza para relaciones polimórficas, donde una tabla puede estar asociada a
múltiples modelos.

En los modelos, se define la relación usando morphTo() y morphMany().

Fuente
======

Deepseek

======================
Procesamiento de colas
======================

En Laravel, el procesamiento de colas es una forma de ejecutar tareas en segundo
plano de manera asíncrona. Permite separar el procesamiento de tareas largas o
intensivas en recursos de la respuesta inmediata a una solicitud del usuario.

El procesamiento de colas se basa en la idea de enviar trabajos (jobs) a una
cola, donde están esperando a ser procesados. Estos trabajos pueden ser tareas
como enviar correos electrónicos, generar informes, procesar imágenes, realizar
cálculos intensivos, entre otros.

En lugar de realizar estas tareas directamente en el momento en que se
solicitan, se encolan en una cola de tareas. Luego, un proceso de trabajador
(worker) se encarga de tomar los trabajos de la cola y procesarlos en segundo
plano.

Al utilizar colas, se pueden obtener varios beneficios:

1- Mejora de la velocidad de respuesta: Al enviar tareas a la cola, se libera el
proceso principal de la aplicación para manejar más solicitudes, lo que resulta
en una respuesta más rápida al usuario.

2- Procesamiento asíncrono: Las tareas en la cola se procesan en segundo plano,
lo que permite al usuario continuar interactuando con la aplicación sin tener
que esperar a que las tareas se completen.

3- Control del flujo de trabajo: Puedes priorizar, reintentar o programar la
ejecución de trabajos en la cola según tus necesidades. Esto proporciona
flexibilidad para manejar diferentes escenarios y optimizar el rendimiento de la
aplicación.

Laravel proporciona un sistema de colas integrado que utiliza una variedad de
controladores de cola, como Redis, base de datos, Amazon SQS, entre otros.
Puedes configurar el controlador de cola deseado en el archivo de configuración
queue.php y definir las tareas de trabajo en clases de trabajos (job classes).

Luego, puedes iniciar uno o más procesos de trabajador utilizando el comando de
php artisan queue:work. Estos trabajadores estarán pendientes de la cola y
procesarán los trabajos según el controlador de cola configurado.

En resumen, el procesamiento de colas en Laravel te permite realizar tareas en
segundo plano de manera eficiente, mejorando el rendimiento y la capacidad de
respuesta de tu aplicación.

Monitoreo de trabajos fallidos
==============================

Escenario: Supongamos que tengo un controlador encargado de guardar los datos
enviados por un formulario, y delegué a un worker el trabajo de enviar una
notificación por correo, entonces, que pasaría si se guardan los datos del
formulario pero por alguna razón el worker falla porque se cayó la conexión a
internet en ese momento y la notificación nunca le llegó al usuario.

Respuesta: Si en el escenario que planteas el controlador guarda los datos del
formulario exitosamente, pero el worker encargado de enviar la notificación por
correo falla debido a una caída de la conexión a Internet, la notificación no se
enviará y el usuario no recibirá el correo.

Este tipo de situaciones pueden ocurrir cuando se trabaja con colas y
procesamiento en segundo plano. Si el worker no puede completar su tarea debido
a un error o una interrupción en la conexión, es importante tener en cuenta cómo
se manejarán esos casos.

En Laravel, hay diferentes enfoques para manejar estas situaciones:

-Retries (reintentos): Puedes configurar el worker para que intente nuevamente
el trabajo en caso de que falle. Por ejemplo, puedes establecer un número máximo
de reintentos y un intervalo de espera entre cada intento. Esto permitiría que
el worker vuelva a intentar enviar la notificación cuando la conexión a Internet
se restablezca.

-Fallos en la cola: Laravel proporciona una funcionalidad llamada "failed jobs"
(trabajos fallidos) que permite capturar y registrar los trabajos que no se
pudieron procesar correctamente. Puedes configurar el sistema para almacenar
estos trabajos fallidos en una tabla de base de datos o enviar notificaciones
por correo electrónico cuando ocurran errores.

-Supervisión y monitoreo: Es recomendable utilizar herramientas de supervisión y
monitoreo para verificar el estado de los trabajadores y las colas. Puedes
utilizar herramientas como Horizon (una interfaz de administración para colas) y
herramientas de monitoreo de aplicaciones para asegurarte de que los
trabajadores estén funcionando correctamente y detectar cualquier problema o
error en tiempo real.

Además, es importante diseñar adecuadamente tus tareas de trabajo y manejar
situaciones de errores o fallas de manera adecuada. Puedes implementar lógica en
tus trabajos para manejar escenarios de excepciones y notificar o registrar los
errores para su posterior revisión y solución.

En resumen, si un worker falla debido a una caída de la conexión a Internet
mientras se procesa una tarea en segundo plano, es importante configurar
reintentos, manejar los trabajos fallidos y utilizar herramientas de supervisión
y monitoreo para garantizar el correcto funcionamiento del sistema y mitigar
problemas en tiempo real.

Crear una clase de trabajo (job class)
======================================

Puedes utilizar el comando Artisan para generar la clase de trabajo:

$ php artisan make:job SendNotificationJob

Esto creará una clase SendNotificationJob en el directorio app/Jobs.

El contenido por defecto será:

-----

<?php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldBeUnique;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class SendNotificationJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    /**
     * Create a new job instance.
     *
     * @return void
     */
    public function __construct()
    {
        //
    }

    /**
     * Execute the job.
     *
     * @return void
     */
    public function handle()
    {
        //
    }
}

-----

En el método handle es donde se debe realizar la lógica del trabajo, como
guardar algo en la base de datos o enviar una notificación de correo, etc.

Luego, en el controlador donde queremos ejecutar el trabajo podemos agregar
esto:

SendNotificationJob::dispatch($data);

Donde $data puede ser información que necesitamos recibir en nuestra clase
trabajo para ser procesada.

Configurar .env
===============

Tambien debemos agregar la siguiente variable en el archivo .env

QUEUE_CONNECTION=database

Crear tabla para los trabajos
=============================

Ejecuta el siguiente comando para generar la migración:

$ php artisan queue:table

Después de ejecutar el comando anterior, se generará una migración en el
directorio database/migrations.

Ejecuta el siguiente comando para ejecutar la migración y crear la tabla "jobs":

$ php artisan migrate

Una vez que hayas ejecutado la migración, la tabla "jobs" debería estar
disponible en tu base de datos y podrás utilizar las colas de trabajo
correctamente.

Ejecución del trabajo
=====================

Ejecutamos el siguiente comando en la consola:


$ php artisan queue:work

Si usamos el controlador que llama a la job class creada y se ejecuta
correctamente debemos ver en la consola la ejecución, tal como esta salida:

[2023-05-22 17:15:18][1] Processing: App\Jobs\SendNotificationJob
[2023-05-22 17:15:21][1] Processed:  App\Jobs\SendNotificationJob

La tabla jobs en la base de datos
=================================

Si estás utilizando Laravel y el procesamiento de colas con la tabla jobs, es
normal que inicialmente no se muestren registros en esa tabla. Esto se debe a
que los trabajos encolados se procesan y eliminan de la tabla automáticamente
una vez que han sido completados.

Cuando encolas un trabajo mediante el uso de Laravel's dispatch o dispatchNow,
el trabajo se agrega a la tabla jobs con la información necesaria para su
procesamiento. Una vez que el trabajo es tomado por un worker de la cola y se
completa su ejecución, Laravel lo eliminará automáticamente de la tabla jobs.

Si estás ejecutando trabajos en segundo plano con colas y no ves registros en la
tabla jobs, significa que los trabajos están siendo procesados de manera
eficiente y eliminados correctamente una vez que se completan.

Sin embargo, si deseas conservar los registros de los trabajos en la tabla jobs
incluso después de que se completen, puedes configurar tu archivo de
configuración de colas (config/queue.php) y establecer el valor de
'database' => 'jobs' en true. Esto permitirá que los trabajos se almacenen en la
tabla jobs incluso después de que se completen. Ten en cuenta que esto podría
ocupar espacio en tu base de datos con el tiempo, por lo que es importante
administrar adecuadamente esos registros si decides habilitar esta opción.

En resumen, si los trabajos se están ejecutando correctamente y no ves
registros en la tabla jobs, significa que los trabajos están siendo procesados y
eliminados correctamente una vez que se completan.

QUEUE_CONNECTION=sync o QUEUE_CONNECTION=database
=================================================

La diferencia entre QUEUE_CONNECTION=sync y QUEUE_CONNECTION=database en el
archivo de configuración de Laravel está relacionada con el tipo de conexión que
se utilizará para procesar las colas de trabajos.

QUEUE_CONNECTION=sync: Cuando utilizas esta configuración, Laravel procesará las
colas de trabajos de forma sincrónica, lo que significa que los trabajos se
ejecutarán inmediatamente en el mismo hilo de ejecución en el que se encolan. En
otras palabras, los trabajos se ejecutarán de manera secuencial y bloquearán la
ejecución de otros trabajos o tareas hasta que se completen. Esta opción es útil
durante el desarrollo o en casos en los que no necesitas diferir la ejecución de
los trabajos a un proceso en segundo plano.

QUEUE_CONNECTION=database: Con esta configuración, Laravel utiliza la base de
datos para almacenar los trabajos encolados y procesarlos en segundo plano. Los
trabajos se almacenan en la tabla jobs de la base de datos y son procesados por
un worker de la cola de trabajos en un proceso separado. Este enfoque permite
diferir la ejecución de los trabajos y liberar el hilo de ejecución principal
para atender otras solicitudes. El procesamiento de los trabajos en la cola se
realiza de manera asíncrona y en segundo plano.

En resumen, QUEUE_CONNECTION=sync ejecuta los trabajos de forma sincrónica en el
hilo de ejecución actual, mientras que QUEUE_CONNECTION=database almacena los
trabajos en una tabla de la base de datos y los procesa en segundo plano
mediante un worker de la cola. La elección entre estas configuraciones depende
de tus necesidades y de si deseas ejecutar los trabajos de forma inmediata o en
segundo plano para liberar el hilo principal de ejecución.

Fuente
======

ChatGPT

========================================================================
Correr 2 proyectos de laravel a la vez con diferentes versiones a la vez
========================================================================

1- El proyecto A que usa php 7.4 el cual está configurado por defecto, al
ejecutar php -v muestra que por defecto es la 7.4 la que está configurada por
defecto, entonces ejecutamos:

$ php artisan serve

Starting Laravel development server started: http://127.0.0.1:8000

2- El proyecto B que usa php 8.1 el cual no está configurado por defecto, al
ejecutar php -v muestra que por defecto es la 7.4 la que está configurada por
defecto, entonces ejecutamos:

$ php8.1 artisan serve

Starting Laravel development server: http://127.0.0.1:8001

Nota; Deben estar instaladas ambas versiones de PHP

=====================
El archivo Helper.php
=====================

En Laravel, el archivo Helper.php ubicado en la carpeta /app/Helpers/ es un
archivo que puedes utilizar para definir tus propias funciones de ayuda (helper
functions) personalizadas.

Las funciones de ayuda son funciones globales que se pueden utilizar en todo el
proyecto sin la necesidad de importar o incluir manualmente el archivo en cada
lugar donde se necesiten.

El archivo Helper.php es un lugar comúnmente utilizado para definir estas
funciones personalizadas que pueden ayudar a simplificar tareas comunes o
proporcionar funcionalidad adicional a tu aplicación Laravel.

Dentro del archivo Helper.php, puedes definir cualquier cantidad de funciones de
ayuda que desees, siguiendo la sintaxis de funciones de PHP normales. Estas
funciones pueden realizar cualquier operación o tarea que necesites y pueden ser
utilizadas en cualquier parte del proyecto.

Por ejemplo, podrías definir una función de ayuda para formatear una fecha de
manera específica, realizar cálculos matemáticos comunes, manipular cadenas de
texto, generar códigos aleatorios, entre muchas otras tareas útiles.

Una vez que hayas definido tus funciones en Helper.php, puedes utilizarlas en
tus controladores, modelos, vistas o cualquier otro lugar dentro de tu
aplicación Laravel sin la necesidad de importar o incluir manualmente el
archivo.

Recuerda que después de definir tus funciones personalizadas en Helper.php, es
posible que necesites ejecutar el comando composer dump-autoload en la terminal
para que Laravel cargue correctamente las nuevas funciones de ayuda definidas en
el archivo.

Fuente
======

ChatGPT

=====================================================================
Validar solo letras y no caracteres especiales en controlador Laravel
=====================================================================

Nota: Permite espacios

[
  'name' => [
      'required',
      'max:200',
      'unique:payroll_coordinations',
      'regex:/^[a-zA-Z\s]+$/',
  ],
  'description' => [
      'nullable',
      'max:200'
  ],
  'department_id' => ['required'],
],
[
  'department_id.required' => 'El campo departamento de adscripción es obligatorio.',
  'name.regex' => 'El campo nombre no debe contener caracteres especiales.',
]

=====================================================================
Validar solo letras, no números, permite acentos y espacios en blanco
=====================================================================

'name' => [
    'required',
    'max:200',
    'unique:payroll_coordinations',
    'regex:/^[a-zA-ZáéíóúÁÉÍÓÚüÜ\s]+$/u'
],

==========================
constrained() en migración
==========================

En el contexto de una migración de Laravel, "constrained" se refiere a la
restricción de clave externa que se aplica a un campo de una tabla, lo que
significa que el valor en ese campo debe existir en otra tabla como clave
primaria.

Ejemplo:

Supongamos que tienes dos tablas en tu base de datos: 'users' y 'posts'. En la
tabla 'posts', tienes un campo llamado 'user_id' que se utiliza para almacenar
el ID del usuario que creó el post.

Si deseas aplicar una restricción de clave externa en el campo 'user_id' de la
tabla 'posts', puedes utilizar el método `constrained()` en Laravel. Esto
garantizará que el valor en el campo 'user_id' exista como una clave primaria en
la tabla 'users'.

Aquí está un ejemplo de cómo se vería en código:

```php
Schema::table('posts', function (Blueprint $table) {
    $table->foreign('user_id')
          ->references('id')
          ->on('users')
          ->constrained();
});
```

Con esto, Laravel creará automáticamente la restricción de clave externa en la
columna 'user_id' de la tabla 'posts', asegurando que solo se puedan agregar
valores que existan como claves primarias en la tabla 'users'.

Fuente
======

LuzIA Telegram Bot

===========================
Tabla intermedia en Laravel
===========================

Ejemplo sencillo de cómo usar una tabla intermedia en Laravel.

Imaginemos que estás construyendo una aplicación para administrar cursos y
estudiantes. Tendrás dos modelos: Course (Curso) y Student (Estudiante), y
necesitarás una tabla intermedia llamada course_student para gestionar la
relación muchos a muchos entre cursos y estudiantes.

Paso a paso, aquí tienes cómo puedes configurar esto:

Crear las migraciones:

Primero, crea las migraciones para las tablas courses y students:

$ php artisan make:migration create_courses_table

$ php artisan make:migration create_students_table

Luego, modifica las migraciones para agregar los campos necesarios:

// Migración para la tabla "courses"
public function up()
{
    Schema::create('courses', function (Blueprint $table) {
        $table->id();
        $table->string('title');
        $table->timestamps();
    });
}

// Migración para la tabla "students"
public function up()
{
    Schema::create('students', function (Blueprint $table) {
        $table->id();
        $table->string('name');
        $table->timestamps();
    });
}

Crear la migración para la tabla intermedia:

Nota: por convención las tablas intermedias, sus modelos deben ir en singular
y por orden alfabético.

$ php artisan make:migration create_course_student_table

Modifica la migración para agregar los campos de relación:

// Migración para la tabla intermedia "course_student"
public function up()
{
    Schema::create('course_student', function (Blueprint $table) {
        $table->id();
        $table->unsignedBigInteger('course_id');
        $table->unsignedBigInteger('student_id');
        $table->timestamps();
        $table->foreign('course_id')->references('id')->on('courses')->onDelete('cascade');
        $table->foreign('student_id')->references('id')->on('students')->onDelete('cascade');
    });
}

o esta versión más compacta:

public function up()
{
    Schema::create('course_student', function (Blueprint $table) {
        $table->id();
        $table->foreignId('course_id')
                ->constrained('courses')
                ->onUpdate('cascade')
                ->onDelete('restrict')
                ->nullable();
        $table->foreignId('student_id')
            ->constrained('students')
            ->onUpdate('cascade')
            ->onDelete('restrict')
            ->nullable();
        $table->timestamp('created_at')->useCurrent();
        $table->timestamp('updated_at')->nullable();
    });
}

Definir las relaciones en los modelos:

En el modelo Course, define la relación muchos a muchos con el modelo Student:

class Course extends Model
{
    public function students()
    {
        return $this->belongsToMany(Student::class);
    }
}

Y en el modelo Student, define la relación inversa:

class Student extends Model
{
    public function courses()
    {
        return $this->belongsToMany(Course::class);
    }
}

Utilizar las relaciones:

Ahora puedes utilizar las relaciones en tu código:

// Obtener todos los estudiantes de un curso
$course = Course::find(1);
$students = $course->students;

// Obtener todos los cursos de un estudiante
$student = Student::find(1);
$courses = $student->courses;

Con este ejemplo, podrás entender cómo funciona una relación muchos a muchos con
una tabla intermedia en Laravel.

Ejemplo de como se manejas los datos en esas tablas:

Imagina que tienes dos conjuntos de datos, digamos "A" y "B", y deseas
establecer una relación muchos a muchos entre ellos. Esto significa que un
elemento del conjunto "A" puede estar relacionado con varios elementos del
conjunto "B", y viceversa.

Sin embargo, para almacenar esta relación en una base de datos relacional,
necesitas una forma de vincular los elementos de "A" con los elementos de "B".
Aquí es donde entra en juego la tabla intermedia.

La tabla intermedia es una tabla adicional que se crea para mantener un registro
de las conexiones entre los elementos de "A" y "B". Esta tabla contiene, al
menos, dos columnas: una que corresponde a los elementos de "A" y otra que
corresponde a los elementos de "B". Estas columnas actúan como claves foráneas
que hacen referencia a las tablas originales de los conjuntos "A" y "B".

Cuando deseas establecer una relación entre un elemento específico de "A" y uno
o más elementos de "B", insertas registros en la tabla intermedia. Cada registro
indicará que un elemento de "A" está relacionado con uno de "B". Así, a medida
que agregas registros a la tabla intermedia, estás construyendo las relaciones
entre los conjuntos "A" y "B".

Por ejemplo, si "A" son estudiantes y "B" son cursos, la tabla intermedia podría
llamarse "course_student" y contendría registros que indican qué estudiantes
están inscritos en qué cursos.

Esta tabla intermedia no se llena automáticamente con datos; más bien, se llena
a medida que estableces relaciones entre los elementos de "A" y "B". Es
utilizada principalmente para consultas y para mantener la integridad
referencial en la base de datos, asegurando que las relaciones entre los
conjuntos se mantengan correctamente.

En resumen, las tablas intermedias son esenciales en las relaciones muchos a
muchos para registrar y gestionar las conexiones entre conjuntos de datos
diferentes.

Fuente
======

Ejemplo completo de tabla intermedia entre cursos y estudiantes en:
https://github.com/argenisosorio/laravel_8_crud/tree/prueba_tabla_intermedia

===========================
El método attach en Laravel
===========================

El método attach en Laravel se utiliza para establecer relaciones de muchos a
muchos entre modelos a través de una tabla intermedia. En el contexto de tu
aplicación (https://github.com/argenisosorio/laravel_8_crud/tree/prueba_tabla_intermedia)
de administración de cursos y estudiantes, se utiliza para relacionar
estudiantes con cursos seleccionados.

En tu caso específico, tienes una relación muchos a muchos entre los modelos
Student y Course, y la tabla intermedia se llama course_student. El método
attach se utiliza para agregar registros a esta tabla intermedia y establecer
la relación entre un estudiante y uno o varios cursos.

La sintaxis básica del método attach es la siguiente:

$student->courses()->attach($courseIds);

Donde:

$student es una instancia del modelo Student.

courses() es el método de relación definido en el modelo Student que representa
la relación muchos a muchos con cursos.

attach($courseIds) es el método que se utiliza para establecer la relación.
$courseIds es un array de IDs de cursos que deseas relacionar con el estudiante.

En tu código, dentro del método store, utilizas el método attach para
relacionar el estudiante recién creado con los cursos seleccionados a través del
campo 'selected_courses' del formulario.

if ($request->has('selected_courses')) {
    $student->courses()->attach($request->input('selected_courses'));
}

Este código toma los IDs de los cursos seleccionados del formulario (contenidos
en el campo 'selected_courses') y establece las relaciones correspondientes en
la tabla intermedia course_student. Esto permite que puedas asociar múltiples
cursos con un estudiante específico.

En resumen, el método attach es una forma de establecer relaciones de muchos a
muchos en Laravel, agregando registros a una tabla intermedia que conecta dos
modelos.

Fuentes
=======

ChatGPT
https://github.com/argenisosorio/laravel_8_crud/tree/prueba_tabla_intermedia

===================
La función toBase()
===================

La función toBase() en una consulta de Laravel convierte la consulta a una
instancia de la clase BaseQuery. Se utiliza para obtener una consulta base sin
restricciones adicionales. El beneficio es que te permite manipular y
personalizar la consulta de manera más flexible. Por ejemplo, puedes usar
toBase() para realizar operaciones adicionales antes de ejecutar la consulta
final.

Ejemplo:

Supongamos que tienes una tabla llamada usuarios y deseas realizar una consulta
simple para obtener todos los usuarios cuyas edades son mayores de 25 años.

Sin toBase():

$usuarios = DB::table('usuarios')->where('edad', '>', 25)->get();

En este caso, estamos utilizando la fachada DB de Laravel para construir una
consulta directamente en la tabla "usuarios" y aplicando una restricción donde
la edad es mayor que 25.

Con toBase():

$consulta = DB::table('usuarios')->where('edad', '>', 25);

$baseConsulta = $consulta->toBase();

$resultado = $baseConsulta->get();

Aquí, en lugar de ejecutar get() en la consulta original, primero almacenamos la
consulta en la variable $consulta. Luego, usamos el método toBase() para
convertirla en una instancia de BaseQuery, que es más flexible y nos permite
realizar operaciones adicionales antes de ejecutar la consulta final.

Por ejemplo, podríamos agregar más condiciones o personalizaciones a la consulta
$consulta antes de llamar a get() en la instancia $baseConsulta. Esto puede ser
útil en situaciones donde necesitas construir la consulta de manera dinámica o
aplicar operaciones adicionales antes de recuperar los resultados finales.

En resumen, toBase() te permite manipular y personalizar una consulta de manera
más flexible antes de ejecutarla, lo que puede ser útil en escenarios donde
necesitas realizar acciones adicionales en la consulta antes de obtener los
resultados.

Fuentes
=======

LuzIA
ChatGPT

============
QueryBuilder
============

Una QueryBuilder es una herramienta o biblioteca que se utiliza en muchos
frameworks y lenguajes de programación para construir consultas de bases de
datos de una manera más programática y orientada a objetos. Su principal
objetivo es permitir a los desarrolladores crear consultas SQL de forma
dinámica y flexible utilizando código en lugar de escribir directamente SQL
estático.

Las QueryBuilders suelen ofrecer una interfaz en la que los desarrolladores
pueden encadenar métodos y funciones para construir gradualmente una consulta
SQL. Esto facilita la construcción de consultas complejas y dinámicas sin tener
que concatenar manualmente cadenas SQL o preocuparse por la seguridad contra la
inyección de SQL.

Algunas de las características y ventajas de las QueryBuilders incluyen:

-Legibilidad y mantenibilidad del código: Las QueryBuilders permiten construir
consultas de manera más legible y estructurada, ya que las consultas se crean
como código fuente en lugar de cadenas SQL.

-Seguridad contra la inyección de SQL: Las QueryBuilders suelen manejar
automáticamente la sanitización de datos, lo que ayuda a prevenir ataques de
inyección de SQL.

-Portabilidad: Puedes utilizar la misma sintaxis de QueryBuilder para construir
consultas en diferentes sistemas de gestión de bases de datos (por ejemplo,
MySQL, PostgreSQL, SQLite, etc.), lo que hace que tu código sea más portable.

-Compatibilidad con múltiples lenguajes: Las QueryBuilders suelen estar
disponibles en varios lenguajes de programación, lo que facilita la construcción
de consultas en el lenguaje que estés utilizando.

Fuente
======

ChatGPT

===================
php artisan db:wipe
===================

El comando php artisan db:wipe en Laravel se utiliza para eliminar todas las
tablas de la base de datos registrada en tu archivo de configuración de Laravel.

Este comando es útil en situaciones en las que deseas limpiar completamente la
base de datos, eliminando todas las tablas y sus datos.

Cuando ejecutas php artisan db:wipe, Laravel ejecutará una serie de operaciones
para eliminar todas las tablas de la base de datos actual y, por lo tanto,
eliminar todos los datos almacenados en esas tablas. Este comando puede ser útil
en situaciones como la limpieza de una base de datos de prueba antes de volver a
ejecutar pruebas o restablecer una base de datos en un entorno de desarrollo.

======
Fuente
======

ChatGPT

=================================
Observer" (observador) en Laravel
=================================

Un "Observer" (observador) en Laravel es una clase que te permite observar y
responder a eventos que ocurren en los modelos de tu aplicación. Los
observadores son una forma poderosa de centralizar la lógica relacionada con los
eventos del modelo y mantener tu código más limpio y organizado.

Los observadores se utilizan principalmente para automatizar tareas comunes o
realizar acciones adicionales cuando ocurren eventos en los modelos. Algunos
ejemplos de eventos que puedes observar en un modelo incluyen:

Creación de un registro: Puedes observar el evento created que se dispara cuando
se crea un nuevo registro en la base de datos. Por ejemplo, puedes enviar un
correo electrónico de bienvenida a un usuario cuando se registre.

Actualización de un registro: Puedes observar el evento updated que se dispara
cuando un registro se actualiza. Esto es útil para realizar seguimientos de
cambios o ejecutar acciones cuando ciertos campos se actualizan.

Eliminación de un registro: Puedes observar el evento deleted que se dispara
cuando se elimina un registro. Esto es útil para realizar acciones de limpieza o
archivar datos antes de eliminarlos.

Restauración de un registro: Si estás utilizando "soft deletes" y restauras un
registro eliminado, puedes observar el evento restored para realizar acciones
cuando se restaura un registro.

Para crear un observador en Laravel, normalmente sigues estos pasos:

Genera un nuevo observador usando el comando Artisan:

$ php artisan make:observer NombreDelObservador

En el observador recién creado, puedes definir métodos que correspondan a los
eventos que deseas observar (por ejemplo, created, updated, deleted, restored,
etc.). Dentro de estos métodos, puedes escribir la lógica que deseas ejecutar
cuando se dispare el evento.

Registra el observador en el servicio EventServiceProvider de tu aplicación.
Esto se hace en el archivo EventServiceProvider.php en la propiedad $listen:

protected $listen = [
    'App\Events\ModelCreated' => [
        'App\Observers\NombreDelObservador',
    ],
];

Asocia el observador con el modelo correspondiente utilizando el método observe
en el modelo:

protected static function boot()
{
    parent::boot();
    static::observe(NombreDelObservador::class);
}

Una vez que hayas configurado un observador, cada vez que ocurra el evento en el
modelo, se llamará al método correspondiente en el observador, permitiéndote
realizar acciones específicas en respuesta a ese evento.

En resumen, los observadores en Laravel son una forma efectiva de separar la
lógica de los eventos del modelo, lo que hace que tu código sea más mantenible
y limpio al tiempo que permite automatizar tareas comunes.

======
Fuente
======

ChatGPT

====================
Método forceDelete()
====================

forceDelete() en Laravel. Este método se utiliza para eliminar permanentemente
un registro de la base de datos cuando estás utilizando el sistema de
eliminación suave (soft delete) de Laravel.

En Laravel, el sistema de eliminación suave te permite "eliminar" registros de
la base de datos sin eliminarlos realmente físicamente. En su lugar, se
establece una columna de marca de tiempo llamada deleted_at en el registro, lo
que indica que el registro ha sido eliminado lógicamente. Esto es útil para
mantener un historial de registros eliminados y permitir la posible restauración
de registros en el futuro.

Cuando deseas eliminar permanentemente un registro eliminado suavemente, es
decir, borrarlo de forma irreversible de la base de datos, puedes usar el
método forceDelete(). Aquí tienes un ejemplo de cómo se usa:

// Elimina permanentemente un registro eliminado suavemente por su ID
$model = Modelo::onlyTrashed()->find($id);
$model->forceDelete();

En este ejemplo, $model representa el modelo del registro que se ha eliminado
suavemente y forceDelete() se utiliza para eliminarlo permanentemente de la base
de datos. Ten en cuenta que esta operación es irreversible y no se puede
deshacer. Asegúrate de usar forceDelete() con precaución.

======
Fuente
======

ChatGPT

================================================================================
Convertir el nombre de una clase model de laravel en un nombre de campo de tabla
================================================================================

Ejemplo, Si deseas convertir el nombre de la clase $model "App\Models\City" en
"city_id", puedes hacerlo utilizando funciones de manipulación de cadenas en
PHP. Puedes seguir estos pasos:

Obtén el nombre de la clase del modelo.

Extrae el último segmento del nombre de la clase (en este caso, "City").

Agrega "_id" al final del segmento extraído.

Aquí tienes una función que realiza esta conversión:

static::deleting(function ($model) {
    // Obtén el nombre de la clase del modelo
    $class_name = get_class($model);

    // Divide el nombre de la clase en segmentos utilizando '\'
    $segments = explode('\\', $class_name);

    // Obtiene el último segmento (el nombre de la clase en sí)
    $class_name = end($segments);

    // Agrega "_id" al final del nombre de la clase
    $column_name = strtolower($class_name) . '_id';

    // Imprime el resultado
    dd($column_name);
});

Con este código, obtendrás "city_id" cuando dd($column_name) se ejecute con el
nombre de clase "App\Models\City". Puedes adaptar este código a tu evento de
eliminación en Laravel según tus necesidades específicas.

======
Fuente
======

ChatGPT

=====================
La variable APP_DEBUG
=====================

La variable APP_DEBUG en Laravel se utiliza para habilitar o deshabilitar el
modo de depuración en la aplicación. Cuando está habilitada (valor "true"), se
mostrarán mensajes de error detallados. Cuando está deshabilitada (valor
"false"), los mensajes de error serán más genéricos y no se mostrarán detalles
sensibles.

======
Fuente
======

LuzIA

===============
El método sum()
===============

Es un método proporcionado por el framework Laravel. No es un método nativo de
PHP.

En Laravel, sum() se utiliza para calcular la suma de los valores en una columna
específica de una tabla de base de datos. En este ejemplo,
Ages::sum('number_ages') calcula la suma de los valores en la columna
number_ages de la tabla Ages. Esto es útil cuando se necesita realizar
operaciones de agregación en una columna, como sumar, promediar, contar, etc.

En resumen, sum() es una función de consulta de Laravel que facilita la
realización de operaciones de suma en columnas de bases de datos, suma la
totalidad de los datos guardados en un campo de la base de datos tomando en
cuenta todos los registros.

======
Fuente
======

ChatGPT

=======================
Instalar y usar MailHog
=======================

MailHog permite atrapar el correo SMTP saliente, de modo que puedas ver el
contenido sin que email se envíe realmente. Cómo instalar MailHog en diversos
sistemas y usarlo para aplicaciones web PHP y proyectos Laravel.

Instalación en GNU/Linux Debian:

Nota: Probado en GNU/Linux Debian 11

1) Instalar el paquete golang desde los repositorios de Debian:

$ sudo apt install golang

2) Comprobar la correcta instalación:

$ go version

Mostrará algo como:

go version go1.15.15 linux/amd64

3) Obtener el software MailHog

$ go get github.com/mailhog/MailHog

Si este comando falla, por get esta deprecado, se debe ejecutar el siguiente:

$ go install github.com/mailhog/MailHog@latest

Esto creara la carpeta "go" en la caprpeta personal, dentro está el software.

4) Ejecutar MailHog

$ ~/go/bin/MailHog

2023/10/31 15:36:16 Using in-memory storage
2023/10/31 15:36:16 [SMTP] Binding to address: 0.0.0.0:1025
[HTTP] Binding to address: 0.0.0.0:8025
2023/10/31 15:36:16 Serving under http://0.0.0.0:8025/
Creating API v1 with WebPath:
Creating API v2 with WebPath:
[APIv2] GET /api/v2/jim
[APIv2] GET /api/v2/messages
[APIv2] GET /api/v2/websocket
[APIv1] KEEPALIVE /api/v1/events
[APIv1] KEEPALIVE /api/v1/events
[APIv1] KEEPALIVE /api/v1/events

Visitar http://127.0.0.1:8025/ verás la interfaz de MailHog.

4) Luego en la aplicación de Laravel, en el archivo .env configurar las
siguientes variables:

MAIL_DRIVER=smtp
MAIL_HOST=0.0.0.0
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_NAME="Pepe el pruebas"

Refrescar la caché de la configuración con:

$ php artisan optimize:clear

5) Listo, enviar cualquier email con la aplicación, por ejemplo el reseteo de
contraseña, este debería ser interceptado por MailHog y mostrado en su bandeja
de mensajes.

Extra
=====

luego de hacer todo esto, quedara creada la carpeta "go" en el home del usuario,
como esto puede ser molesto se puede cambiar el nombre de la carpeta "go" a
".go" esto hará que la carpeta quede oculta, se puede hacer con el siguiente
comando:

$ mv go .go

Y ahora para ejecutar MailHog se haría con el siguiente comando:

$ ~/.go/bin/MailHog

Fuentes
=======

https://desarrolloweb.com/articulos/instalar-mailhog-mac-php.html

https://github.com/mailhog/MailHog

https://styde.net/capturando-emails-de-forma-local-con-mailhog-y-laravel-homestead/

============
Método map()
============

En Laravel, el método map() se utiliza para transformar los elementos de una
colección, aplicando una función a cada elemento y creando una nueva colección
con los resultados de estas transformaciones. Es útil cuando deseas modificar
los datos de una colección sin cambiar la colección original. La función
proporcionada toma cada elemento de la colección como entrada y devuelve el
elemento transformado.

Ejemplo Práctico:

Supongamos que tienes una colección de objetos Product y deseas crear una nueva
colección que contenga los nombres de los productos en mayúsculas. Puedes
utilizar el método map() para lograr esto.

use Illuminate\Support\Collection;

// Crear una colección de objetos Product
$products = new Collection([
    ['name' => 'Producto 1', 'price' => 10],
    ['name' => 'Producto 2', 'price' => 20],
    ['name' => 'Producto 3', 'price' => 30],
]);

// Utilizar el método map() para transformar la colección
$upperCaseNames = $products->map(function ($product) {
    $product['name'] = strtoupper($product['name']);
    return $product;
});

// Imprimir la colección resultante
$upperCaseNames->each(function ($product) {
    echo "Nombre: " . $product['name'] . ", Precio: " . $product['price'] . "\n";
});

En este ejemplo, creamos una colección de objetos Product. Luego, utilizamos el
método map() para transformar cada elemento de la colección. La función de
callback toma cada producto, convierte el nombre a mayúsculas y devuelve el
producto modificado. La colección resultante $upperCaseNames contiene los
nombres de los productos en mayúsculas. Luego, imprimimos los nombres y precios
de los productos en mayúsculas utilizando el método each().

El resultado será:

Nombre: PRODUCTO 1, Precio: 10
Nombre: PRODUCTO 2, Precio: 20
Nombre: PRODUCTO 3, Precio: 30

Como puedes ver, el método map() se utiliza para transformar los elementos de la
colección sin modificar la colección original y crear una nueva colección con
los resultados transformados.

Fuente
======

ChatGPT

=================
Model::unguard();
=================

En Laravel, Model::unguard(); es un método que desactiva temporalmente la
protección de asignación masiva en los modelos de Eloquent. Esto permite que
puedas asignar valores a cualquier atributo del modelo sin necesidad de
definirlos en la propiedad $fillable o $guarded del modelo.

¿Qué es la protección de asignación masiva?
===========================================

Laravel, por defecto, protege contra la asignación masiva para evitar que los
usuarios malintencionados modifiquen atributos sensibles de un modelo a través
de formularios o solicitudes HTTP. Por ejemplo, si tienes un modelo User con un
atributo is_admin, no querrías que alguien pueda asignar is_admin = true desde
un formulario.

Para controlar qué atributos pueden ser asignados masivamente, Laravel usa dos
propiedades en los modelos:

$fillable: Define los atributos que sí pueden ser asignados masivamente.

$guarded: Define los atributos que no pueden ser asignados masivamente.

¿Qué hace Model::unguard();?
============================

Cuando llamas a Model::unguard();, desactivas temporalmente esta protección.
Esto significa que:

Puedes asignar valores a cualquier atributo del modelo, incluso si no está en
$fillable o está en $guarded.

Es útil en situaciones como seeders o tareas de desarrollo, donde necesitas
asignar datos masivamente sin preocuparte por las restricciones de asignación
masiva.

Fuente
======

Deepseek

===============
Logs en Laravel
===============

¿Qué son los logs?
==================

Registros de eventos de tu aplicación (errores, advertencias, información de
depuración). Laravel los guarda automáticamente cuando ocurren excepciones o
cuando tú los generas manualmente.

Ubicación de los Logs
=====================

storage/logs/laravel.log

storage/logs/laravel-YYYY-MM-DD.log  # Versiones anteriores

Logs por canal: Si usas canales como daily, se crean archivos por fecha:

storage/logs/laravel-2025-06-16.log

Cómo escribir en los Logs
=========================

Usa la facade Log en tus controladores, modelos o cualquier archivo:

use Illuminate\Support\Facades\Log;

// Ejemplos:
Log::emergency("Mensaje de emergencia");  // Nivel más crítico
Log::error("Error al procesar el pago", ['user_id' => 1]);
Log::warning("Alerta: espacio en disco bajo");
Log::info("Usuario registrado", ['email' => 'user@example.com']);
Log::debug("Variable X: " . json_encode($data));

Estos se pueden incluir en el controlador o donde haga falta para escribir en
los logs.

Cómo Leer/Probar los Logs
=========================

Opción 1: Ver el archivo directamente

$ less storage/logs/laravel.log

Opción 2: Usar Tinker (consola interactiva)

$ php artisan tinker

> file_get_contents(storage_path('logs/laravel.log'));

Opción 3: Ver el archivo con tail (Muestra poca información)

$ tail -f storage/logs/laravel.log

Fuente
======

Deepseek

===============================================================
Probar el envío correcto de correo desde una aplicación Laravel
===============================================================

Para probar el funcionamiento de las notificaciones por correo y la correcta
configuración en las variables descritas se recomienda ejecutar algunas
instrucciones en la consola de tinker para lo cual se debe ejecutar el comando:

$ php artisan tinker

Una vez ejecutado este comando se debe indicar la siguiente instrucción:

Mail::raw(
    'A través de este correo se esta probando las notificaciones del sistema',
    function($msg) {
        $msg->to('usuario@correo.com')->subject('Correo de prueba');
    }
);

Donde usuario@correo.com se debe sustituir por una dirección de correo
electrónico real para verificar que esten llegando las notificaciones y los
mensajes por correo.

Al ejecutar esta instrucción la consola de tinker arrojará 2 posibles resultados
el primero un valor null lo cual indica que la comunicación con el servidor de
correo electrónico ha sido satisfactoria, y el segundo posible resultado es un
mensaje de error el cual dará indicios de las posibles acciones a realizar para
corregir esto a nivel de comunicación entre el servidor en el que se encuentra
la aplicación y el servidor de correo.

Si en la consola de tinker se muestran algunos mensajes con la etiqueta
DEPRECATED se debe omitir esto ya que no afecta el funcionamiento de las
notificaciones y por lo general sucede en versiones de PHP >= 8.4

Ejemplo mejorado:

try {
    $result = Mail::raw(
        'A través de este correo se está probando las notificaciones del sistema KAVAC',
        function($msg) {
            $msg->to('user@mail.com')->subject('Correo de prueba');
        }
    );

    if ($result === null) {
        echo "\033[32m✔️ Correo enviado con éxito\033[0m\n";
        echo "Por favor verifica la bandeja de entrada (y spam) de user@mail.com\n";
    }
} catch (\Exception $e) {
    echo "\033[31m✖️ Error al enviar el correo:\033[0m\n";
    echo $e->getMessage() . "\n";
    echo "Revisa la configuración SMTP en tu archivo .env\n";
}

Fuentes
=======

README del KAVAC

DeepSeek

=============================================
Creación y ejecución de comandos en Laravel 8
=============================================

1. Crear un comando

Usar Artisan

$ php artisan make:command ChangePassword

Esto creará un archivo en: app/Console/Commands/ChangePassword.php

2. Editar el archivo app/Console/Commands/ChangePassword.php poniendo especial
atención en signature, descriptiony handle que es dond está la lógica que el
comando hará cuando sea ejecutado.

<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Models\User;

class ChangePassword extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'user:change-password';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Cambia la contraseña de un usuario específico';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return int
     */
    public function handle()
    {
        $user = User::find(1);
        if ($user) {
            $user->password = bcrypt('12345678');
            $user->save();
        }
        $this->info("¡Contraseña del usuario {$user->name} cambiada exitosamente!");
        return 0;
    }
}

3. Registrar el comando

En app/Console/Kernel.php, agregar el comando al array $commands:

protected $commands = [
    Commands\ChangePassword::class,
    // Otros comandos...
];

4. Ejecutar el comando

$ php artisan user:change-password

=============================
Programar tareas en Laravel 8
=============================

Puedes programar tareas (tareas recurrentes o "cron jobs") utilizando el
scheduler integrado del framework.

1. Definir tareas en App\Console\Kernel.php

Laravel usa el archivo Kernel.php (en app/Console) para configurar tareas
programadas.

protected function schedule(Schedule $schedule)
{
    // Ejecutar un comando Artisan diariamente
    $schedule->command('emails:send')->daily();

    // Ejecutar una closure cada hora
    $schedule->call(function () {
        DB::table('recent_users')->delete();
    })->hourly();

    // Ejecutar un script del sistema cada día a las 15:00
    $schedule->exec('node /path/to/script.js')->dailyAt('15:00');

    // Programar una tarea entre semana cada 5 minutos
    $schedule->job(new MyJob)->weekdays()->everyFiveMinutes();
}

// Ejecutar a horas exactas.
protected function schedule(Schedule $schedule)
{
    $schedule->command('aplicant:update-status')
        ->dailyAt('8:00')
        ->dailyAt('10:00')
        ->dailyAt('12:00')
        ->dailyAt('14:00')
        ->dailyAt('15:25');
}

Nota:

Hora exacta de ejecución:
daily() = 00:00 (medianoche)
dailyAt('11:30') = 11:30 AM (hora específica)

Alternativas a daily():

$schedule->command('comando')->hourly();      // Cada hora
$schedule->command('comando')->everyMinute(); // Cada minuto
$schedule->command('comando')->weekly();      // Cada semana (domingo 00:00)
$schedule->command('comando')->monthly();     // Cada mes (día 1, 00:00)
$schedule->command('comando')->quarterly();   // Cada trimestre
$schedule->command('comando')->yearly();      // Cada año (Enero 1, 00:00)

2. Registrar el scheduler en el cron del sistema

Agrega esta entrada al cron de tu servidor (usa crontab -e):

* * * * * cd /path-to-your-project && php artisan schedule:run

Esto ejecutará el comando schedule:run cada minuto.

3. Frecuencias disponibles

Laravel ofrece métodos intuitivos para programar tareas:
Método	Descripción
->everyMinute()	Cada minuto.
->everyFiveMinutes()	Cada 5 minutos.
->daily()	Una vez al día (medianoche).
->dailyAt('13:00')	Diariamente a una hora específica.
->twiceDaily(1, 13)	Dos veces al día (1:00 y 13:00).
->weekly()	Una vez por semana.
->monthly()	Una vez al mes.
->weekdays()	Solo días de semana (lunes-viernes).

4. Ejemplo de tareas personalizadas:

-Comandos Artisan: Crea comandos con php artisan make:command MyCommand y
programalos.

-Jobs: Usa $schedule->job(new MyJob)->daily() para despachar jobs.

-Scripts externos: Usa $schedule->exec() para ejecutar scripts.

5. Monitoreo y logs

-Agrega ->appendOutputTo('/path/log.txt') para guardar logs.

-Usa ->emailOutputTo('admin@example.com') para recibir notificaciones por
correo.

Ejemplo completo:

// En App\Console\Kernel.php
protected function schedule(Schedule $schedule)
{
    $schedule->command('users:cleanup')->dailyAt('03:00');
    $schedule->job(new ProcessPayments)->weeklyOn(1, '8:00'); // Todos los lunes a las 8:00
    $schedule->call(function () {
        // Tarea personalizada
    })->everySixHours();
}

Ejemplo más sencillo
====================

Tarea programada en Laravel 8 para actualizar la contraseña del usuario con id =
1 una vez al día a una hora específica 1 vez al día.

1- Crear un comando Artisan

Genera un comando personalizado para realizar la acción:

$ php artisan make:command ChangePassword

2- Definir la lógica en el comando

Edita el archivo app/Console/Commands/ChangePassword.php:

<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Models\User;

class ChangePassword extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'user:change-password';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Cambia la contraseña de un usuario específico';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return int
     */
    public function handle()
    {
        $user = User::find(1);
        if ($user) {
            $user->password = bcrypt('12345678');
            $user->save();
        }
        $this->info("¡Contraseña del usuario {$user->name} cambiada exitosamente!");
        return 0;
    }
}

3- Programar la tarea en App\Console\Kernel.php

Registra el comando para que se ejecute diariamente a una hora específica
(11:30am):

<?php

namespace App\Console;

use Illuminate\Console\Scheduling\Schedule;
use Illuminate\Foundation\Console\Kernel as ConsoleKernel;

class Kernel extends ConsoleKernel
{
    /**
     * The Artisan commands provided by your application.
     *
     * @var array
     */
    protected $commands = [
        Commands\ChangePassword::class,
    ];

    /**
     * Define the application's command schedule.
     *
     * @param  \Illuminate\Console\Scheduling\Schedule  $schedule
     * @return void
     */
    protected function schedule(Schedule $schedule)
    {
        // $schedule->command('inspire')->hourly();
        $schedule->command('user:change-password')->dailyAt('11:30');
    }

    /**
     * Register the commands for the application.
     *
     * @return void
     */
    protected function commands()
    {
        $this->load(__DIR__.'/Commands');

        require base_path('routes/console.php');
    }
}

// Tarea programada para que se ejecute 4 veces al día:
// a las 08:00am, 10:00am, 12:00am y 14:00pm o 02:00pm
$schedule->command('aplicant:update-status')->cron('0 8,10,12,14 * * *');

4- Configurar el cron del sistema

Asegúrate de que el scheduler de Laravel se ejecute en tu servidor en una hora
específica.

Agrega esto al cron (ejecuta crontab -e):

30 11 * * * cd /ruta/a/tu/proyecto && php artisan schedule:run

Explicación de la programación:

30 = Minuto 30 (11:30)

11 = Hora 11 (11 AM)

* = Todos los días del mes

* = Todos los meses

* = Todos los días de la semana

¿Qué significa esto?

-Se ejecutará exactamente a las 11:30AM todos los días

-Solo una vez al día.

Revisará el scheduler de Laravel y ejecutará cualquier tarea programada para las
11:30AM

Resultado:

-El comando user:change-passwordse ejecutará una vez al día (a la hora
especificada).

-Actualizará el password de usuario con id = 1.

¡Listo! Tu tarea programada quedará funcionando automáticamente.

Verificar el scheduler actual:

# Ver todos los comandos programados y sus próximas ejecuciones

$ php artisan schedule:list

# Ejemplo de output:
# 0 0 * * *  php artisan backup:run .......... Next due: today at 00:00
# 30 11 * * * php artisan user:change-password Next due: today at 11:30

Crontab vs Scheduler
====================

Quien se ejecuta primero crontab o scheduler? El que se va a ejecutar es el
crontab a las 11:30AM por ejemplo, pero un comando de laravel configurado como
$schedule->command('user:change-password')->daily(); NO se ejecutará a menos que
esté programado para esa hora en el scheduler de Laravel es decir a las 11:30AM.

Explico con un diagrama:

CRONTAB (11:30 AM) -> php artisan schedule:run -> LARAVEL SCHEDULER ->
Revisa qué comandos están programados para EJECUTARSE AHORA

Escenario actual:
1. Crontab (ejecuta a las 11:30 AM)

30 11 * * * cd /ruta/a/proyecto && php artisan schedule:run

Se ejecuta puntualmente a las 11:30 AM

2. Laravel Scheduler (en app/Console/Kernel.php)

$schedule->command('user:change-password')->daily();

-daily() = se ejecuta a medianoche (00:00)

-A las 11:30 AM, el scheduler dice: "Este comando no está programado para ahora"

Resultado: El comando NO se ejecutará a las 11:30 AM
Soluciones:

Opción 1: Cambiar el scheduler para que coincida con el crontab

// Para ejecutar a las 11:30 AM
$schedule->command('user:change-password')->dailyAt('11:30');

// O si quieres que sea a las 11:30 AM
$schedule->command('user:change-password')->at('11:30');

Opción 2: Mantener crontab minuto a minuto (recomendado)
bash

# Ejecutar cada minuto (mejor práctica)
* * * * * cd /ruta/a/proyecto && php artisan schedule:run

// Y en el scheduler defines la hora exacta
$schedule->command('user:change-password')->dailyAt('11:30');

¿Por qué la opción 2 es la mejor?

-El crontab ejecuta schedule:run cada minuto

-Laravel decide inteligentemente qué comandos ejecutar basado en su programación.

-Puedes tener múltiples comandos a diferentes horas sin modificar el crontab

Conclusión: El crontab solo dice "cuándo revisar", pero el scheduler de Laravel
decide "qué ejecutar". Para que tu comando se ejecute a las 11:30 AM, necesitas
que ambos estén coordinados.

Fuente
======

DeepSeek

==================================================
Impacto en el servidor del crontab minuto a minuto
==================================================

crontab minuto a minuto no genera carga significativa en el servidor. razones:

schedule:run es extremadamente ligero:

-Solo verifica la hora actual
-Consulta la lista de comandos programados
-Ejecuta SOLO los comandos que deben ejecutarse en ese minuto exacto
-Si no hay comandos programados para ese minuto, termina inmediatamente

El overhead es mínimo:

-Un proceso de PHP que dura milisegundos

-Consume muy pocos recursos de CPU y memoria

-Mucho más eficiente que tener múltiples entradas crontab

Es la práctica recomendada por Laravel:

-Los creadores de Laravel diseñaron así el sistema
-Es usado por miles de aplicaciones en producción
-Optimizado para este uso específico

Fuente
======

DeepSeek

====================================
Verificar hora del sistema y Laravel
====================================

1. Comandos directos en el servidor

Ver hora actual del sistema:

$ date

Hora con más detalle:

$ timedatectl status

# Hora en formato específico

$ date +"%Y-%m-%d %H:%M:%S"

# Zona horaria

$ cat /etc/timezone

Ver hora desde PHP/Laravel:

$ php artisan tinker
>>> echo date('Y-m-d H:i:s');
>>> echo config('app.timezone');

==================================================================
Que hacer si no coincide la hora del sistema con la de Laravel/PHP
==================================================================

$ date
sáb 30 ago 2025 11:56:39 -04

y

$ php artisan tinker
Psy Shell v0.11.11 (PHP 8.2.29 — cli) by Justin Hileman
> echo date('Y-m-d H:i:s');
2025-08-30 15:57:01⏎
>

Hay una discrepancia de horas

Resultados de la verificación:

Hora del sistema:

sáb 30 ago 2025 11:56:39 -04 (hora local, UTC-4)

Hora de Laravel/PHP:

2025-08-30 15:57:01 (UTC, 4 horas adelante)

Problema identificado: Diferente zona horaria

-El sistema está en UTC-4 (hora local)
-PHP/Laravel está usando UTC (hora universal)

Solución:

1. Verificar configuración actual de Laravel:

php artisan tinker

> echo config('app.timezone');

2. Corregir la zona horaria en Laravel:

Edita config/app.php:

'timezone' => 'America/Caracas', // Para UTC-4
// o
'timezone' => 'UTC', // Si quieres que coincida con UTC (y ajustar el sistema)

3. Zonas horarias comunes para UTC-4:

'America/Caracas'      // Venezuela
'America/La_Paz'       // Bolivia
'America/Santiago'     // Chile (en verano)
'America/Asuncion'     // Paraguay
'America/Cuiaba'       // Brasil (parte)
'America/Manaus'       // Brasil (parte)

4. Verificar después del cambio:

$ php artisan config:clear

$ php artisan tinker

> echo date('Y-m-d H:i:s');
> echo config('app.timezone');

# Verificar

$ date

¿Qué significa para tu scheduler?

Si no corriges esto:

-Tu comando programado para las 11:30 se ejecutará a las 15:30 hora local

-Porque Laravel piensa que son las 15:30 cuando el sistema dice 11:30

Comando rápido para verificar ambas zonas:

$ echo "Sistema: $(date) | Laravel: $(php artisan tinker --execute="echo date('Y-m-d H:i:s');") | Zona: $(php artisan tinker --execute="echo config('app.timezone');")"

Importante:

Después de cambiar config/app.php, ejecuta:

$ php artisan config:clear

$ php artisan cache:clear

Fuente
======

DeepSeek

==========================================
Ruta para devolver la versión del software
==========================================

1) Crear un archivo con nombre VERSION.txt en la raíz del proyecto.

2) En el archivo routes/web.php agregar lo siguiente:

use Illuminate\Http\JsonResponse;

Auth::routes();

Route::group(['middleware' => ['auth']], function () {

    // Ruta que devuelve la versión del software.
    Route::get('/version', function () {
        $versionFile = base_path('VERSION.txt');

        if (file_exists($versionFile)) {
            $version = trim(file_get_contents($versionFile));
            return new JsonResponse(['version' => $version]);
        }

        return new JsonResponse(['version' => 'No disponible'], 404);
    })->name('version');

3- Probar la ruta: Una vez implementado, puedes probar la ruta accediendo a:

http://tudominio.com/version

Deberías obtener una respuesta JSON como:

{
    "version": "1.0.0"
}

===================================================================
Seeder para probar el envío correcto de correos desde la aplicación
===================================================================

$ php artisan db:seed --class=SendTestEmailSeeder

<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\Mail;
use Illuminate\Support\Facades\Log;

class SendTestEmailSeeder extends Seeder
{
    /**
     * Ejecuta el seeder que solicita un correo y envía un email de prueba.
     *
     * Uso:
     * php artisan db:seed --class=SendTestEmailSeeder
     */
    public function run()
    {
        // Pide al usuario que ingrese un correo por consola
        $email = $this->command->ask('Ingrese el correo de prueba para enviar la notificación');

        // Valida formato del correo
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            $this->command->error("Correo inválido: {$email}");
            return;
        }

        $subject = 'Prueba de envío de correo - Sinidot';
        $body = "Este es un correo de prueba enviado por el seeder SendTestEmailSeeder.\n\n"
            . "Si recibe este mensaje, la configuración de correo está funcionando correctamaente.\n\n"
            . "Fecha: " . now();

        try {
            // Enviar correo en texto plano
            Mail::raw($body, function ($message) use ($email, $subject) {
                $message->to($email)
                        ->subject($subject);
            });

            $this->command->info("Correo de prueba enviado correctamente a: {$email}");
        } catch (\Exception $e) {
            // Log y mensaje de error en consola
            Log::error("SendTestEmailSeeder error: " . $e->getMessage());
            $this->command->error("Error al enviar el correo: " . $e->getMessage());
        }
    }
}
