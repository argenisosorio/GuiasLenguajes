==========================================
Guía de comandos en GNU/Linux Debian by dM
==========================================

Nota:
-Usaremos $ para describir los comandos que se usaran con usuario regular.
-Usaremos # para describir los comandos que se usaran con superusuario.

=============================================
Comandos para mostrar información del sistema
=============================================

Mostrar archivos ocultos de un directorio, esto se hace desde el explorador de
archivos nautilus de Gnome.

Crtl + h

-----

Para saber la versión de SO que tenemos.

$ cat /etc/issue.net

-----

Para saber la versión de SO que tenemos.

$ cat /etc/issue

-----

Para saber la versión de Debian que tenemos específicamente.

$ cat /etc/debian_version

-----

Para ver la información del cpu o procesador.

$ cat /proc/cpuinfo

-----

Para ver la información del cpu o procesador pero menor a la anterior.

$ lscpu

-----

Saber el número de núcleos del procesador.

$ nproc

----

Comando que nos va a dar detalles de SO.

$ lsb_release -a

-----

Muestra información del sistema.

$ uname

-----

Muestra la versión del SO instalado, Version de Kernel y arquitectura de
procesador.

$ uname -a

-----

Saber mi version de Kernel especifica, recomendada.

$ uname -mrs

-----

Ver info del sistema.

$ cat /etc/*-release

-----

Indica cuánto tiempo ha estado funcionando el sistema, muestra:

$ uptime

15:11:08 up 1 day,  5:07,  9 users,  load average: 0,65, 0,83, 0,88

Los parámetros que muestra son:

-El tiempo actual que el sistema ha estado ejecutando.
-El tiempo que lleva el sistema corriendo.
-Los usuarios que están actualmente registrados.
-Tiempo de carga del sistema durante los últimos 1, 5 y 15 minutos.

-----

Saber cuantos demonios(daemons) del sistema están en ejecución. En esta ruta se
encuentran algunos de los scripts que se ejecutan con el arrenque del SO.

$ ls -l /etc/init.d/

-----

Muestra la fecha.

$ date

-----

Asignar la fecha manualmente.

# date --set 1998-11-02

-----

Asignar la hora manualmente.

# date --set 21:08:00

-----

Muestra un calendario.

$ cal

-----

Ver informacion de los discos duros, particiones y dispositivos montados en el
sistema.

# fdisk -l

-----

Este comando muestra los dispositivos USB conectados al equipo, organizados por
buses y dispositivos lógicos. Este comando no te dice cuántos puertos USB
físicos tiene el computador.

$ lsusb

Ejemplo de salida:

$ lsusb

Bus 002 Device 005: ID 0a5c:5800 Broadcom Corp. BCM5880 Secure Applications Processor
Bus 002 Device 006: ID 258a:003a SINO WEALTH Gaming KB
Bus 002 Device 003: ID 1bcf:08a0 Sunplus Innovation Technology Inc. Gaming mouse [Philips SPK9304]
Bus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 001 Device 004: ID 1bcf:2802 Sunplus Innovation Technology Inc. Laptop_Integrated_Webcam_FHD
Bus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub

Lo que vemos aquí son:

-Buses: El sistema organiza los puertos USB en buses (Bus 001 y Bus 002 en este
caso).

-Dispositivos raíz (root hubs): Cada bus tiene un "root hub" (identificado con
Linux Foundation) que gestiona las conexiones. Estos no son puertos físicos a
los que conectas tus dispositivos.

-Dispositivos conectados: Los otros dispositivos listados son los periféricos
que actualmente están conectados a tus puertos USB (webcam, mouse, teclado,
etc.) o componentes internos que utilizan la interfaz USB.

-----

Herramienta poderosa para obtener información detallada sobre los conectores
físicos presentes en la placa base de tu computadora. Sirve para contar
por ejemplo los puertos USB físicos, pero no necesarimente son solo los que
se usan para colocar pendirves por ejemplo, hay más puertos USB que se usan
como por ejemplo para la webcam internamente, entre otros.

$ sudo dmidecode -t connector

-----

Lista todos los componentes tipo pci (Peripheral Component Interconnec) como
las tarjetas de red, de sonido o de televisión.

$ lspci

-----

Leer el fichero meminfo que contiene datos dinámicos de la memoria, similar
a free.

$ cat /proc/meminfo

-----

Saber cuánta y qué tipo de memoria RAM tengo.

$ sudo dmidecode --type memory | less

-----

Muestra el estado de la memoria virtual.

$ vmstat

-----

Muestra el espacio disponible del disco y demas dispositivos asi como el espacio
usado.

$ df

-----

Muestra el espacio disponible del disco y demas dispositivos asi como el espacio
usado, pero en mg o gb según sea el caso.

$ df -h

-----

Muestra el espacio disponible del disco y demas dispositivos asi como el espacio
usado, pero en mg.

$ df -m

-----

Muestra los procesos del sistema en forma de arbol.

$ pstree

-----

Enumerar todas las fuentes instaladas que están disponibles en su sistema linux.

$ fc-list

-----

Saber que gestor de sesiones estoy utilizando

$ cat /etc/X11/default-display-manager

===========
Memoria ram
===========

Muestra el estado de la memoria RAM, total, usado, disponible, cached, buffers.

$ free

Mostrar los datos en mb sin más.

$ free -m

Para ver los resultados en mb o gb con letra al final.

$ free -h

Detalles, fabricante, tipo, el máximo que soporta nuestro equipo, etc.

# dmidecode --type memory

================================
Tips para la consola de comandos
================================

Repetir el ultimo comando ejecutado en consola.

!!

Para sacarlo usar AvPag en la consola.

~

Ejecucion multiple de comandos

$ comando && comando && comando

Cortar el contenido de la linea de comandos desde la posicion del cursor hasta
el principio.

Ctrl + u

Cortar el contenido de la linea de comandos desde la posicion del cursor hasta
el final.

Ctrl + k

Intercambiar de posicion las letras que estan a cada lado del cursor.

Ctrl + t

Limpiar el shell.

Ctrl + l

En el shell, cerrar sesion, salir del root, de maquinas virtuales o de sesiones
de usuarios iniciadas.

Ctrl + d

Moverse en el prompt palabra a palabra, no letra por letra.

Ctrl + flecha derecha o izquierda

Borrar la palabra que esta antes del cursor en el shell.

Ctrl + w

Parar la salida por pantalla. Si por ejemplo ejecutamos un comando que tiene una
salida inmensa, podemos hacer que trabaje en silencio.

Control + s

Permitir la salida por pantalla, inverso al comando anterior.

Control + q

Borrar palabra

Alt + d

===============
Comandos varios
===============

Muestra el manual de una comando donde como: ls, grep, aptitude etc...

$ man nombre_comando

Dentro de los manuales podemos presionar "h" para ver las opciones tenemos del
manual, ejemplo "/delete" para hacer una busqueda de la cadena "delete" dentro
del manual.

Limpiar la consola.

$ clear

Si no desea ver la página de manual completa sino sólo una descripción corta
para confirmar que es lo que está buscando, ingrese whatis programa.

$ whatis nombre_programa

Ejemplo:

$ whatis scp

scp (1)     - copia segura (programa de copia de ficheros remotos)

-----

Apagar la maquina

$ sudo poweroff

Se debe ser root para ejecutarlo.

# poweroff

-----

Apagar la maquina.

$ sudo shutdown -h now

-----

Reiniciar la maquina.

$ reboot

Reiniciar la maquina en Debian 10.

# systemctl reboot

-----

Detectar las resoluciones de pantalla disponibles del sistema así como los hz
correspondientes, la que tenga (*) es la que está siendo usada.

$ xrandr

-----

Obtener la resolución de la pantalla o pantallas o monitor:

$ xrandr | grep '*'

-----

Dimensiones de las pantallas, pantalla o monitor en mm:

$ xrandr | grep ' connected'

Este comando busca las pantallas conectadas y muestra información sobre ellas.
La salida se verá algo así:

HDMI-1 connected primary 1920x1080+0+0 (normal left inverted right x axis y axis) 477mm x 268mm

Para convertir las dimensiones de milímetros (mm) a centímetros (cm),
simplemente divide cada dimensión entre 10, ya que 1 centímetro es igual a 10
milímetros.

Aquí están los pasos para convertir 477 mm x 268 mm a cm:

Ancho: 477mm / 10 = 47.7cm

Alto: 268mm / 10 = 26.8cm

-----

Ver las dependencias de una librería o ejecutable, en este caso del ejecutable
de python.

$ ldd /xxx/python2.7

$ ldd /bin/bash

===================================
Comandos para gestionar directorios
===================================

(print work directory) Muestra la ruta en la que te encuentras.

$ pwd

Crear una carpeta.

$ mkdir nombre_carpeta

Crear una carpeta con otra carpeta dentro, encadenar la creación.

$ mkdir -p carpeta1/carpeta2

El operador '&&' sirver para continuar con la ejecucion de comadnos en el shell,
ejemplo:

Creamos una carpetaFFF y luego entramos en la carpeta creada

$ mkdir carpetaFFF && cd carpetaFFF

&& nos permite poner varias instrucciones en una sola linea del shell, otro
ejemplo:

Creamos una carpeta, entramos en ella y creamos un archivo en ese directorio en
una sola instruccion.

$ mkdir carpetaZZZ && cd carpetaZZZ && touch archivo.txt

Crear fichero con la extensión que se requiera.

$ touch nombre_fichero.xxx

Crear una carpeta que lleve por nombre la fecha, ejemplo: 20170807

$ mkdir /tmp/`date +\%Y\%m\%d`

====================================
Comandos para listar los directorios
====================================

Muestra lo que hay en la carpeta en la que te encuentras.

$ ls

-----

Muestra los archivos, fecha, permisos, etc.

$ ls -l

-----

Muestra los archivos, fecha, permisos, y el peso pero en kb,mg o gb según sea el
caso.

$ ls -lh

-----

Muestra los archivos, los ocultos tambien, fecha, permisos, etc.

$ ls -la

-----

Muestra los archivos en forma de lista.

$ ls -1

-----

Lista el contenido de un directorio en orden alfabético, usa space para paginar
si la lista es grande.

$ ls | more

-----

Listar todos los ficheros de un directorio que tengan las extension .xxx, donde
xxx puede ser: txt, html, php, css.

$ ls *.xxxetc

ejemplo: ls *.txt

-----

Listar los directorios y subdirectorios asi como ficheros de un directorio.

$ ls -R

-----

Muestra el contenido del directorio en una lista numerada.

$ ls | cat -n

-----

Contar el número de ficheros o elementos contenidos en un directorio.

$ ls name_dir | wc

-----

Ver la lista de carpetas y sub carpetas, los directorios que existen, lo primero
que muestra es el tamaño.

$ du

-----

Los mismo que arriba pero se ven los tamaños pesos en kb, mg, etc.

$ du -h

-----

Ver el tamaño total de los directorios.

$ du -sh

-----

Ver el tamaño de un directorio específico.

$ du -sh name_dir

-----

Muestra todos directorios y ficheros y el espacio que ocupan en el disco.

$ du *

-----

Leer todos los elementos y ver los tamaños en kg, mg, etc.

$ du -h *

-----

Ver los tamaños en kg, mg, etc, de un fichero específico.

$ du -h file_name.xxx

-----

Ver el tamaño de los directorios y de los archivos en megabytes, hasta 10
niveles de profundidad.

$ du -ha --max-depth=10 | sort -hr

-----

Listar los archivos de X extensión por peso sin importar si está en un
subdirectorio, en este caso los .txt por ejemplo, dara los pesos en mg y kb
ordenados de mayor a menor en la lista:

$ find . -type f -name "*.pdf" -exec du -ah {} + | sort -hr

Explicación del comando:

find . -type f -name "*.txt": busca en el directorio actual (.) todos los
archivos (-type f) con la extensión .txt (-name "*.txt").

-exec du -ah {} +: ejecuta el comando du -ah en cada uno de los archivos
encontrados. La opción {} se reemplaza con el nombre del archivo encontrado, y
el + al final indica que se deben procesar varios archivos a la vez para mejorar
el rendimiento.

| sort -hr: ordena la lista resultante por tamaño, de mayor a menor.

Este comando mostrará una lista de todos los archivos con la extensión .txt en
el directorio actual y sus subdirectorios, ordenados por tamaño en megabytes.
Puedes cambiar la extensión .txt en el comando para listar otros tipos de
archivos.

-----

Calcular el tamaño ocupado por un directorio.

# du -h -s /var/log

9,6M    /var/log

-----

Nos dira el tipo de archivo de todos los ficheros del directorio.

$ file *

=======================================
Comandos para moverse entre directorios
=======================================

Cambiar de directorio, nos lleva al home del usuario.

$ cd

-----

Acceder a un directorio que tiene espacios en el nombre.

$ cd 'nombre carpeta'

-- Si una carpeta se llama (a b c d e), para aceder a ella usamos:

Al final siempre lleva el / normal, los otros usan el invertido.

$ cd a\ b\ c\ d\ e/

-----

Retroceder un directorio.

$ cd ..

-----

Retroceder dos directorios (../) representa un directorio.

$ cd ../../

===========================
Rutas relativas y absolutas
===========================

- Una ruta o path es donde se localiza una carpeta o fichero dentro de nuestro
sistema de ficheros.

- Todos los comandos que se ejecuten sin especificar una ruta lo hará donde este
situado.

- Hay dos tipos de ruta que debemos diferenciar:

=============
Ruta absoluta
=============

Se indica toda la ruta del fichero incluyendo el directorio raíz. Por ejemplo:

/home/user/folder/file.txt

=============
Ruta relativa
=============

Se indica la ruta a partir de donde este en ese momento situado. No se incluye
el directorio raíz. Por ejemplo, si estamos en la ruta /home/user y queremos
acceder al file.txt que esta dentro de folder, seria:

folder/file.txt

=================================================================
Comandos para buscar ficheros, directorios, paquetes, historiales
=================================================================

Mostrar el historial de los comandos de la consola.

$ history

-----

Mostrar los ultimos comandos usados por el usuario

$ fc -l

-----

Busqueda especifica de una comando usado, ejemplo: aptitude, alias, grep etc.

$ history | grep xxx

-----

En los archivos ocultos del home, en este fichero se almacena el historial de
los comandos usados.

.bash_history

-----

--color para colorear la palabra a buscar, -n para listar la la linea del
caracter buscado y al final la ruta del archivo a buscar.

$ grep --color=always -n "mysql" /var/www/prueba/2/datos.php

-----

Busca la cadena de manera recursiva en la carpeta en que se encuentre situado

$ grep cadena_texto ./* -rIn

-----

Busca la cadena de manera recursiva en la carpeta en que se encuentre situado.

$ grep --color=always -n "cadena_texto" ./* -Ir

No hace falta poner =always siempre.

-----

$ grep --color -n "cadena_texto" -Ir

Aquí está el significado de cada una de las opciones utilizadas en el comando:

grep es un comando utilizado para buscar texto en archivos.

--color hace que la salida del comando se resalte en color para que sea más
fácil de leer.

-n hace que se imprima el número de línea junto con la línea coincidente.

-I hace que los archivos binarios se ignoren durante la búsqueda.

-r hace que la búsqueda se realice de manera recursiva en todos los archivos y
subdirectorios a partir del directorio actual.

Si se quiere buscar más de una cadena se usan las comillas dobrles:

$ grep --color -n -Ir "la casa"

Al utilizar comillas dobles, indicas que el contenido entre las comillas es una
sola cadena que debe ser buscada. En este caso, el comando buscará la cadena
"la casa" en todos los archivos del directorio actual y sus subdirectorios.

-----

Puedes usar la opción -i. La opción -i hace que la búsqueda sea insensible a
mayúsculas y minúsculas.

El comando modificado es:

$ grep --color -n -iIr debian

Resultado:

test.txt:100 Debian 12
test.txt:250: on-debian

Explicación de las opciones:

-n	Muestra el número de línea donde se encuentra la coincidencia.

-i	Ignora las diferencias entre mayúsculas y minúsculas al buscar.

-I	Ignora los archivos binarios. Esto es útil para evitar que grep se queje de
que no puede leer archivos que no son de texto.

-r	Busca recursivamente en todos los archivos de los subdirectorios.

-----

$ grep --color -n -Ir -F "\$('.directions"

pdf-flip.js:15:                    $('.directions .prev-button').click();
pdf-flip.js:18:                    $('.directions .next-button').click();

El \ al principio escapa el carácter $ para que grep lo interprete literalmente
y no como un metacarácter de expresiones regulares.

-----

Otra forma de busqueda.

$ egrep -r "Saludo" .

-----

Filtra la busqueda con el parametro que le demos ejemplo:

| grep xxx

-----

Busca las versiones de python que coincidan con el patron 2.7.

$ aptitude search python | grep 2.7

-----

Busca en los procesos del sistema las coincidencias con ruby

$ ps -e | grep ruby
-----

Para saber donde esta instalado un programa, saber el directorio

$ whereis python

$ whereis firefox

$ whereis apache2

-----

Listar todos los archivos contenidos en el directorio actual y en los sub
directorios, si estamos en /home/user nos listara todo, dependiendo de donde
este pues listara el contenido.

$ find

-----

Buscar un directorio especifico en el sistema.

$ find -name name_dir

-----

Buscar un fichero o directorio específico en el sistema.

# find / -name name_file_or_package

-----

Para mostrar el directorio del archivo que se quiera buscar, se debe saber el
nombre del archivo.

# find / -type f -name NombreArchivo.html

-----

Abrir un fichero del directorio desde el navegador.

file:///home/user/nombre_fichero.xxx

-----

Hacer una busqueda de un archivo en los directorios, se puede especificar un
nombre con su extensión o solo especificar una palabra, la busqueda se hara en
todos los archivos que contengan la palabra o nombre de archivo escrita.

$ locate nombre_del_archivo

-----

Buscar en todos los directorios los ficheros con la extension especificada.

$ locate .jpg

-----

Buscar en todos los directorios los ficheros con la extension especificada.

$ locate "*.jpg"

-----

Buscar en todos los .pdf del sistema que contengan la palabra "software" en el
nombre. Sí hace distinción entre mayúsculas, minúsculas y acéntos.

$ locate .pdf | grep software

-----

Muestra cuantos archivos contienen la palabra "hola" en el nombre.

$ sudo locate -c hola

-----

Busca todos los archivos que contienen la palabra "hola" en el nombre tanto en
mayúsculas como en minúsculas.

$ sudo locate -i hola

-----

Para guardar el resultado de la búsqueda en un archivo de texto.

$ sudo locate nombre_archivo > /home/usuario/lista.txt

-----

(/) es para hacer la busqueda desde ahi en adelante, puede ser (/home/user)

$ sudo find / -name nombre_carpeta

-----

Lista los archivos que componen el directorio introducido.

$ find /carpeta

-----

Busca la ruta donde se encuentra el comando, ejemplo: aptitude, python, etc.

$ type nombre_comando

-----

Buscar la ruta de un programa.

$ which nombre_programa

-----

Buscar en todo el sistema los ficheros cuyo nombre contengan la expresion
escrita.

$ sudo find / -name "*nombre_fichero*"

-----

Buscar en el directorio actual los ficheros cuyo nombre contengan la expresion
escrita.

$ sudo find -name "*nombre_fichero*"

-----

Buscar en todo el sistema los ficheros cuyo nombre contengan la expresion
escrita, en este caso, una extensión de fichero, donde / puede ser /home/user
etc y .xxx la extension: .jpg, .png, .txt, .py, etc.

$ sudo find / -name "*.xxx*"

-----

Busca todos los archivos que NO contienen la palabra "xxx" en el nombre, se
especifíca el directorio en el cual buscar.

$ sudo find /home/user ! -name "*xxx*"

-----

Busca todos los archivos que contienen la palabra "xxx" en el nombre tanto en
mayúsculas como en minúsculas.

$ sudo find /home/user -iname "*xxx*"

-----

Si el resultado de la búsqueda anterior te ha proporcionado una gran cantidad de
información, resulta más cómodo almacenar el resultado de la búsqueda en un
fichero de texto para revisarlo posteriormente.

$ sudo find /home/user/ -iname "*xxx*" > /home/user/lista.txt

-----

Crear un fichero (x.txt) que guardará la salida de la consola, en este caso es
una búsqueda, buscamos el fichero.c en el directorio user y guardaremos la
salida del shell en el fichero x.txt que se creará.

# sudo find / -type f -name /home/user/fichero.c>>/home/user/x.txt

===================================================
Comando para el mantenimiento de los logs de Debian
===================================================

Los logs del sistema se almacenan en /var/log/* tiene un limite maximo, se van
guardando comprimidos y luego se van borrando automáticamente.

-----

Ver el tamaño del directorio:

# du -sh /var/log

-----

Ver el tamaño de los directorios que estan adentro:

# du -h /var/log

Los siguientes comandos eliminan los logs guardados de manera segura, no afecta
el funcionamiento del sistema:

# aptitude clean && aptitude autoclean && apt-get autoremove && apt autoremove && apt purge && apt remove

# rm -f /var/log/*.old /var/log/*.gz /var/log/apt/* /var/log/auth* /var/log/daemon*

# rm -f /var/log/debug* /var/log/dmesg* /var/log/dpkg* /var/log/kern*

# rm -f /var/log/messages* /var/log/syslog* /var/log/user* /var/log/Xorg* /var/crash/*

===========================================
Lectores/Editores de texto desde la consola
===========================================

Modificar un fichero con el editor nano.

$ nano nombre_fichero

Leer el manual del editor de textos nano, muy útil, práctico y fácil de usar.

$ man nano

Mostrar contenido de un fichero, concatenate files and print on the standard
output.

$ cat nombre_fichero.xxx

Mostrar contenido de un fichero y numerar las líneas.

$ cat -b nombre_fichero.xxx

Mostrar el contenido de un archivo, lector de ficheros, mayor movilidad que cat,
con / permite buscar dentro del fichero, como vim, q para salir.

$ less nombre_fichero.xxx

El comando tail sirve para mostrar en pantalla las últimas líneas de un archivo.

$ tail nombre_fichero.xxx

-n donde X es el número de lineas que queremos ver del fichero.

$ tail -n X nombre_fichero.xxx

-n donde X es el número caracteres desde el final, que queremos ver del fichero.

$ tail -c X nombre_fichero.xxx

Se pueden especificar 1 o más ficheros a la vez, los mostrara en el orden
declarado.

$ tail fichero_1.xxx fichero_2.xxx

Muestra el estado e información de un fichero

$ stat nombre_fichero

Muestra información de un directorio

$ stat nombre_carpeta

Donde xxx es el nombre de un fichero, nos dira el tipo de fichero que es.

$ file xxx

Ejemplo: file index.html

index.html: HTML document, UTF-8 Unicode text

Permite hacer una comparacion de dos archivos para apreciar sus diferencias se
debe especificar la ruta de ambos archivos y separarlos con un espacio, si estan
en el mismo directorio no hace falta especificar las rutas completas.

$ diff /home/user/file.html /home/user/file2.html

Cambiar extension a todos los ficheros de un directorio

En el ejemplo vamos a sustituir los .txt por .xls y le decimos que se lo haga a
todos los .txt

$ rename 's/\.txt/\.xls/' *.txt

====
Less
====

less es un visualizador de archivos de texto que funciona en intérpretes de
comando.

A diferencia de otros programas similares (como more), less permite una completa
navegación por el contenido del archivo, utilizando un mínino de recursos del
sistema.

Manual de less.

$ man less

Avanzar una página

AvPag

Retroceder una página

RePag

Tecla espacio para avanzar, como page up

space

Salir

:q

Ayuda

:h

(/) Buscamos una palabra dentro del documento

:/palabra

Para ir a la siguiente coincidencia.

(n)

Para ir a la coincidencia anterior

(N)

Ir al final del texto.

:G

Ir al inicio del texto.

:g

Invocar un editor de texto para el documento, por lo general usa vi pero puede
usar nano automaticamente.

:v

Para ir a una línea específica de un fichero.

$ less +123 filename

====================================
Ver un fichero .csv desde la consola
====================================

Ordenará por columnas, etc...

$ cat file.csv | sed -e 's/,,/, ,/g' | column -s, -t | less -#5 -N -S

===================================
Comandos para monitorear el sistema
===================================

Listar los procesos de ejecución del sistema (y más cosas) en tiempo real, es
una de las herramientas más importantes para un administrador.

$ top

Si presionamos "z" nos mostrara la salida con 2 colores, para distingir mejor la
información.

"q" o "Ctrl+c" para salirse del monitor top.

Liberar memoria ram.

# sysctl -w vm.drop_caches=3

Recargar el entorno gráfico, evitando el reinicio del pc.

# gnome-shell --replace & disown

Refrescar el escritorio gnome sin reiniciar.

Alt + F2 y escriba r y presione enter, esto para gnome3

Para refrescar el desktop en xfce.

$ xfce4-panel -r && xfwm4 --replace

Si un programa es pausado con Ctrl + z, con este comando lo reanudamos.

$ fg %1

Es otro monitor del sistema, parecido a top pero con un poco mas de herramientas
, para instalarlo # apt-get install htop.

$ htop

Es otro monitor de sistema, para instalarlo # apt-get install nmon

Si quieren ver la información relacionada con el CPU presionan la tecla "c", con
la memoria "m", del kernel "k" y discos "d".

Segun vayamos usando las letras nos va mostrando lo que escogimos, muy útil y
bonito.

$ nmon

Donde xxx es el nombre de un host al cual enviaremos paquetes y comprobaremos si
hay una conexion con ese host, util para saber si estamos conectados a internet.

$ ping xxx

Ejemplo:

Si hay conexion a internet enviara paquetes que seran recibidos, de lo contrario
dara un error.

$ ping http://www.google.com

Tiempo en segundos que se va a hacer ping donde n es un entero.

$ ping -w n ip_num

Ver si hay aceleracion grafica en la maquina, muestra unos engranajes de colores
rodando, si es así, está correcta la instalacion del video.

# glxgears

Este comando sirve para revisar el log o bitácora de los eventos ocurridos en el
sistema, cuelca todos los mensajes que han ocurrido desde el arranque del
sistema.

# journalctl

Si un servicio parece que no está funcionando como debiera, el primer paso para
resolver el problema es comprobar si el servicio está ejecutándose realmente
mediante systemctl status. Si no es así y los mensajes que se muestran no son
suficientes para diagnosticar el problema se pueden comprobar los registros que
ha recogido journald relacionados con es servicio. Por ejemplo, suponiendo que
el servidor SSH no funciona:

# systemctl status ssh.service

-f , que hace que journalctl siga mostrando los nuevos mensajes a medida que se
van emitiendo (semejante a lo que ocurre con tail -f file).

# journalctl -f

===========================
Eliminar vs vaciar ficheros
===========================

Para eliminar ficheros con el fin de liberar espacio emplearemos habitualmente
el comando rm. Sin embargo, es muy habitual que no nos podamos permitir eliminar
un fichero por estar siendo utilizado en ese momento por una aplicación, lo cual
es de lo más habitual con ficheros de log en sistemas en producción que no
pueden parar. Eliminarlos directamente puede tener consecuencias nefastas, como
el bloqueo de la propia aplicación que los está utilizando, o más leves pero
también indeseables, como que se interrumpa el volcado de datos a estos ficheros
y dejen de ser útiles.

Para no alterar el funcionamiento de una aplicación y conseguir nuestro objetivo
de liberar espacio vaciaremos los ficheros en lugar de eliminarlos:

# >/var/log/syslog

=======
Fuentes
=======

-https://www.daniloaz.com/es/los-comandos-linux-mas-utiles-para-mantener-sistemas-de-ficheros/

==============================
Gestionar procesos del sistema
==============================

Cada proceso tiene un identificador (PID) proccess ID, entonces podemos matar
ese proceso con:

Matar un proceso donde xxxx es el identificador del proceso.

$ kill xxxx

Matar un proceso donde xxxx es el identificador del proceso.

$ kill -9 xxxx

Muestra los procesos actuales del sistema y acepta varios parametros como:

$ ps

Visualiza información sobre "todos" los procesos del sistema.

$ ps -e

-----

Visualiza información sobre "todos" los procesos del sistema con mas detalles,
así pues se puede detener un proceso con kill -9 PID_number.

$ ps -ef

Filtrar la búsqueda, en este caso, buscando el proceso que alberga el visor pdf
evince.

$ ps -ef | grep evince

-----

pidof es una utilidad de la línea de comandos de Linux que devuelve el ID de un
proceso (PID) o procesos.

$ pidof firefox
2993

-----

Filtrar la búsqueda para ver las conexiones ssh activas, nuevamente se aclara
que podemos matar esos procesos con kill -9 xxx pasandole el PID process.

$ ps -ef | grep ssh

Saber el tiempo que lleva ejecutandose un proceso.

$ ps -p xxxx -o etime

Muestra los procesos del sistema de sistema, similar a ps -ef.

$ ps aux

Mostrar información de proceso/s específico/s.

$ ps aux | grep firefox

Muestra algunos detalles de los procesos del sistema.

$ ps -l

Muestra mas detalles de los procesos del sistema.

$ ps l

========================
Driver de wifi en laptop
========================

# apt install firmware-iwlwifi

# apt-get install firmware-b43-installer

# apt-get install firmware-linux firmware-linux-free firmware-linux-nonfree firmware-misc-nonfree firmware-realtek

=====================================
Reiniciar la interfaz de red en Linux
=====================================

Luego de algun cambio en el archivo etc/network/interfaces se debe reiniciar
el servicio networking con el siguiente comando:

$ sudo systemctl restart networking

============================================================================
Restaurar o reiniciar las conexiones de red del sistema - networking restart
============================================================================

# /etc/init.d/networking restart

# service networking restart

# invoke-rc.d networking restart

=======================
Para maquinas virtuales
=======================

Cuando se va a conectar por wireless, para que el dhcp le asigne una dirección
ip modificamos el fichero:

/etc/network/interfaces

Y quedará así:

# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

source /etc/network/interfaces.d/*

# The loopback network interface
#auto lo
#iface lo inet loopback
auto eth0
iface eth0 inet dhcp

---

Guardamos y reiniciamos las interfaces de redes con los tres comandos de arriba,
esto es para cuando una máquina virtual no agarra internet inalambrico, tambien
debe estar habilitada el adaptador de conexión inalambrica en el panel de
configuración de la maquina virtual. Dentro de la máquina virtual parecerá que
esta conectado por cable.# The loopback network interface

Cuando se instala el SO y no consigue ninguna red cableada, es posible que el
router/DHCP no le haya asignado una dirección ip, entonces modificamos el mismo
fichero para que quede así:

auto lo
iface lo inet loopbackresolv.conf
# ifup eth0

Luego # ip addr a ver si ya tiene ip, si no es así entonces reiniciaremos las
conexiones de red del sistema con los comandos descritos arriba.

Si lo demás no ha servido, se puede editar el /etc/resolv.conf de la máquina
virtual a ver si hagarra internet, a veces el dhcp le asigna ip pero no tiene
conexión a internet, entonces:

# sudo nano /etc/resolv.conf

Agregamos las siguientes líneas:

nameserver 8.8.8.8
nameserver 8.8.4.4

Guardamos el archivo y hacemos ping a ver si ya envía paquetes a google:

Lo que vamos a hacer es enviar paquetes a los servidores de Google para
comprobar si nos responde su ip pública es 8.8.8.8

$ ping 8.8.8.8

===================================================================
Restaurar o reiniciar las conexiones de red inalambrica del sistema
===================================================================

If you really want to reset the network adapter you usually need to unload and
reload the kernel module that it uses.

If you just want to reconfigure it you can usually do:

# /etc/init.d/network-manager restart

But if you just want a new dhcp lease (that's the technical name for obtain a
new IP from the router), you just need to use:

# dhclient -v eth1

===================
Herramientas de red
===================

Permite desplegar numerosos parámetros de las interfaces de red residentes  en
el núcleo, como la dirección ip (dinámica o estática), o la máscara de red entre
otros.

# ifconfig

-----

Para ver el estatus de las conexiones de red, este comando le mostrará su
dirección ip, el tipo de conexión que está utilizando, etc.

$ ip addr

-----

Este comando nos muestra información de la red a la cual estamos conectados,
como la ip de la máquina.

$ ip route

ó

$ ip r

====
nmap
====

Nmap es una poderosa herramienta de exploración de redes que te permite
descubrir hosts y servicios, así como realizar análisis de seguridad en una red.

1- Instalar Nmap:

$ sudo apt install nmap

2- Ejecutar Nmap:

Una vez que Nmap esté instalado, puedes comenzar a ejecutar comandos. Aquí
tienes algunos ejemplos básicos:

Escaneo de un solo host:

$ sudo nmap <dirección IP>

Reemplaza <dirección IP> por la dirección IP del host que deseas escanear.

Ejemplo:

$ sudo nmap 192.168.12.82
[sudo] password for user:
Starting Nmap 7.80 ( https://nmap.org ) at 2023-06-01 12:05 -04
Nmap scan report for 192.168.12.82
Host is up (0.0000060s latency).
Not shown: 998 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

Nmap done: 1 IP address (1 host up) scanned in 0.13 seconds

-----

Escaneo de un rango de direcciones IP:

$ sudo nmap <rango de direcciones IP>

Reemplaza <rango de direcciones IP> por el rango que deseas escanear, por

Ejemplo:

$ sudo nmap 192.168.12.1-100

Esto te dara los detalles de los dispositivos conectados a la red en el rango
establecido, con los detalles como en el primer comando de ejemplo

-----

Escaneo de una red completa:

$ sudo nmap <dirección de red/máscara>

Reemplaza <dirección de red/máscara> por la dirección de red y la máscara de
subred que deseas escanear, por ejemplo, 192.168.0.0/24.

Ejemplo:

$ sudo nmap 192.168.12.0/24

Esto te dara los detalles de los dispositivos conectados a la red, con los
detalles como en el primer comando de ejemplo

Estos son solo ejemplos básicos, y Nmap ofrece muchas opciones y funcionalidades
avanzadas. Puedes explorar la documentación oficial de Nmap para aprender más
sobre los comandos y las opciones disponibles.

-----

Ver que puertos de la pc que estan escuchando:

$ sudo nmap -sT -O localhost

Otros comandos:

1. Escaneo Simple

$ nmap <IP_o_Dominio>

Ejemplo: nmap 192.168.1.1

Qué hace: Escaneo rápido de puertos abiertos (solo los 1000 más comunes).

2. Escaneo a Todos los Puertos (1-65535)

$ nmap -p- <IP>

Ejemplo: nmap -p- 192.168.1.100

Qué hace: Escanea todos los puertos (puede ser lento).

3. Escaneo Rápido (Puertos Comunes + Timing Agresivo)

$nmap -T4 -F <IP>

-T4: Modo rápido (mayor velocidad, menor precisión).

-F: Escanea solo los 100 puertos más comunes.

4. Detección de Sistema Operativo y Servicios
bash

$ nmap -A <IP>

-A: Activa detección de OS (Operating System), versiones de servicios y scripts básicos.

5. Escaneo Solo a Puertos Específicos

nmap -p 22,80,443 <IP>

Ejemplo: nmap -p 22,80,443 192.168.1.1

Qué hace: Escanea solo SSH (22), HTTP (80) y HTTPS (443).

6. Escaneo de Red Completa (Subred)

$ nmap 192.168.1.0/24

Qué hace: Escanea todos los dispositivos en la red 192.168.1.1 a 192.168.1.254.

7. Escaneo con Scripts de Nmap (NSE)

$ nmap --script <nombre_script> <IP>

Ejemplo:
nmap --script vuln 192.168.1.1  # Busca vulnerabilidades conocidas
nmap --script http-enum 192.168.1.100  # Enumera directorios web

8. Escaneo Sigiloso (Sin Ping + Timing Lento)

$ nmap -Pn -T2 <IP>

-Pn: Omite el descubrimiento de hosts (útil si el firewall bloquea ICMP).

-T2: Modo lento (para evitar detección por IDS/IPS).

9. Guardar Resultados en un Archivo

nmap -oN resultado.txt <IP>      # Formato normal
nmap -oX resultado.xml <IP>      # Formato XML (para herramientas como Metasploit)
nmap -oG resultado.grep <IP>     # Formato "grepeable"

10. Detección de Firewall/IDS

$ nmap -sS -f <IP>                 # Fragmenta paquetes para evadir firewalls

$ nmap --script firewall-bypass <IP>

Bonus: Comando para Auditar Seguridad Básica

$ nmap -A -T4 -p- -v <IP>

-A: Detección agresiva (OS + servicios).

-T4: Velocidad alta.

-v: Modo verbose (muestra detalles en tiempo real).

Fuente
======

ChatGPT
DeepSeek

========
Iproute2
========

Iproute2 es un paquete de herramientas muy potentes para administrar interfaces
de red y conexiones en sistemas Linux.

Este paquete reemplaza completamente las funcionalidades presentes en ifconfig,
ya que este no viene instalado por defecto en GNU/Linux Debian 9 Stretch, ya que
a ifconfig se le considera obsoleto.

=====================================
Instalar ifconfig y route en Debian 9
=====================================

Lo primero que tenemos que hacer es abrir un terminal e instalar el paquete
“net-tools”. Si en la instalación hemos elegido hacer “sudo” para ascender a
superusuario para instalar paquetes, tecleamos:

# apt-get  install net-tools

==============================================
Comparación de comandos de entre ifconfig e IP
==============================================

Mostrar dispositivos de red y su configuración.

# ifconfig

$ ip addr show

ó

$ ip link show

Activar una interfaz de red.

$ ifconfig eth0 up

$ ip link set eth0 up

Desactivar una interfaz de red.

$ ifconfig eth0 down

$ ip link set eth0 down

Establecer una dirección IP a una interfaz.

$ ifconfig eth0 192.168.1.1

$ ip address add 192.168.1.1 dev eth0

Eliminar una dirección IP de una interfaz.

ifconfig no podrá hacer esto.

$ ip address del 192.168.1.1 dev eth0

Añadir una interfaz virtual.

$ ifconfig eth0:1 10.0.0.1/8

$ ip addr add 10.0.0.1/8 dev eth0 label eth0:1

Para configurar una tarjeta de red física, por ejemplo, con ifconfig debemos
teclear lo siguiente:

$ ifconfig eth0 192.168.0.2 netmask 255.255.255.0

$ ip addr add 192.168.0.2/24 dev eth0

==============================
Gestionar usuarios del sistema
==============================

Conectarse como otro usuario creado

$ su nombre_de_usuario

Como root, Agregar un usuario nuevo al sistema, una nueva sesion, nos pedira
agregar el nombre de usuario y asignarle contraseña, la clave de root es la
misma para todas las sesiones.

$ adduser nombre_de_usuario

Como root, eliminar el usuario creado

$ userdel -r nombre_usuario

Otra forma de eliminar un usuario creado

$ deluser --remove-home nombre_usuario

====================================
Comandos para escribir en un fichero
====================================

Escribir una cadena de texto al final de un fichero.

$ echo "Texto al final del archivo" >> archivo.txt

Insertar una cadena de texto "xxxxx" al principio de un fichero.

$ sed -i '1i xxxxx' archivo.txt

Insertar una cadena al final del fichero, funciona como el método echo.

$ sed -i '$a xxx' archivo.txt

Huevo de pascua, muestra una vaca.

$ apt-get moo

============================================
Comandos para copiar, mover, eliminar, otros
============================================

Copiar un fichero o carpeta

$ cp

-----

Copiar un fichero o carpeta

$ cp -r

-----

Copiar un fichero en un directorio se debe estar situado en la carpeta del
archivo a copiar

$ cp Nombre_de_archivo.txt /Carpeta/destino/a/copiar

-----

Copiar un directorio en otro, se debe estar situado en la carpeta de la
carpeta a copiar.

$ cp Nombre_carpeta -r /Carpeta/destino/a/copiar

-----

Saber la ruta de un directorio: Desde el explorador de archivar (nautilus) desde
cualquier directorio sin importar el nivel donde estemos, tecleamos Ctrl + l
esto nos dirá la ruta completa hasta el directorio.

-----

Se pueden copiar archivos o carpetas especificando las rutas completas, en este
caso la primera ruta es el directorio o archivo a copiar y la segunda es la ruta
donde se va a pegar lo copiado, ambas rutas separadas por un espacio en blanco.

$ cp -r /home/usuario/carpeta1/ /home/usuario/carpeta2/

Ambas carpetas estan en el mismo directorio donde estamos situados, por lo tanto
no hay que especificar las rutas completas de las carpetas involucradas.

-----

Hacer una copia de un fichero y cambiarle el nombre.

$ cp nombre_fichero.xxx nombre_fichero2.xxx

-----

Hacer una copia de un directorio y cambiarle el nombre.

$ cp -r carpeta1 carpeta2

-----

Mover un fichero o carpeta y/o cambiar su nombre.

$ mv

-----

Mover una carpeta o archivo especificando el directorio de salida y el de
llegada, si estan en el mismo directorio no hace falta poner las rutas
completas.

$ mv /home/carpeta/archivo1.txt /home/carpeta2/

-----

Renombrar un archivo o carpeta.

$ mv archivo1.txt archivo2.txt

-----

Borrar una carpeta.

$ rmdir nombre_carpeta

-----

Borrar un fichero.

$ rm nombre_fichero

-----

Borrar varios ficheros.

$ rm fichero1 fichero2 fichero3

-----

Para borrar una carpeta, se le da la ruta del directorio a borrar.

$ rm -r /directorio

-----

Borrar todos el contenido de una carpeta, se debe estar dentro del directorio.

$ rm *

-----

Borrar todo el contenido de una carpeta, incluyendo las carpetas de ese
directorio se debe estar dentro del directorio

$ rm -r *

-----

rm: Comando "remove", eliminar. -rf: r de "recursivo" donde se borra todo y f de
"force"; nunca solicita confirmación. /xxx/xxx indica la ruta de los ficehros o
carpetas a borrar.

$ sudo rm -rf /xxx/xxxx

-----

Borrar todos los elementos de un directorio exeptuando lo que está entre "",
donde try es un directorio pero también puede ser un fichero, "x.txt" por
ejemplo.

$ rm -r !("try")

-----

Pedir contraseña root, algunas versiones basadas en Debian.

$ sudo -i

-----

Pedir contraseña del root.

$ su

-----

Para salir del root, tambien exit, funciona en algunas consolas como python,
ruby, entre otras.

root@debian:/home/user# Ctrl + d

-----

En la consola, para hacer una busqueda de comandos usados baasndose en la
palabra que se introduzca.

Ctrl + r

-----

Moverse a traves de los logs de la consola, simula el scroll up/down del mouse.

Shift + Page up <--> Page down


Borrar y purgar un paquete con todos sus archivos y configuraciones

# apt-get --purge remove nombre-paquete

====================================================
Limpiar la papelera de reciclaje mediante un comando
====================================================

$ gio trash --empty

=======================
Ip pública e Ip privada
=======================

==========
Ip Pública
==========

Es la que tiene asignada cualquier equipo o dispositivo conectado de forma
directa a Internet.

Algunos ejemplos son: los servidores que alojan sitios web como Google, los
router o modems que dan a acceso a Internet, otros elementos de hardware que
forman parte de su infraestructura, etc.

Las Ip públicas son siempre únicas. No se pueden repetir. Dos equipos con IP de
ese tipo pueden conectarse directamente entre sí. Por ejemplo, tu router con un
servidor web. O dos servidores web entre sí.

==========
Ip Privada
==========

Se utiliza para identificar equipos o dispositivos dentro de una red doméstica o
privada. En general, en redes que no sean la propia Internet y utilicen su mismo
protocolo (el mismo "idioma" de comunicación).

Las Ip privadas están en cierto modo aisladas de las públicas. Se reservan para
ellas determinados rangos de direcciones. Son estos:

Estas Ip deben ser únicas dentro de una misma red. Cada equipo o dispositivo ha
de tener la suya, distinta de la de los demás. De lo contrario habría problemas.
Sería como si dos vecinos tuvieran el mismo nombre y la misma dirección física.
El cartero nunca sabría a quién corresponde la carta que les envíen.

Las Ip privadas sí pueden repetirse en redes distintas (como en la tuya y la de
una empresa). Los equipos o dispositivos con esas IP pueden conectarse entre sí
SÓLO dentro de la red a que pertenecen. No hay conflictos porque las redes están
separadas. Igual que no los hay entre dos direcciones físicas iguales de
ciudades distintas.

===================
Saber la ip pública
===================

Una forma de averigar esa ip pública es haciendo uso del comando curl. Si no
tenéis instalado el paquete habrá que instalarlo.

$ sudo apt-get install curl

Nos mostrará nuestra ip pública.

$ curl ifconfig.me

-----

Saber más datos de mi ISP y mí ip pública

$ curl ipinfo.io

{
  "ip": "186.10.126.11",
  "hostname": "186-10-126-11.genericrev.cantv.net",
  "city": "Caracas",
  "region": "Caracas",
  "country": "VE",
  "loc": "8.5792,-75.1571",
  "org": "AS5748 CANTV Servicios, Venezuela",
  "timezone": "America/Caracas",
  "readme": "https://ipinfo.io/missingauth"
}

-----

Desmontar un dispositivo, pendrive, disco externo etc.

$ user@debian:/media$ umount nombre_device

Muestra usuarios conectados a nuestra máquina, tambien usado para ver las
conexiones entrantes de un servidor

$ who

Ejemplo:
user tty7         2015-07-28 08:47 (:0)
user pts/0        2015-07-30 14:03 (:0.0)
user pts/1        2015-07-30 17:03 (:0.0)
user pts/2        2015-07-31 14:15 (:0.0)
user pts/3        2015-07-31 12:37 (:0.0)

En este caso son los usuarios conectados a mi máquina, eso quiere decir que
tengo shells abiertos, por lo tanto todos son representados como usuarios, entre
los diversos parametros se puede apreciar la fecha y la hora en que se abrio el
shell, en un servidor seria el momento en que se conecto el usuario
 
Muestra que usuario soy, nombre de usuario.

$ whoami

Nos dira cual usuario somos, si navegamos por los shells abiertos y ejecutamos
el comando nos dira cual usuario es

$ who am i

Ver usuarios conectados

$ who -u

Ejemplo:

user tty7         2015-07-28 08:47  antig       4257 (:0)
user pts/0        2015-07-30 14:03 03:22        8351 (:0.0)
user pts/1        2015-07-30 17:03 03:19        8351 (:0.0)
user pts/2        2015-07-31 14:15 00:08        8351 (:0.0)
user pts/3        2015-07-31 12:37 02:53        8351 (:192.168.0.240)

Aqui observamos que hay una conexion externa a traves de ssh a nuestro servidor
proveniente de la maquina (192.168.0.240) demarcada por el id process 8351 la
cual podemos cancelar con $ kill -9 8351, pero no refusar esa conexion, el
usuario seguirá conectado por ssh.

Acabar con una conexión externa, se envió la señal -9 que indica matar (KILL) el
proceso, la opción -t indica que se basará en un atributo de nombre de terminal
y se indica después el nombre de la terminal en si pts/3. Este es el comando que
sí funciona para  refusar o eliminar conexiones externas. A veces pide su.

$ pkill -9 -t pts/3

Listar los ultimos usuarios conectados

$ last

==================================
Cambiar el pass del usuario y root
==================================

========================
Usuario normal o regular
========================

$ passwd

Nos mostrara lo siguiente:

Cambiando la contraseña de user.
(actual) contraseña de UNIX:******
Introduzca la nueva contraseña de UNIX:*****
Vuelva a escribir la nueva contraseña de UNIX:*****

============
Usuario root
============

Primero nos logeamos como root:

$ su

Luego lo mismo de arriba:

# passwd

Nos pedira que introduzcamos la nueva contraseña y la confirmacion para cambiar
la clave de root

Introduzca la nueva contraseña de UNIX:****** 
Vuelva a escribir la nueva contraseña de UNIX:*****
passwd: contraseña actualizada correctamente

======================================================
Instalacion de programas y paquetes con apt y aptitude
======================================================

Ver el manual de aptitude.

$ man aptitude

-----

Ver el manual de apt-get.

$ man apt-get

-----

Instalar paquetes.

# apt install Nombre_Paquete

-----

Actualizar un paquete unicamente.

# apt install --only-upgrade packagename

-----

Instalar paquetes disponibles desde otro repositorio, en este caso, los de
jessie-backports.

# apt-get install -t jessie-backports Nombre_Paquete

-----

Instalar paquetes, otra forma usando el programa aptitude

# aptitude install Nombre_Paquete

-----

Intentará satisfacer las dependencias de compilación de un paquete fuente, el
comando build-dep busca en los repositorios locales en el sistema e instala las
dependencias de construcción para el paquete. Si el paquete no existe en el
repositorio local se devolverá un código de error.

# apt-get build-dep Nombre_Paquete

-----

Hace una simulacion de la instalacion, podemos ver que procesos haría la
instalación.

$ aptitude install -s Nombre_Paquete

-----

Simulacion de instalacion con apt-get install.

# apt-get install -s Nombre_Paquete

-----

El -y Supone una respuesta afirmativa a todas las preguntas, de esta forma
apt-get se ejecuta sin necesidad de intervención posterior para tomar
decisiones, usar con cuidado.

# apt-get install -y package

-----

Descargar las fuentes del paquete, para compilar e instalar.

$ apt-get source Nombre_paquete

-----

Realizar una busqueda en los repositorios del paquete que se quiere encontrar

$ sudo aptitude search Nombre_Paquete

-----

Para ver la informacion del paquete, version, estado, tamaño, conflictos,
dependencias, etc.

$ aptitude show Nombre_Paguete

-----

Ver informacion del paquete, version, dependencias, descripcion, tamaño, entre
otros.

$ apt-cache show nombre_paquete

-----

Buscar un paquete en los repositorios.

$ apt-cache search nombre_paquete

-----

Muestra las versiones de los paquetes listados en la línea de órdenes.

$ aptitude versions nombre_paquete

-----

Elimina o Desinstala el paquete.

# aptitude remove Nombre_paquete

-----

Elimina el paquete y sus archivos de configuracion.

# aptitude purge Nombre_Paquete

-----

Descarga el fichero .deb del paquete dado al directorio actual.

$ aptitude download nombre_paquete

-----

Descarga el fichero .deb del paquete dado al directorio actual.

$ apt-get download nombre_paquete

-----

Reinstalar un paquete

# aptitude reinstall nombre_paquete

-----

Actualizar la lista de paquetes disponibles.

$ aptitude update

-----

Saber si un paquete está instalado y su version.

$ sudo dpkg -l | grep nombre_paquete

sudo: Ejecuta el comando con privilegios de superusuario o administrador. Es
necesario cuando se requieren permisos elevados.

dpkg -l: Este comando lista todos los paquetes instalados en el sistema. dpkg es
el sistema de gestión de paquetes en Debian y derivados (como Ubuntu), y la
opción -l muestra un listado de todos los paquetes instalados junto con su
estado.

| grep nombre_paquete: El símbolo | es un pipe, que redirige la salida del
comando anterior (dpkg -l) como entrada para el siguiente comando (grep). grep

nombre_paquete busca en la lista generada por dpkg -l cualquier línea que
contenga el texto nombre_paquete. Esto se utiliza para filtrar los resultados y
mostrar solo los paquetes cuyo nombre o descripción coincida con name_package.

Resumen: Este comando se usa para verificar si un paquete específico
(nombre_paquete) está instalado en el sistema Debian, mostrando detalles del
paquete si se encuentra instalado.

Fuente
======

ChatGPT

-----

Borra los paquetes huérfanos, o las dependencias que quedan instaladas después
de haber instalado una aplicación y luego eliminarla, por lo que ya no son
necesarias.

# apt-get autoremove

-----

Saber la version de algun paquete que tengamos instalado.

$ xxx --version

Ejemplo:
bash --version
gcc --version
python --version
ruby --version

-----

El indicador '~c' se refiere a los paquetes que han sido marcados como
"configurados pero no utilizados". Es decir, estos son los paquetes que están
instalados en tu sistema, pero no se están utilizando actualmente. Pueden haber
sido instalados como dependencias de otros paquetes que ya no están en uso.

La salida de aptitude search '~c' mostrará una lista de paquetes que cumplen con
esta descripción.

$ aptitude search '~c'

Si decides que ya no necesitas ninguno de estos paquetes, puedes usar aptitude
purge para eliminar los paquetes y sus archivos de configuración del sistema.

-----

Para listar los paquetes rotos en Debian, puedes usar el comando apt-get en
lugar de aptitude. Aquí hay un comando que puedes usar:

$ sudo apt-get check

Este comando verifica la integridad de los paquetes de la base de datos de
paquetes. Si hay paquetes rotos, el comando mostrará un mensaje de advertencia y
te pedirá que ejecutes sudo apt-get install -f para arreglarlos.

=========================
Liberando espacio con apt
=========================

APT (Advanced Packaging Tool) Herramienta Avanzada de Empaquetado es un sistema
gestor de paquetes creado por el proyecto Debian. Esta herramienta se encarga de
facilitarle al usuario las tareas de instalación y eliminación de programas en
los sistemas GNU/Linux (distribuciones derivadas de Debian).

Esta herramienta se compone de dos programas principalmente: apt-get y
apt-cache, para estos programas podemos encontrar programas frontend, me refiero
a programas con una interfaz gráfica que facilita el uso de apt como es
Aptitude, Synaptic, Adept, Ubuntu Software Center, etc.

Apt instala paquetes .deb para los sistemas debian y distribuciones derivadas,
instalar un programa con esta herramienta es tan sencillo como escribir:

$ apt-get install <nombre_del_programa>

Donde <nombre_del_programa> lo sustituimos por el nombre del programa que
deseamos instalar.

Si queremos por ejemplo instalar GIMP, un programa para la manipulación de
imágenes, se haría de la siguiente manera:

$ sudo apt-get install gimp

================================
Comprobando el espacio utilizado
================================

Los archivos .deb que apt-get descarga de los repositorios, son almacenados en
nuestra máquina antes de comenzar el proceso de instalación, y a veces hace
falta hacer limpieza de estos archivos (ojo, al realizar los siguientes 3 pasos
para liberar espacio, liberaremos espacio sin desinstalar programas, solo
borraremos los instaladores, caché de .deb almacenados localmente); Los archivos
son almacenados en la siguiente ruta cuando van a ser instalados
/var/cache/apt/archives podemos ver cuánto espacio están utilizando estos
archivos en nuestro disco con:

$ du -hs /var/cache/apt/archives

du es un comando que nos permite ver el Disk Usage (espacio utilizado en disco).
3 Pasos para liberar espacio

1- Para liberar el espacio primero haremos un autoclean, esta opción borra todo
el caché de los paquetes .deb de paquetes de versiones anteriores y de los
programas que ya han sido instalados en nuestro sistema:

$ sudo apt-get autoclean

2- El siguiente comando con la opción clean borra todos los paquetes .deb, si
queremos instalar de nuevo un programa el archivo .deb necesitará ser descargado
nuevamente de los repos:

$ sudo apt-get clean

3- Por último el siguiente comando con la opción autoremove borra todos los
paquetes dependencias de otros programas:

$ sudo apt-get autoremove

Comprobando el espacio libre nuevamente

Ahora que hemos liberado el espacio, podemos comprobar nuevamente el tamaño de
la carpeta que apt usa para almacenar todos los archivos como caché:

$ du -hs /var/cache/apt/archives

==========================================
Mantener tu sistema Debian o Ubuntu limpio
==========================================

$ sudo apt-get update

Este comando actualiza la lista de paquetes disponibles en los repositorios
configurados en tu sistema. No instala ni actualiza ningún paquete; solo
descarga la información más reciente sobre los paquetes, lo que permite al
sistema saber qué versiones están disponibles para instalar o actualizar. Es un
comando que se recomienda ejecutar antes de instalar o actualizar software.

-----

$ sudo apt-get autoclean:

Este comando elimina los archivos .deb (paquetes descargados) que ya no son
necesarios en el caché del sistema, específicamente los que ya no están
disponibles para descargar de los repositorios actuales. Esto ayuda a liberar
espacio en el disco eliminando archivos que ya no pueden ser reinstalados o que
han sido actualizados a nuevas versiones.

-----

$ sudo apt-get clean:

Este comando elimina todos los archivos .deb de la caché local, es decir, los
paquetes descargados para la instalación o actualización. Después de ejecutar
este comando, si deseas reinstalar un paquete, tendrá que ser descargado de
nuevo desde los repositorios.

-----

$ sudo apt-get autoremove:

Este comando elimina automáticamente los paquetes que se instalaron como
dependencias de otros paquetes, pero que ya no son necesarios. Esto suele
ocurrir cuando desinstalas un paquete que tenía dependencias, pero esas
dependencias no son usadas por ningún otro paquete instalado en tu sistema.

En resumen, estos comandos te ayudan a mantener tu sistema Debian o Ubuntu
limpio y ordenado, eliminando archivos innecesarios y paquetes obsoletos.

Fuente
======

ChatGPT

===============================
Comprimir/Descomprimir archivos
===============================

tar se refiere a un formato de archivos ampliamente usado en entornos UNIX
identificados por el sufijo de archivo .tar.. Además hace referencia al programa
para la manipulación de archivos que es estándar en estos entornos, pero no
incluye la compresión de los mismos.

Comprimir un directorio, le damos los parametros de compresion, así como el
nombre del paquete y el directorio que vamos a comprimir.

$ tar -cvf paquete.tar nombre_directorio 

-c : indica a tar que cree un archivo
-x : extraer un archivo
-t : listar los contenidos de un archivo
-v : indica a tar que muestre lo que va empaquetando.
-f : indica a tar que el siguiente argumento es el nombre del fichero.tar
-z : comprimir a la vez que se empaqueta

Crear un paquete con el nombre que le dimos y contiene el archivo.txt

$ tar -cvf paquete.tar archivo.txt

Descomprimir un paquete

$ tar -xvf paquete.tar

=============================
Descomprimir paquetes.tar.bz2
=============================

$ tar -xjvf example.tar.bz2

=================
Ficheros .tar.gz
=================

Comprimir un directorio

$ tar -czvf paquete.tar.gz nombre_directorio

Comprimir un fichero

$ tar -czvf paquete.tar.gz nombre_fichero.xxx

Descomprimir

$ tar -xzvf paquete.tar.gz

============
Ficheros .gz
============

Comprimir

$ gzip -9 ficehro.txt

Descomprimir

$ gzip -d fichero.gz

====================
Descomprimir .tar.xz
====================

$ tar Jxvf fichero.tar.xz

-------------

Cuando nos iniciamos en Linux y buscamos un programa lo normal es que
encontremos un .deb o .rpm y en muchos casos nos encontramos programas con la
extensión .tar.gz y .tar.bz2, estos archivos están comprimidos y por lo general
contienen aparte del programa unas instrucciones para instalarlo.

La instalación para estos dos tipos de paquetes es exactamente igual, primero
entramos a la carpeta donde tengamos el archivo.

$ cd directorio

$ tar -zxvf nombredelarchivo.tar.gz

$ tar -jxvf nombredelarchivo.tar.bz2

Configuramos, con esta accion se configurara el paquete para la posterior
compilacion, si hacen falta paquetes "dependencias" para la compilacion por lo
general mostrara que paquetes faltan y fallará la configuracion.

$ ./configure

Hacemos make (compilamos)

$ make

Ahora make install

$ make install

====================
Descomprimir con RAR
====================

Necesitamos instalar unrar.

$ aptitude search unrar

Si no lo encuentra debemos bajar el source de http://www.unrarlib.org/ Nos
bajara unrarsrc-3.7.8.tar.gz

Descomprimimos, nos dejara la carpeta (unrar)

$ cd unrar

luego:

$ make -f makefile.unix

# install -v -m755 unrar /usr/bin

Ya deberíamos poder descomprimir .rar

Uso: unrar [OPTION...] ARCHIVE [FILE...] [DESTINATION]
-x, --extract              Extract files from archive (default)
-t, --list                 List files in archive
-f, --force                Overwrite files when extracting
--extract-newer        Only extract newer files from the archive
--extract-no-paths     Don't create directories while extracting
-p, --password             Decrypt archive using a password
-?, --help                 Give this help list
--usage                Give a short usage message
-V, --version              Print program version

Ejemplo:

Para descomprimir un fichero .rar.

$ unrar x archivo.rar

Para descomprimir un fichero .rar dando la ruta.

$ unrar x archivo.rar /home/user/carpeta

===============================
Comprimir/ Descomprimir con ZIP
===============================

Instalar el paquete de zip.

$ sudo aptitude install zip

Comprimir un fichero.

$ zip archivo.zip nombre_fichero.xxx

Descomprimir el fichero.

$ unzip archivo.zip

Comprimir directorios y su contenido.

$ zip -r carpeta.zip nombre_carpeta

Comprimir un directorio con contraseña
======================================

Para comprimir un directorio en un archivo ZIP protegido con contraseña, usa el
siguiente comando:

$ zip -r -e archivo_comprimido.zip directorio

-r: Comprime el directorio de manera recursiva (incluyendo todos los archivos y
subdirectorios).

-e: Solicita una contraseña para cifrar el archivo ZIP.

archivo_comprimido.zip: Nombre del archivo ZIP que se generará.

directorio/: Ruta del directorio que deseas comprimir.

Nota:

Fuerza de la contraseña: El cifrado usado por zip no es el más seguro (usa ZIP
2.0 encryption). Si necesitas un cifrado más robusto, considera usar
herramientas como 7z con el formato .7z y cifrado AES-256.

Fuente
======

Deepseek

=================
7zip en GNU/Linux
=================

Instalación:

$ sudo apt install p7zip p7zip-full

Descomprimir:

$ 7z e archivo.7z

Comprimir:

$ 7z a file.7z foto.jpeg

Comprimir directorio:

$ 7z a file.7z nombre_carpeta

Comprimir con 7z con contraseña
===============================

Si prefieres usar 7z para mayor seguridad, el comando sería:

$ 7z a -p -mhe=on archivo_comprimido.7z directorio

-p: Solicita una contraseña.

-mhe=on: Cifra también los nombres de los archivos (opcional).

Dividir archivo en partes
=========================

1. Comprimir el archivo en partes:

Usa el comando 7z con la opción -v para dividir el archivo comprimido en partes
del tamaño que desees. Por ejemplo, si quieres que cada parte sea de 500 MB (o
cualquier tamaño que elijas), puedes usar:

$ 7z a -v500M video_partes.7z video.mp4

a: Añade el archivo video.mp4 al archivo comprimido.

-v500M: Divide el archivo comprimido en partes de 500 MB cada una.

video_partes.7z: Nombre base del archivo comprimido.

video_partes.7z.001
video_partes.7z.002
video_partes.7z.003

2. Unir las partes comprimidas:

Para unir las partes y reconstruir el archivo comprimido original, puedes usar
el comando cat en Linux:

$ cat video_partes.7z.001 video_partes.7z.002 video_partes.7z.003 > video_partes.7z

cat: Concatena los archivos en orden.

video_partes.7z.001 video_partes.7z.002 video_partes.7z.003: Las partes que deseas unir.

> video_partes.7z: Redirige la salida a un archivo único.

3. Descomprimir el archivo unido:

Una vez que hayas unido las partes en un solo archivo .7z, puedes descomprimirlo
con:

$ 7z x video_partes.7z

x: Extrae el contenido del archivo .7z.

Resumen de comandos:

Comprimir en partes:

$ 7z a -v500M video_partes.7z video.mp4

Unir las partes:

$ cat video_partes.7z.001 video_partes.7z.002 video_partes.7z.003 > video_partes.7z

Descomprimir:

$ 7z x video_partes.7z

Notas adicionales:

Tamaño de las partes: Ajusta el tamaño de las partes cambiando el valor de -v.
Por ejemplo, -v200M para partes de 200 MB.

Verificación: Si quieres verificar la integridad de las partes antes de unirlas,
puedes usar:

$ 7z t video_partes.7z.001

Esto verificará la primera parte y, por extensión, las demás.

============================================
Comprimir una carpeta o directorio en Partes
============================================

1. Comprimir la carpeta en partes:

Supongamos que tienes una carpeta llamada mi_carpeta y quieres comprimirla en
partes de 100 MB cada una. Usa el siguiente comando:

$ 7z a -v100m mi_carpeta_partes.7z mi_carpeta/

a: Añade los archivos al archivo comprimido.

-v100m: Divide el archivo comprimido en partes de 100 MB.

mi_carpeta_partes.7z: Nombre base del archivo comprimido.

mi_carpeta/: Ruta de la carpeta que deseas comprimir.

Esto generará archivos como:

mi_carpeta_partes.7z.001
mi_carpeta_partes.7z.002
mi_carpeta_partes.7z.003
...

2. Verificar las partes generadas:

Puedes listar los archivos generados para asegurarte de que todo esté correcto:

$ ls -lh mi_carpeta_partes.7z.*

3. Unir las partes (opcional):

Si necesitas unir las partes para descomprimir la carpeta, puedes usar el
comando cat:

$ cat mi_carpeta_partes.7z.001 mi_carpeta_partes.7z.002 mi_carpeta_partes.7z.003
> mi_carpeta.7z

Luego, descomprime el archivo unido:

$ 7z x mi_carpeta.7z

5. Descomprimir las partes directamente:

Si no quieres unir las partes manualmente, puedes descomprimirlas directamente
con 7z. Solo necesitas indicar la primera parte:

$ 7z x mi_carpeta_partes.7z.001

7z detectará automáticamente las partes restantes y descomprimirá todo.

Ejemplo completo:

Si tienes una carpeta llamada proyecto y quieres comprimirla en partes de 50 MB,
usa:

$ 7z a -v50m proyecto_partes.7z proyecto

Esto generará archivos como proyecto_partes.7z.001, proyecto_partes.7z.002, etc.

Notas adicionales:

Tamaño de las partes: Puedes ajustar el tamaño de las partes cambiando el valor
de -v. Por ejemplo:

-v100m: Partes de 100 MB.

-v1g: Partes de 1 GB.

Cifrado con contraseña: Si deseas proteger el archivo comprimido con una
contraseña, añade la opción -p:

$ 7z a -v100m -p mi_carpeta_partes.7z mi_carpeta/

Te pedirá que ingreses y confirmes una contraseña.

Fuentes
=======

https://weblinus.com/como-instalar-7zip-en-linux/

Deepseek

===================================================================
Proteger un archivo ZIP con contraseña mediante la línea de comando
===================================================================

$ zip -er nombre-archivo.zip carpeta-a-comprimir

===================
Terminal Terminator
===================

Gran herramienta para los desarrolladores, permite abrir multiples terminales
y poder ordenarlos, muy personalizable, entre muchas otras cosas.
**RECOMENDADO**.

Paquete: terminator / multiple GNOME terminals in one window.

Para instalarlo

# apt-get install terminator

Dentro de Terminator:

Abrir un terminal horizontal y paralelo

Ctrl + Shift + o

Abrir un terminal vertical y paralelo

Ctrl + Shift + e

Abrir una nueva pestaña en el terminal

Ctrl + Shift + t

Moverse por los terminales

Alt + flechas

Cerrar un terminal

Ctrl + Shift + w

Maximizar un terminal, igual para salir

Ctrl + Shift + x

Maximizar un terminal(aumentado), igual para salir

Ctrl + Shift + z

Cambiar el tamaño a voluntad de un terminal

Ctrl + Shift + flechas

Aumentar tamaño de fuente, el (+) del Qwerty

Ctrl + (+)

Minimizar tamaño de fuente, el (-) del Qwerty

Ctrl + (-)

Si no hay sesion de usuario abierta, como root y otros cerrará la pestaña o
ventana.

Ctrl + d

Pantalla completa.

f11

=========================
DIA - Editor de diagramas
=========================

Es un editor de diagramas, grafos, gráficas, etc. Ofrece soporte para diagramas
de estructuras estáticas en UML (diagramas de clases), diagramas de
Entidad-Relación, diagramas de redes y mucho más.

Los diagramas se pueden exportar a postscript y a otros formatos.

$ aptitude install dia

====
Meld
====

Es una herramienta gráfica para hacer archivos diff y fusionarlos.

Permite al usuario ver los cambios entre, y fusionar, dos archivos, dos
directorios, o dos archivos con un ancestro común.

# apt install meld

========================
Editor de texto VI o VIM
========================

Es un editor de texto poderoso, muy usado en la comunidad de desarrolladores de
Software Libre para escribir scripts, modificar ficheros de texto en el shell,
programar etc. No posee botones y todas sus funcionalidades se usan a traves de
comandos.

Por lo general viene preinstalado en la mayoria de distribuciones, si no es así
solo basta con un:

# apt-get install vim

============
Modos de uso
============

Al entrar a VIM para editar un fichero por primera vez, estamos en modo de
comandos, quiere decir que no podemos editar el texto sino que solo podremos
sar comandos.

Abrir vim, un fichero en blanco sin nombre ni contenido.

$ vim

Tecleamos i para entrar en modo de edicion, podemos insertar texto.

i

Pulsamos la tecla escape para salir del modo edicion o de cualquier otro modo,
y volvemos al modo comandos.

escape

En modo comandos escribimos :q para salir del editor sin guardar.

:q

Salir del editor sin guardar ni pedir confirmacion.

:q!

Guardamos un fichero nuevo, le asignamos el nombre y la extension si es
necesario.

:w nombre_fichero.xxx

Nos aparecerá una ventana en negro, donde nos aparecerá el contenido del fichero
o en negro si está vacío.

En la parte inferior, nos aparecerán los mensajes o comandos que escribamos
para manejar el editor, así como la línea en la que estamos, porcentaje del
fichero, etc.

vim nombre_archivo.xxx

Guardar un documento.

:w

Guardar y salir, esta accion aplica a un fichero ya creado, que estemos
editando.

:wq!

Para saber el nombre y extensión del fichero abierto.

:f

Deshacer el ultimo cambio.

u

Rehacer el ultimo cambio.

Ctrl + R

Copiar la linea.

yy

Eliminar una linea, en tal caso la corta y esta lista para pegarse.

dd

Pegar una linea cortada.

p

Convertir la linea actual en minusculas.

guu

Convertir la linea actual en mayusculas.

gUU

Ir al principio del archivo.

g

Ir al final del documento.

G

Navegar palabra por palabra en el fichero.

w

Entra en modo Visual. En este modo seleccionaremos un texto con los cursores, y
después podremos cortar, copiar y pegar con los comandos:  

Copiar: y

Copiar el texto seleccionado en modo visual (de "yank".)

Cortar: c

Cortar el texto seleccionado en modo visual.

Pegar: p

Pegar el texto copiado o cortar en modo visual con anterioridad. 

v

Para hacer una busqueda de una palabra dentro del archivo.

:/palabra

Para ir a la siguiente coincidencia.

n

Para ir a la coincidencia anterior.

N

Enumerar las líneas del fichéro.

:set nu

Si queremos que se enumeren siempre las lineas editamos el fichero:

# vim /etc/vim/vimrc

y quitámos las comillas (") a la línea que tiene a set number y guardamos.

Ir a la linea (x) donde 123 es el número de linea a la cual queremos ir.

:123

Sirve para dar color al codigo que estemos editando, VIM reconoce la sintaxis de
muchos lenguajes y la resalta en colores como muchos otros editores graficos
como gedit, sublime, ninja, komodo, Geany.

:syntax on

Quitamos las (") para que quede activado directamente la coloracion de codigos

En /etc/vim en el fichero vimrc descomentamos la linea "syntax on

===============================
Configurar el localhost / hosts
===============================

En el fichero /etc/hosts está configurado el localhost de la máquina, el
contenido puede ser parecido a:

---

127.0.0.1      localhost
127.0.1.1       debian8.debian8 debian8

---

Esto quiere decir que cuando accedamos desde el navegador a "localhost"
entonces estaremos accediento a 127.0.0.1.

Para hacer una prueba agregaremos y comentaremos una línea al fichero:

---

#127.0.0.1      localhost
127.0.1.1       debian8.debian8 debian8
127.0.0.1        www.x.x

---

Lo que hicimos es cambiar localhost por una url arbitraria, ahora si accedemos a
www.x.x accederemos a 127.0.0.1

===========================================
Bloquear acceso localmente a una página web
===========================================

$ ping www.pagina_a_bloquear.com

Eso va a hacer ping o enviar paquetes a esa web y nos mostrara la ip pública del
sitio, es decir un número con este formato: 111.222.333.444

Ahora, con esa ip hacemos lo siguiente:

Para bloquear el acceso a esa página

# iptables -I INPUT -s 111.222.333.444 -j DROP

Para habilitar el acceso a esa página

# iptables -I INPUT -s 111.222.333.444 -j ACCEPT

==========
Otra forma
==========

Para bloquear sitios vamos a modificar el archivo hosts, abrimos un terminal y
escribimos la siguiente linea de comando:

Como super usuario abrimos el fichero /etc/hosts con el editor gedit, puede ser
nano vi, vim, u otro.

# gedit /etc/hosts

Ahora para bloquear en este ejemplo a Instagram, vamos a escribir al principio
del archivo:

127.0.0.1 instagram.com
127.0.0.1 www.instagram.com

Guardamos y listo.

==========================
Editar el hosts en Windows
==========================

El hosts permite redirigir nombres de dominio a IPs específicas sin depender de
servidores DNS, útil para pruebas locales de servidores, bloquear sitios web,
acceder a recursos internos de red con nombres personalizados.

Nota: Probado en 7 y 10

Editamos como administradores con el blog de notas el fichero que está en:

C:\Windows\system32\drivers\etc\hosts

Nos encontraremos con algo como esto:

127.0.0.1       localhost
127.0.0.1       localhost
127.0.0.1       localhost

Agrega las entradas necesarias al final del archivo, siguiendo este formato:

[IP del servidor]    [nombre de dominio]

Ejemplo:

192.168.1.100    kavac.iahula.com

Guardamos y listo, al entrar a kavac.iahula.com deberíamos ver lo que se sirve
desde 192.168.1.100

======================================================
Bloquear acceso localmente a una página web en Windows
======================================================

Probado en 7

Editamos con el blog de notas el fichero que está en:

C:\Windows\system32\drivers\etc\hosts

Nos encontraremos con algo como esto:

127.0.0.1       localhost
127.0.0.1       localhost
127.0.0.1       localhost

Para bloquear una página, solamente agregamos un par de lineas al final del
fichero Por ejemplo, vamos a bloquear a instagram, entonces quedaría así:

127.0.0.1       localhost
127.0.0.1       www.instagram.com
127.0.0.1       instagram.com

Guardamos y listo, podemos agregar tantas webs como queramos.

====================================
Generar certificado ssl auto-firmado
====================================

Para establecer una conexión segura y de confianza es necesario generar
certificados que respalden la identidad del servidor. Estos certificados son
generalmente emitidos por entidades certificadoras (Certificate Authority)
independientes y de confianza reconocida. Sin embargo, para una utilización más
casera y económica, es posible crear un certificado "auto-firmado".

Hay que configurar el sitio a proteger en /etc/hosts, esto es opcional muy
específico e independiente del manual que continúa.

=====================
Instalar dependencias
=====================

# aptitude install openssl ca-certificates

Generar la clave RSA

$ openssl genrsa -des3 -out x.gob.ve.key 1024

ó 2048

Generar CSR (Petición de Firma de Certificado)

$ openssl req -new -key x.gob.ve.key -out x.gob.ve.csr

Esto realiza una petición para la firma con la clave privada especificada al
realizarlo nos pide algunos datos que tendrá el certificado algunos los podemos
omitir.

El "Common Name" que nos pide debe corresponder con la URL que queremos
Securizar. Si la URL a poner por https es x.gob.ve, este campo debe contener
exactamente eso.

Generar Certificado Autofirmado

$ openssl x509 -req -days 365 -in x.gob.ve.csr -signkey x.gob.ve.key -out x.gob.ve.crt

Al final nos Deben quedar 3 ficheros: .cert, .crs, .key
x.gob.ve.crt ***Este es el certificado final***
x.gob.ve.csr
x.gob.ve.key

======================================================================
Generar un certificado electrónico autofirmado en formato PKCS#12 .p12
======================================================================

El certificado en formato PKCS#12 es un archivo de almacén de clave que incluye
certificado(s), y clave privada(s) cifradas por una contraseña (frase de paso)
elegida por el usuario. El certificado autofirmado no es emitido por alguna
autoridad o proveedor de servicio de certificado, si no que puede ser construido
y avalado por una misma persona.

1) Instalación de la librería OPENSSL.

$ sudo aptitude install openssl

2) Crear una clave privada y pública RSA. El RSA es un algoritmo criptográfico
para la generación de claves utilizadas en firmas electrónicas. Para generar las
claves RSA se ejecuta el siguiente comando:

$ openssl genrsa -out localhost.key

La ejecución del comando anterior genera la clave privada y la almacena en un
archivo llamado localhost.key en el directorio donde se ejecutó el comando
(verificar la existencia del archivo).

3) Crear un certificado autofirmado con el estándar x509. El estándar X509
esencialmente se usa para la verificación de emisión de certificado dentro de la
jerarquía de autoridades certificantes. Para este ejemplo no se requiere
verificar que autoridades lo emitieron porque es un certificado autofirmado,
pero se necesita que dicho certificado este bajo ese estándar.

Para crear este certificado se ejecuta el siguiente comando:

$ openssl req -new -x509 -days 1825 -key localhost.key -out localhost.crt

Donde se indica que genere un nuevo certificado (openssl req -new) con los
siguientes parámetros:

-Estándar: ( -x509 )

-Días de duración del certificado:( -days 1825 )

-Clave privada, nombre del archivo donde esta almacenado: ( -key localhost.key )

-Nombre del archivo donde se almacenara el certificado:( -out localhost.crt )

Al ejecutar el comando se solicita la información que contendrá el certificado:

-Country Name (2 letter code) [AU]:
-State or Province Name (full name) [Some-State]:
-Locality Name (eg, city):
-Organization Name (eg, company) [Internet Widgits Pty Ltd]:
-Organizational Unit Name (eg, section):
-Common Name (e.g. server FQDN or YOUR name):
-Email Address:

La ejecución del comando anterior genera el certificado asociado a la clave
indicada y con información ingresada al momento de su generación.

El certificado se guarda en el archivo con el nombre localhost.crt en el
directorio donde se ejecutó el comando (verificar la existencia del archivo).

4) Crear un certificado en formato PKCS#12: Como ya se tiene la clave privada y
el certificado asociado a dicha clave (generada en las secciones anteriores), se
procede a generar un certificado en formato PKCS#12 ejecutando el siguiente
comando:

$ openssl pkcs12 -export -inkey localhost.key -in localhost.crt -out localhost.p12

Donde se le indica que exporte ( -export ) los siguientes parámetros:

-La clave privada ( -inkey localhost.key )
-Certificado autofirmado ( -in localhost.crt ) asociado a la clave privada
-Nombre del archivo donde se almacena el certificado ( -out localhost.p12 )

La ejecución del comando anterior solicita que ingresa una contraseña (frase de
paso), luego se genera el certificado en formato PKCS#12 y se guarda en el
archivo con el nombre localhost.p12 el directorio donde ejecuto el comando
(verificar la existencia del archivo).

Con todos estos pasos ya se dispone de un certificado autofirmado en formato
PKCS#12 almacenado en el archivo localhost.p12. Al hacer doble clic sobre el
archivo localhost.p12 se levanta una ventana solicitando la contraseña o frase
de paso para poder acceder a la información. Al ingresar la contraseña o frase
de paso mostrara toda la información referente a dicho certificado.

Fuentes
=======

Curso en línea de Firma electrónica con Murachí de CENDITEL.

==============================================================
Generar un certificado .p12 con curva elíptica en Debian Linux
==============================================================

Para generar un certificado .p12 (PKCS#12) usando criptografía de curva elíptica
(ECC), sigue estos pasos:

1. Generar una clave privada ECC

Usa openssl para crear una clave privada con un algoritmo de curva elíptica
(ej: secp384r1 o prime256v1):

$ openssl ecparam -name secp384r1 -genkey -noout -out clave-privada-ecc.key

Opciones comunes de curvas:

-prime256v1 (NIST P-256, ampliamente compatible).

-secp384r1 (NIST P-384, mayor seguridad).

-secp521r1 (NIST P-521, aún más robusta).

2. Generar un CSR (Certificate Signing Request)

Crea una solicitud de firma para tu clave ECC:

$ openssl req -new -key clave-privada-ecc.key -out solicitud.csr

Se te pedirá ingresar datos como país, organización, etc.

3. Opciones para el certificado:

Auto-firmarlo (para pruebas):

$ openssl req -x509 -key clave-privada-ecc.key -in solicitud.csr -out certificado-ecc.crt -days 365

Obtenerlo firmado por una CA (ej: Let's Encrypt):

Envía el .csr a tu entidad certificadora.

4. Generar el archivo .p12

Combina la clave privada y el certificado en un PKCS#12:

$ openssl pkcs12 -export -inkey clave-privada-ecc.key -in certificado-ecc.crt -out certificado-ecc.p12

Te pedirá una contraseña para proteger el archivo .p12.

5. Verificar el contenido del .p12

$ openssl pkcs12 -info -in certificado-ecc.p12

Notas importantes:

-Compatibilidad: Asegúrate que los sistemas/clientes soporten ECC (la mayoría
modernos sí).

-Rendimiento: Las claves ECC son más eficientes que RSA para un mismo nivel de
seguridad.

-Herramientas alternativas: Si usas certbot (Let's Encrypt), añade el flag
--key-type ecdsa para generar certificados ECC automáticamente.

Fuente
======

DeepSeek

=====================================================
Creación de claves de curva elíptica mediante OpenSSL
=====================================================

Probado En Debian 12.11
Paquete: openssl
Versión: 3.0.16-1~deb12u1

1) Instalación de la librería OPENSSL.

$ sudo aptitude install openssl

2) Generación de una clave privada de curva elíptica mediante OpenSSL

Para empezar, deberá elegir la curva con la que trabajará. Puede usar el
siguiente comando para ver una lista de nombres y descripciones de curvas
compatibles.

$ openssl ecparam -list_curves

  secp112r1 : SECG/WTLS curve over a 112 bit prime field
  secp112r2 : SECG curve over a 112 bit prime field
  secp128r1 : SECG curve over a 128 bit prime field
  secp128r2 : SECG curve over a 128 bit prime field
  secp160k1 : SECG curve over a 160 bit prime field
  secp160r1 : SECG curve over a 160 bit prime field
  secp160r2 : SECG/WTLS curve over a 160 bit prime field
  secp192k1 : SECG curve over a 192 bit prime field
  secp224k1 : SECG curve over a 224 bit prime field
  secp224r1 : NIST/SECG curve over a 224 bit prime field
  secp256k1 : SECG curve over a 256 bit prime field
  secp384r1 : NIST/SECG curve over a 384 bit prime field
  secp521r1 : NIST/SECG curve over a 521 bit prime field
  prime192v1: NIST/X9.62/SECG curve over a 192 bit prime field
  prime192v2: X9.62 curve over a 192 bit prime field
  prime192v3: X9.62 curve over a 192 bit prime field
  prime239v1: X9.62 curve over a 239 bit prime field
  prime239v2: X9.62 curve over a 239 bit prime field
  prime239v3: X9.62 curve over a 239 bit prime field
  prime256v1: X9.62/SECG curve over a 256 bit prime field
  sect113r1 : SECG curve over a 113 bit binary field
  sect113r2 : SECG curve over a 113 bit binary field
  sect131r1 : SECG/WTLS curve over a 131 bit binary field
  sect131r2 : SECG curve over a 131 bit binary field
  sect163k1 : NIST/SECG/WTLS curve over a 163 bit binary field
  sect163r1 : SECG curve over a 163 bit binary field
  sect163r2 : NIST/SECG curve over a 163 bit binary field
  sect193r1 : SECG curve over a 193 bit binary field
  sect193r2 : SECG curve over a 193 bit binary field
  sect233k1 : NIST/SECG/WTLS curve over a 233 bit binary field
  sect233r1 : NIST/SECG/WTLS curve over a 233 bit binary field
  sect239k1 : SECG curve over a 239 bit binary field
  sect283k1 : NIST/SECG curve over a 283 bit binary field
  sect283r1 : NIST/SECG curve over a 283 bit binary field
  sect409k1 : NIST/SECG curve over a 409 bit binary field
  sect409r1 : NIST/SECG curve over a 409 bit binary field
  sect571k1 : NIST/SECG curve over a 571 bit binary field
  sect571r1 : NIST/SECG curve over a 571 bit binary field
  c2pnb163v1: X9.62 curve over a 163 bit binary field
  c2pnb163v2: X9.62 curve over a 163 bit binary field
  c2pnb163v3: X9.62 curve over a 163 bit binary field
  c2pnb176v1: X9.62 curve over a 176 bit binary field
  c2tnb191v1: X9.62 curve over a 191 bit binary field
  c2tnb191v2: X9.62 curve over a 191 bit binary field
  c2tnb191v3: X9.62 curve over a 191 bit binary field
  c2pnb208w1: X9.62 curve over a 208 bit binary field
  c2tnb239v1: X9.62 curve over a 239 bit binary field
  c2tnb239v2: X9.62 curve over a 239 bit binary field
  c2tnb239v3: X9.62 curve over a 239 bit binary field
  c2pnb272w1: X9.62 curve over a 272 bit binary field
  c2pnb304w1: X9.62 curve over a 304 bit binary field
  c2tnb359v1: X9.62 curve over a 359 bit binary field
  c2pnb368w1: X9.62 curve over a 368 bit binary field
  c2tnb431r1: X9.62 curve over a 431 bit binary field
  wap-wsg-idm-ecid-wtls1: WTLS curve over a 113 bit binary field
  wap-wsg-idm-ecid-wtls3: NIST/SECG/WTLS curve over a 163 bit binary field
  wap-wsg-idm-ecid-wtls4: SECG curve over a 113 bit binary field
  wap-wsg-idm-ecid-wtls5: X9.62 curve over a 163 bit binary field
  wap-wsg-idm-ecid-wtls6: SECG/WTLS curve over a 112 bit prime field
  wap-wsg-idm-ecid-wtls7: SECG/WTLS curve over a 160 bit prime field
  wap-wsg-idm-ecid-wtls8: WTLS curve over a 112 bit prime field
  wap-wsg-idm-ecid-wtls9: WTLS curve over a 160 bit prime field
  wap-wsg-idm-ecid-wtls10: NIST/SECG/WTLS curve over a 233 bit binary field
  wap-wsg-idm-ecid-wtls11: NIST/SECG/WTLS curve over a 233 bit binary field
  wap-wsg-idm-ecid-wtls12: WTLS curve over a 224 bit prime field
  Oakley-EC2N-3: 
	IPSec/IKE/Oakley curve #3 over a 155 bit binary field.
	Not suitable for ECDSA.
	Questionable extension field!
  Oakley-EC2N-4: 
	IPSec/IKE/Oakley curve #4 over a 185 bit binary field.
	Not suitable for ECDSA.
	Questionable extension field!
  brainpoolP160r1: RFC 5639 curve over a 160 bit prime field
  brainpoolP160t1: RFC 5639 curve over a 160 bit prime field
  brainpoolP192r1: RFC 5639 curve over a 192 bit prime field
  brainpoolP192t1: RFC 5639 curve over a 192 bit prime field
  brainpoolP224r1: RFC 5639 curve over a 224 bit prime field
  brainpoolP224t1: RFC 5639 curve over a 224 bit prime field
  brainpoolP256r1: RFC 5639 curve over a 256 bit prime field
  brainpoolP256t1: RFC 5639 curve over a 256 bit prime field
  brainpoolP320r1: RFC 5639 curve over a 320 bit prime field
  brainpoolP320t1: RFC 5639 curve over a 320 bit prime field
  brainpoolP384r1: RFC 5639 curve over a 384 bit prime field
  brainpoolP384t1: RFC 5639 curve over a 384 bit prime field
  brainpoolP512r1: RFC 5639 curve over a 512 bit prime field
  brainpoolP512t1: RFC 5639 curve over a 512 bit prime field
  SM2       : SM2 curve over a 256 bit prime field

En este ejemplo, estoy usando prime256v1 (secp256r1), que es adecuado para la
firma JWT, esta es la curva utilizada para ES256.

3) Ahora puedes generar una clave privada:

$ openssl ecparam -name prime256v1 -genkey -noout -out private-key.pem

Esto debería proporcionarle un archivo PEM que contiene su clave privada EC, que se parece a lo siguiente:

-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIKEubpBiHkZQYlORbCy8gGTz8tzrWsjBJA6GfFCrQ98coAoGCCqGSM49
AwEHoUQDQgAEOr6rMmRRNKuZuwws/hWwFTM6ECEEaJGGARCJUO4UfoURl8b4JThG
t8VDFKeR2i+ZxE+xh/wTBaJ/zvtSqZiNnQ==
-----END EC PRIVATE KEY-----

4) Creación de una clave pública EC a partir de una clave privada mediante
OpenSSL.

Ahora que tienes tu clave privada, puedes usarla para generar otro PEM, que
contenga solo tu clave pública.

$ openssl ec -in private-key.pem -pubout -out public-key.pem

Esto debería proporcionarle otro archivo PEM, que contiene la clave pública:

-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEOr6rMmRRNKuZuwws/hWwFTM6ECEE
aJGGARCJUO4UfoURl8b4JThGt8VDFKeR2i+ZxE+xh/wTBaJ/zvtSqZiNnQ==
-----END PUBLIC KEY-----

5) Creación de un certificado autofirmado EC mediante OpenSSL

Ahora que tiene una clave privada, puede usarla para generar un certificado
autofirmado. Esto no es obligatorio, pero le permite usar la clave para la
autenticación de servidor/cliente o para obtener funcionalidades específicas de
X509 en tecnologías como JWT y SAML.

$ openssl req -new -x509 -key private-key.pem -out cert.pem -days 360

Esto generará nuevamente otro archivo PEM, esta vez conteniendo el certificado
creado por su clave privada:

-----BEGIN CERTIFICATE-----
MIIB4DCCAYWgAwIBAgIUH53ssiPt4JEGx+VJyntCpHL+TdAwCgYIKoZIzj0EAwIw
RTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoMGElu
dGVybmV0IFdpZGdpdHMgUHR5IEx0ZDAeFw0yMDA3MTgxMTE4NDNaFw0yMTA3MTMx
MTE4NDNaMEUxCzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYD
VQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjO
PQMBBwNCAAQ6vqsyZFE0q5m7DCz+FbAVMzoQIQRokYYBEIlQ7hR+hRGXxvglOEa3
xUMUp5HaL5nET7GH/BMFon/O+1KpmI2do1MwUTAdBgNVHQ4EFgQU9yjFBqAZOMv+
cD6a3KHTWuYrcFEwHwYDVR0jBBgwFoAU9yjFBqAZOMv+cD6a3KHTWuYrcFEwDwYD
VR0TAQH/BAUwAwEB/zAKBggqhkjOPQQDAgNJADBGAiEAwCpA5Nx083qqUqU6LUd0
vzZLK4etuInxNvXohXH5LiACIQDSI63J4DiN3dq2sPPLw5iQi9MMefcV1iAySbKT
B9BaAw==
-----END CERTIFICATE-----

6) Puedes dejar las cosas ahí, pero quizás prefieras un archivo PFX que contenga
tanto el certificado como la clave privada para exportar y usar.

Puedes hacer esto usando el comando pkcs12 de OpenSSL:

$ openssl pkcs12 -export -inkey private-key.pem -in cert.pem -out cert.pfx

OpenSSL le pedirá que cree una contraseña para el archivo PFX. Puede dejarla en
blanco.

Esto debería dejarle con un certificado .pfx.

¿Qué es el formato de certificado PFX?
======================================

Un archivo de intercambio de información personal (.pfx) es un certificado de
archivo protegido por contraseña que se utiliza comúnmente para firmar código en
aplicaciones. Se deriva del certificado de formato de archivo PKCS 12 y almacena
múltiples objetos criptográficos en un solo archivo:

Certificados de clave pública X.509
Claves privadas X.509
CRL X.509
datos genéricos

Existen otros tipos de formatos de certificados como .pem, .cert, .crt y algunos
de ellos incluso pueden convertirse a .pfx y usarse para firmar código, mientras
que otros solo pueden usarse para SSL (páginas web).

Fuente
======

https://www.scottbrady.io/openssl/creating-elliptical-curve-keys-using-openssl

=====
rsync
=====

Es una aplicación que ofrece transmisión eficiente de datos, que opera también
con datos comprimidos y cifrados. Mediante una técnica de delta encoding,
permite sincronizar archivos y directorios entre dos máquinas de una red o entre
dos ubicaciones en una misma máquina, minimizando el volumen de datos
transferidos.

Muy recomendable para hacer respaldos en discos externos.

Para instalarlo

# apt-get install rsync

Parametros: -P para mostrar el progreso de la copia y -r cuando se van a copiar
directorios

Para copiar ficheros, archivos, etc.

$ rsync -P ficehero /directorio/carpeta2

-r para copiar directorios se ponen las dos rutas: origen y destino separados
por un espacio

$ rsync -P -r /directorio/carpeta1_origen /directorio/carpeta2_destino

Ojo con carpeta1, sin el / al final, lo cual significa que se va copiar la
carpeta completa con su contenido y no solo su contenido.

========================================================
rsync para copiar ficheros a un servidor a través de ssh
========================================================

-v : Verbose (try -vv for more detailed information)
-e "ssh options" : specify the ssh as remote shell
-a : archive mode
-r : recurse into directories

$ rsync -P -r -v -e ssh name_dir_or_filename user@192.168.1.100:/home/use/dir/

==============================================================
Usando rsync desde python para copiar un fichero a un servidor
==============================================================

$ python

>>> import os
>>> os.system("rsync -varz /home/user/xxx.txt user@192.168.1.100:")
user@192.168.1.100's password: ******
sending incremental file list
xxx.txt

sent 87 bytes  received 31 bytes  33.71 bytes/sec
total size is 0  speedup is 0.00
0
>>> 

Fichero copiado al servidor!

Comando avanzado de rsync
=========================

El comando rsync -avR --progress es una combinación de opciones muy utilizada
con la herramienta rsync, que sirve para sincronizar archivos y directorios
entre ubicaciones (local o remota) de manera eficiente. Aquí está el desglose de
cada opción:

Opciones:

1. -a (archive mode)

Activa el modo "archivo", que equivale a varias opciones combinadas:

-r: Copia recursiva (incluye subdirectorios).

-l: Preserva enlaces simbólicos.

-p: Preserva permisos de archivos.

-t: Preserva timestamps (fechas de modificación).

-g: Preserva el grupo propietario.

-o: Preserva el usuario propietario (requiere permisos adecuados).

-D: Incluye dispositivos especiales (solo para superusuarios).

2. -v (verbose)

Muestra detalles durante la transferencia (archivos copiados, errores, etc.).

3. -R (relative paths)

Preserva la estructura relativa de las rutas. Por ejemplo, si sincronizas
/foo/bar/file.txt y el destino es /backup, se creará /backup/foo/bar/file.txt en
lugar de solo /backup/file.txt. Útil para mantener jerarquías exactas.

4. --progress

Muestra el progreso de la transferencia para cada archivo (útil para monitorear
operaciones largas).

Fuente
======

DeepSeek

====================================
CCLive - Descargar videos de youtube
====================================

CCLive es una aplicación que nos permite descargar un vídeo que esté en YouTube
hacia nuestro ordenador mediante un simple comando. Por defecto guarda los
vídeos en webm.

Para ver si lo tenemos en los repos, y ver la descripción, si es así.

$ aptitude show cclive

Instalación

# apt install cclive

Descargar un video pasando la url de youtube.

$ cclive https://www.youtube.com/watch?v=yWVrvce5R9

Soporta varias URLs a la vez, para bajar mas de 1 video.

$ cclive URL1 URL2 URL3 URL4

Descargar un vídeo detrás de otro, desde un archivo de texto plano con todas
las URLs (en líneas diferentes).

$ cclive < urls.txt

Manual del paquete.

$ man cclive

Comprobar los formatos disponibles antes de descargar el video.

Se podrá ver un listado de formatos disponibles separados por "|"

$ cclive -F https://www.youtube.com/watch?v=Lfj667lLLnE

Se elige el formato y se pasa en el comando, luego comenzará la descarga.

$ cclive -f fmt22_720p https://www.youtube.com/watch?v=LtzFg4JiL5E

Download the best available format of the media.

$ cclive -f best http://www.youtube.com/xxxxxx

========================================
youtube-dl - Descargar videos de youtube
========================================

Instalación de youtube-dl desde el repositorio de Debian.

# apt-get install youtube-dl

# apt-get install python-pip

Nota: De vez en cuando salen actualizaciones por lo cual hay que actualizar
manualmente el paquete, y si no se actualiza puede presentar errores, entonces,
lo actualizamos con los siguientes comandos:

# apt-get update

# apt-get install --only-upgrade youtube-dl

$ pip install --upgrade youtube-dl

Instalación desde la página oficial.

$ sudo curl -L https://yt-dl.org/downloads/latest/youtube-dl -o /usr/local/bin/youtube-dl

$ sudo chmod a+rx /usr/local/bin/youtube-dl

$ sudo pip install --upgrade youtube_dl

ó usando wget

$ sudo wget https://yt-dl.org/downloads/latest/youtube-dl -O /usr/local/bin/youtube-dl

$ sudo chmod a+rx /usr/local/bin/youtube-dl

$ sudo pip install --upgrade youtube_dl

Para enumerar todos los formatos de video disponibles, use la opción
"-list-formats" con el comando youtube-dl.

$ youtube-dl --list-formats my_youtube_url

Ejemplo de la salida del comando:

[youtube] vKtwZmhX0lw: Downloading webpage
[youtube] vKtwZmhX0lw: Downloading video info webpage
[youtube] vKtwZmhX0lw: Extracting video information
[youtube] vKtwZmhX0lw: Downloading DASH manifest
[youtube] vKtwZmhX0lw: Downloading DASH manifest
[info] Available formats for vKtwZmhX0lw:
format code  extension  resolution note
171    webm    audio only DASH audio  113k , vorbis@128k (44100Hz), 1.86MiB
140    m4a     audio only DASH audio  128k , m4a_dash container, aac  @128k (44100Hz), 2.14MiB
141    m4a     audio only DASH audio  255k , m4a_dash container, aac  @256k (44100Hz), 4.30MiB
278    webm    180x144    DASH video   63k , webm container, vp9, 1fps, video only, 946.76KiB
160    mp4     180x144    DASH video  112k , avc1.4d400c, 15fps, video only, 1.86MiB
242    webm    300x240    DASH video  170k , vp9, 1fps, video only, 2.50MiB
133    mp4     300x240    DASH video  247k , avc1.4d400d, 25fps, video only, 4.11MiB
243    webm    400x320    DASH video  288k , vp9, 1fps, video only, 4.07MiB
13     3gp     unknown    small
17     3gp     176x144    small ,  mp4a.40.2, mp4v.20.3
36     3gp     320x240    small ,  mp4a.40.2, mp4v.20.3
5      flv     400x240    small
43     webm    640x360    medium ,  vorbis, vp8.0
18     mp4     640x360    medium ,  mp4a.40.2, avc1.42001E (best)

Para descargar un formato de archivo preferido, use la opción '-f' (código de
formato de video). Por ejemplo, me gustaría descargar el formato mp4 así que uso
el código de formato como '18' como se muestra a continuación.

$ youtube-dl -f 18 my_youtube_url

===============================
Formatear pendrives desde linux
===============================

# aptitude install dosfstools

Luego de instalar el paquede, montamos el pendrive, solo esta montado si aparece
el nombre de la unidad en /media, luego escribimos:

$ df -h

Visualizamos la ruta de nuestro usb, ejemplo /dev/sdc1 que es el puerto donde
está montado, luego desmontamos el pendrive.

$ umount /media/nombre_usb

Luego, estando desmontado la unidad usb, pero conectado al puerto

# mkfs.vfat -F 32 -n Nombre_usb /dev/sdc1

Esperamos y listo. Con la opción -F 32 le decimos que será formateada como
Fat32, y con la opción -n le ponemos una etiqueta o nombre al dispositivo y al
final ponemos la ruta hasta nuestro dispositivo, la que vimos con df -h

=============
sqlitebrowser
=============

Herramienta de alta calidad visual para crear, diseñar y editar archivos de
bases de datos compatibles con SQLite. Es para usuarios y desarrolladores que
desean crear bases de datos, buscar y editar datos. Utiliza una interfaz de tipo
hoja de cálculo familiar y no necesita aprender comandos SQL complicados.

Para instalarlo

# aptitude install sqlitebrowser

Para ejecutarlo

$ sqlitebrowser

==============================================
Quemar o grabar una imagen .iso en un pendrive
==============================================

# dd if=[imagen] of=[dispositivo]

En donde imagen es la ruta completa a la imagen ISO que deseas grabar y
dispositivo la ruta de sistema hacia la unidad usb, no la ruta con el nombre del
usb, estas rutas las vemos con:

$ df -h

Por ejemplo:

# dd if=/home/user/Descargas/debian-testing-i386-businesscard.iso of=/dev/media/sdb

Copiar un imagen .iso en unidad USB

Para hacerlo booteable, debe estar desmontado pero conectado en el puerto usb.

$ cat xxxx.iso > /dev/sdxxx ; sync

=============================================
Instalación de solo el sistema base de Debian
=============================================

https://foratdot.info/como-instalar-linux-debian-base/

====================================
Instalación de gnome en sistema base
====================================

# apt install gnome-shell

# apt install gnome-core

# apt install gnome

# apt install task-gnome-desktop

# apt install task-spanish-desktop

=========================
Remover gnome del sistema
=========================

# apt-get autoremove --purge 'gnome*'

# apt-get autoremove

============================================
Instalación de gnome classic en sistema base
============================================

Probado en Ubuntu 11 y 12 nada más, puede que funcione en anteriores o
superiores.

$ sudo apt install gnome-panel

$ sudo apt install gnome-session-flashback

Luego de reiniciar, saldrá el gnome-classic en las opciones de escritorio antes
de iniciar sesión.

==========================================
Configuraciones visuales extras para gnome
==========================================

# apt-get install gnome-themes-extras

=============================
Usando los programas de gnome
=============================

Captura de pantalla del escritorio usando el panel de herramientas.

$ gnome-screenshot --interactive

Captura de pantalla del escritorio.

$ gnome-screenshot

Extrae las imagenes de un .pdf

$ pdfimages fichero.pdf nombre_imagene

===================================
Instalación de xfce en sistema base
===================================

Xfce es un entorno de escritorio ligero para sistemas tipo UNIX. Su objetivo es
ser rápido y usar pocos recursos del sistema, sin dejar de ser visualmente
atractivo y fácil de usar.

# aptitude install xfce4

Luego instalamos utilidades extras, si se quiere, se le conoce como "goodies".

# aptitude install xfce4-goodies

# aptitude install lightdm

Luego de eso, cuando reiniciemos la máquina, podremos elegir acceder con xfce
como entorno de escritorio.

============================
wget para descargar ficheros
============================

Descargar toda una página completa, wget no está limitado a solo descargas de
archivos. Sitios completos pueden descargarse también.

$ wget www.ejemplo_web.com

Lo mismo que lo anterior pero con esta opción -p descarga además todos los
elementos extras necesarios de la página como hojas de estilos, imágenes en
línea, etc.

$ wget -p www.ejemplo_web.com

-c ó --continue, reanudar una descarga de wget si se detuvo por caída de red,
cancelación de proceso, etc. Se lanza el comando de nuevo con el enlace para
reanudar.

$ wget -c ftp://sunsite.doc.ic.ac.uk/ls-lR.Z

-----

Indicar más de una descarga a la vez, incluso con distintos protocolos o extensiones

$ wget http://ejemplo.com/programa.tar.gz ftp://otrositio.com/descargas/video.mpg

-----

Descargar varios archivos, con extensión similar.

$ wget http://ejemplo.com/*.pdf

-----

Descargar varios archivos a traves de una lista.

$ wget -i archivos.txt

Creamos una lista en archivos.txt que serán descargados:
http://ejemplo.com/programa.tar.gz
http://ejemplo.com/rpm/paquete.rpm
ftp://otrositio.com/descargas/distro.iso

Por defecto, wget realiza 20 intentos de establecer la conexión e iniciar la
descarga, en sitios muy saturados es posible que ni con 20 intentos se logré,
con la opción -t (tries) aumenta a más intentos.

$ wget -t 50 http://ejemplo.com/pelicula.mpg

/ Con la opción -r se descarga recursivamente hasta 5 niveles del sitio.

$ wget -r www.ejemplo.com

$ wget --convert-links -r http://www.sitio.com/

ó

Por defecto, los enlaces dentro del sitio apuntan a la dirección del dominio
completo. Si deseas descargar el sitio recursivamente y después estudiarlo fuera
de línea (off line) usa la opción convert-links que los convertirá en enlaces
locales, apuntando a las páginas dentro del sitio descargado.

$ wget -k -r http://www.sitio.com/

$ wget --mirror http://ejemplo_web.com/    

ó

De este modo obtienes una copia (un espejo) completa del sitio.

$ wget -m http://ejemplo_web.com/

-l7 (nivel de profundidad) de descargara, es decir descargará en esa profundidad
de subdirectorios. De forma predeterminada wget emplea 5.

$ wget -r -l7 www.ejemplo.com

-----

Ignorar avisos de certificados caducados, etc.

$ wget --no-check-certificate my_url

-----

Descargar una carpeta o directorio específico con wget

$ wget -H -r --level=1 -k -p http://192.168.12.82/share/fff

-----

Descargar archivos que tengan espacios en el nombre

Cuando se intenta descargar un archivo que tenga espacios en el nombre o
parentesis puede dar error, en la terminal, los paréntesis tienen un significado
especial, por lo que necesitan ser escapados o el nombre completo del archivo
debe estar entre comillas para evitar el error.:

$ wget "https://example.com/Un Lugar En Silencio Día Uno (2024).mp4"

O si prefieres escapar los paréntesis:

$ wget https://example.com/Un\ Lugar\ En\ Silencio\ Día\ Uno\ \(2024\).mp4

Fuente
======

ChatGPT

========================================================
Imágenes ISO de todas las versiones de GNU/Linux Debian
========================================================

Repositorio oficial: https://cdimage.debian.org/cdimage/archive/

Consideraciones importantes para instalación de versiones antiguas:

Si descarga una imagen ISO antigua e intenta realizar una instalación estándar,
el proceso fallará durante la instalación de las utilidades del sistema. Esto
ocurre porque el instalador intentará conectarse a repositorios y direcciones
que ya no se encuentran disponibles.

Procedimiento recomendado:

1. Instalar solo el sistema base directamente desde la imagen DVD
2. Acceder al sistema una vez finalizada la instalación mínima
3. Configurar manualmente los repositorios archive de Debian
4. Instalar software adicional desde los repositorios archive

Configuración de repositorios archive:

Ejemplos de configuración para /etc/apt/sources.list:

### Para Debian Bullseye (11):

deb http://archive.debian.org/debian/ bullseye main contrib
deb http://deb.debian.org/debian bullseye main
deb http://security.debian.org/debian-security bullseye-security main
deb http://deb.debian.org/debian bullseye-updates main

=====
jigdo
=====

Jigsaw Download, o abreviadamente jigdo , se propone como la forma principal de
distribuir imágenes de CD de Debian en el futuro. Actualmente, el sistema
funciona, pero no es aún muy cómodo de usar porque la aplicación gestora de
descargas no está terminada.

Página del paquete -> https://www.debian.org/CD/jigdo-cd/

# aptitude install jigdo-file

Aquí, por ejemplo, podemos buscar los .jigdo de la versión que queremos
descargar https://cdimage.debian.org/cdimage/archive/ en jigdo-dvd/

Descargar un .jigdo, por ejemplo:

$ jigdo-lite http://cdimage.debian.org/debian-cd/8.5.0/amd64/jigdo-dvd/debian-8.5.0-amd64-DVD-1.jigdo

Luego nos preguntará por ejemplo:

Files to scan: 

Como esta es la primera vez que vamos a descargar el iso, damos Enter y no añado
nada en este paso.

Lo otro que va a preguntar es cuál el mirror que quieres usar (se puede usar un
mirror local siempre y cuando esté actualizado). por lo tango metemos la
dirección en el espacio: http://debian.cenditel/debian/ y enter.

Ejecutará muchos procesos y al final debe mostrar un:

-------------------------------
Finished!
The fact that you got this far is a strong indication that `debian-7.11.0-amd64-CD-1.iso'
was generated correctly. I will perform an additional, final check,
which you can interrupt safely with Ctrl-C if you do not want to wait.

OK: Checksums match, image is good!

Al final nos quedara la imagen .iso de GNU/Linux Debian que escogimos descargar.

=======================
Conexion remota con ssh
=======================

SSH (Secure SHell) es el nombre de un protocolo y del programa que lo implementa
y sirve para acceder a máquinas remotas a través de una red. Permite manejar por
completo la computadora mediante un intérprete de comandos, y también puede
redirigir el tráfico de X para poder ejecutar programas gráficos si tenemos
ejecutando un Servidor X (en sistemas Unix y Windows).

Además de la conexión a otros dispositivos, SSH nos permite copiar datos de
forma segura (tanto archivos sueltos como simular sesiones FTP cifradas),
gestionar claves RSA para no escribir claves al conectar a los dispositivos y
pasar los datos de cualquier otra aplicación por un canal seguro tunelizado
mediante SSH.

Instalar ssh y el servidor de ssh que permite conexiones remotas.

# aptitude install ssh openssh-server

Conectarse a otra máquina o servidor

$ ssh Nombre_usuario@IP_servidor o nombre_servidor

Asi se accede a un ordenador o servidor remoto, debemos poner el usuario que
debe estar creado asi como la ip del server, nos pedira la clave de session, una
vez adentro tenemos acceso a los archivos y podemos pedir el root para tener
acceso total.

$ ssh user@192.168.0.240

ssh es muy usado por administradores de redes y de sistemas para acceder a las
maquinas y los servidores y hacer cambios asi como monitorear los procesos que
esten ejecutando, especialmente en maquinas virtuales si varios proyectos corren
en un mismo servidor.

Otra forma usando el parámetro -l.

$ ssh -l user 192.168.0.240

Si el servidor tiene el mismo usuario que el host, no hace falta especificarlo,
solamente con la ip del servidor basta, pues toma el nombre del usuario del host
para hacer la conexión.

$ ssh 192.168.200.xxx

Estando conectados al servidor, podemos enviar mensajes o abrir programas
remotamente, ejemplo:

 Enviar mensaje a traves del shell a otro usuario, en el servidor o local, debe
 haber un shell abierto que sea receptor.

echo "mensaje" > /dev/pts/2

Se puede hacer localmente para probar, con (who) veremos la identificacion de
cada shell, si estamos conectados remotamente, comprobaremos si hay shells
abiertos en el local y el servidor, se identifican con los pts/0, pts/1, etc, y
sabremos por la ip si son shells locales o del server  el mensaje sale en el
shell escogido.

Creamos la ventana virtual donde se abrira la aplicacion que ejecutemos, luego

$ export DISPLAY=:0.0

Deberia abrir el programa en el servidor, ya esportada la ventana podemos:

$totem o $nautilus

Abrir el reproductor totem en el servidor

DISPLAY=:0.0 totem

Abrir el explorador de archivos en el servidor

DISPLAY=:0.0 nautilus

Reiniciar el servicio de ssh, a veces se hace para que sirvan algunos cambios de
configuración.

$ sudo service ssh restart

Para ver el estado del servicio.

$ sudo service ssh status

================
Seguridad en ssh
================

Para hacer mas seguras las conexiones a través de ssh es necesario realizar
ajustes adicionales en la configuración del servidor. Estos ajustes se deben
realizar en el fichero de configuración del servidor que, por ejemplo, en Linux
se encuentra en /etc/ssh/sshd_config

==============================================
Cambiar el puerto por defecto del servidor SSH
==============================================

Por defecto los servidores SSH utilizan el puerto 22 para las conexiones. Cuando
un pirata intente buscar la forma de conectarse a nuestro servidor SSH este
probará en primer lugar con este puerto y, de estar abierto, comenzará
el ataque.

Si cambiamos el puerto por defecto por otro de nuestra elección evitaremos que
utilicen el puerto 22 para establecer las conexiones, sin embargo, es fácil
descubrir si este tipo de protocolos utilizan otros puertos adicionales para
las conexiones.

=================================================
Bloquear el acceso root en las conexiones remotas
=================================================

Es recomendable crear un único usuario para conectarse al servidor con una
contraseña lo más fuerte posible de manera que no pueda ser explotada
fácilmente, sin embargo, por defecto el usuario Root también puede conectarse
al servidor SSH de forma remota evitando a un atacante el tener que adivinar el
usuario y facilitándose el trabajo.

Desactivando los permisos de Root para conectarse al servidor SSH complicaremos
notablemente la tarea de explotación por fuerza bruta del servidor al tener que
adivinar también el usuario establecido para permitir la conexión.

El valor por defecto en el archivo de configuración que permite las conexiones
de root es:

PermitRootLogin yes

Debemos cambiarlo por:

PermitRootLogin no

De esta manera las conexiones root quedarán bloqueadas evitando que usuarios no
autorizados puedan realizar ataques de fuerza bruta contra nuestro servidor SSH
para adivinar los credenciales del usuario Root.

========================================
Configuraciones de seguridad adicionales
========================================

Existen otras configuraciones recomendadas para evitar las conexiones no
deseadas a nuestro servidor SSH. Estas conexiones son:

LoginGraceTime: Estableceremos el tiempo necesario para introducir la
contraseña, evitando que el atacante tenga que “pensar mucho”.

MaxAuthTries: Número de errores permitidos al introducir la contraseña antes de
desconectarnos.

MaxStartups: Número de logins simultáneos desde una IP, para evitar que se pueda
utilizar la fuerza bruta con varias sesiones a la vez.

AllowUsers: Este parámetro nos permite configurar los usuarios que podrán
conectarse y desde la IP que lo podrán hacer. Una medida muy restrictiva pero a
la vez muy segura ya que bloqueará todas las conexiones que no cumplan los dos
parámetros.

=====================================================
Reiniciar el servidor para aplicar los nuevos ajustes
=====================================================

Una vez realizados los ajustes debemos reiniciar el servidor para que se
apliquen correctamente. Para ello teclearemos:

$ sudo service ssh reload

En pocos segundos el servidor volverá a arrancar con la nueva configuración
aplicada y mucho más seguro que antes.

========================
Ejemplo de configuración
========================

Port 432 (o el que se quiera menor a 1024)
Protocol 2
LoginGraceTime 30
PermitRootLogin no
MaxAuthTries 2
MaxStartups 3
AllowUsers jose  o también:
AllowUsers jose maria@192.1.1.300

---

Port: Por default el demonio ssh funciona en el puerto 22, y precisamente muchos
scripts de ataques están dirigidos a este puerto, el cambiar de puerto no
garantiza que el servicio ya no será localizable, de hecho con herramientas como
nmap o amap es sumamente fácil descubrir que un servicio ssh esta a la escucha
en otro puerto distinto al 22, pero al menos no será localizable por varios
scripts que de manera automática escanean redes y en cuanto a ssh se enfocan
solo al puerto 22.

Protocol 2: Hay dos versiones de ssh en cuanto a su protocolo de comunicación,
la versión 1 y la versión 2. La 1 esta en desuso pero todavía se incluye por
compatibilidad, tiene varias vulnerabilidades conocidas y su uso no es ya
recomendable. Un error frecuente es dejar al demoinio ssh que permita el uso de
las dos versiones (Protocol 2,1). Para evitar el uso del protocolo 1 y sus
posibles ataques a este, basta con indicar en esta línea que solo admita
comunicaciones de ssh basadas en el protocolo 2.

LoginGraceTime 30: El número indica la cantidad de segundos en que la pantalla
de login estará disponible para que el usuario capture su nombre de usuario y
contraseña, si no lo hace el login se cerrará, evitando así dejar por tiempo
indeterminado pantallas de login sin que nadie las use, o peor aun, que alguien
este intentando mediante un script varias veces el adivinar un usuario y
contraseña. Aqui conviene identificar en nuestros usuarios el tiempo promedio
que tardan en ingresar su usuario y contraseña y darles unos cuantos segundos
más de margen por los usuarios lentos para que ingresen sus credenciales. Si
somos el único usuario del sistema considero que con 20 o 30 segundos es mas
que suficiente.

PermitRootLogin no: Esta es quizás la más importante directiva de seguridad que
podemos indicar para fortalecer nuestro servidor ssh.

Prácticamente todos los sistemas Linux y Unix crean por default al usuario root,
entonces sabemos que existe!!!. Muchos ataques de fuerza bruta se concentran en
atacar al usuario root con la esperanza de que tenga una contraseña débil (¡que
es mas común de lo que pensamos!).

Entonces si ya sabemos una parte de la ecuación (root) solo será cuestión de
tiempo para que alguien con paciencia y suerte vulnere el sistema.

Al poner en 'no' la variable PermitRootLogin el usuario root no tendrá permiso
de acceder mediante ssh y por lo tanto cualquier intento de ataque directo a
root será inútil. Con esto siempre tendremos que ingresar como un usuario normal
y ya estando adentro entonces mediante su o sudo podremos usar funciones de
root, no problem. Ahora bien, para el nombre de login del usuario normal te
recomiendo que también NO uses palabras conocidas como: admin, manager, juan,
pedro, sistemas, etc. Usa algo mas dífcil de adivinar como jgon (de juan
gonzález) o sispat (de sistemas pato) o mejor aun también puedes combinar algún
guión bajo o mayúsculas, minúsculas y números en la cuenta de login. Con lo
anterior el hacker tendrá que atinarle o crackear tanto al nombre del usuario
como su contraseña.

MaxAuthTries 2: El número indica la cantidad de veces que podemos equivocarnos
en ingresar el usuario y/o contraseña, en este caso después de dos intentos, se
perderá o cerrará la conexión. Claro, es totalmente posible volver a intentarlo,
pero como son dos intentos por vez, evitaremos ataques basados en la
persistencia de la conexión, como se perderá al tercer intento de conexión, el
ataque cesará.

MaxStartups 3: El número indica la cantidad de pantallas de login, o cantidad de
conexiones simultaneas de login que permitirá el sshd por ip que intente
conectarse. Hay ataques muy efectivos que dividen el ataque en decenas y puede
ser que en cientos (si el sistema atacado lo permite) de conexiones de login.
Es decir, el ataque divide en una gran cantidad de logins los intentos por
ingresar, aumentando sus posibilidades de más rapidamente adivinar al usuario y
contraseña. Con esta directiva limitamos a tan solo 3 pantallas de login. Que
quede claro, una vez logueados en el sistema, es posible tener mas de 3
terminales de ssh, se refiere exclusivamente a pantallas de login.

AllowUsers: En sistemas donde se tiene varios usuarios, quizás existan varios
que solo pueden acceder desde la LAN por ejemplo, o quizás solo desde ciertos
equipos. O incluso que solo desde su PC puedan trabajar en Linux por lo que no
hay razón para que se conecten remotamente via ssh. Con esta directiva podemos
indicar los usuarios que pueden ingresar via ssh. Si solo indicamos al usuario:

AllowUsers jose

El usuario jose podrá ingresar desde cualquier PC en cualquier lugar, no se está
validando el host.

Si se quiere mas seguridad, es posible indicar también el host mediante el
símbolo @

AllowUsers jose@192.168.0.25     (solo desde la IP indicada)
AllowUsers jose@192.168.0.*       (Toda la red indicada)
AllowUsers jose@*.desarrollo.com  maria@contabilidad.com    

(jose desde cualquier equipo del dominio indicado, maria solo desde el equipo
indicado)

Como puede verse, bastan algunas cuantas directivas o variables bien
configuradas en nuestro archivo /etc/ssh/sshd_config para incrementar
enormemente la seguridad en este servicio, seguramente no estoy considerando
alguna otra variable que también pudiera ser importante para la seguridad de ssh
si es así por favor házmelo saber para incluirla en este documento. Asi como
también hay que tener en cuenta que hay variables que permiten el no acceso con
contraseñas y sería más bien con certificados o llaves, las posibilidades son
extensas y es posible incluso tener varios equipos Linux comunícandose entre si
para respaldos, bases de datos, etc. con ssh y certificados de seguridad,
evitando intervención humana, consulta la sección de servicios si es lo que
buscas en tu empresa.

==============================
X11 forwarding a través de ssh
==============================

X11, es el servidor gráfico que usan casi todas las distribuciones Linux. Este
servidor permite, entre otras cosas, forwarding a través de SSH. Esto significa
que es posible ejecutar apliaciones gráficas de una máquina remota exportando el
display a nuestro escritorio. Es decir, la aplicación se ejecuta en el servidor
remoto, pero la interfaz gráfica la visualizamos en nuestro escritorio local.

Ejemplo:

1- En el servidor, editar el archivo /etc/ssh/ssh_config y modificar la opción
X11Forwarding o ForwardX11 para que quede así:

X11Forwarding yes

ó

ForwardX11 yes

Luego de este cambio, posiblemente sea necesario reiniciar el demonio ssh. La
forma de hacer esto varía de acuerdo a cada distribución Linux.

$ sudo service ssh restart

O lo más sencillo es reiniciar la máquina.

2- En el escritorio local, loguearse al servidor a través de ssh utilizando el
parámetro -X:

$ ssh -X user@hostname

Donde user es el nombre de usuario utilizado para loguearse en el servidor y
hostname es el ip o el alias del servidor.

3- Para ejecutar una aplicación, simplemente hay que hacerlo desde el terminal.

Por ejemplo:

$ firefox

$ nautilus

$ evince

Cuando ejecutamos una aplicación gráficamente la consola se bloqueara con el
proceso en ejecución, por lo que podemos usar & para que se ejecute el proceso,
construya el entorno grafico del programa y luego dezplace el proceso para poder
seguir usando la consola, ejemplo:

$ firefox

ó

$ firefox & nautilus &

==========================
Escritorio remoto, por ssh
==========================

Esta guía nos permitirá ejecutar un escritorio remoto a través de una conexión
por ssh, el cliente debe estar en modo consola, puede usar tty1 por ejemplo.

Primer paso, instalar openssh-server en el cliente y en el servidor

# apt-get install openssh-server openssh-client

Una vez hecho esto configuramos el servidor para que sea accesible desde los
clientes:

$ sudo nano /etc/ssh/ssh_config

Hay tres lineas del archivo que deberían quedar así:
ForwardAgent yes
ForwardX11 yes
ForwardX11Trusted yes

Guardamos y abrimos otro archivo:

$ sudo nano/etc/ssh/sshd_config

Debe aparecer la siguiente línea:
ForwardX11 yes

Una vez hecho esto reiniciamos el servidor ssh:

$ sudo service ssh restart

Luego nos conectamos por ssh al servidor, con el parámetro -X que nos permitirá
levantar gráficos en el cliente de aplicaciones que se ejecutan en el servidor.

$ ssh -X username@ip_server

======
startx
======

Para iniciar o levantar el modo gráfico

Arrancar el servidor gráfico indicándole el DISPLAY, por defecto el primer
DISPLAY es 0 (al cual accedemos con Cntrl+Alt+F7).

$ startx -- :DISPLAY

Levantará una sesión de escritorio como root, el cliente debe estár en
modo ttyX.

$ sudo startx

ó

Puede que falle a veces, si es que el cliente ya tiene una interáz gráfica
corriendo, por eso se recomienda que esté en ttyX.

$ gnome-session

===================================================
El error ssh remote host identification has changed
===================================================

Cuando el sistema base guarda una llave de acceso a un host, pero el host
cambió, entonces la llave no funciona y arroja el típico error:

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
...
...
...

Entonces borramos ese host roto, llave perdida, etc.

$ ssh-keygen -R <host>

Ejemplo:

$ ssh-keygen -R 192.168.3.10

========================================================
Error: Read from socket failed: Connection reset by peer
========================================================

# rm /etc/ssh/ssh_host_*

# ssh-keygen -A

# apt-get --reinstall install openssh-server openssh-client

$ ssh-keygen -R 192.168.12.xxx

==============================================
Generar llaves para ssh para saltar contraseña
==============================================

Si el host desea conectarse al servidor, sin tener que escribir password cada
vez que se intente conectarse puede usar este método donde se generan claves
publica y privada.

Generamos las claves en el host

$ ssh-keygen -b 4096 -t rsa

No generar frase de paso: simplemente presionemos [Enter], un segundo después
volvemos a presionar [Enter], y un segundo después volvemos una vez más a
presionar [Enter]. O sea, presionaríamos [Enter] un total de tres (3) veces,
solo lo presionamos… no escribimos nada.

Eso nos va a generar las claves en:

/home/user/.ssh
id_rsa // Es nuestra llave privada.
id_rsa.pub // Es nuestra llave pública.
known_hosts // Es un fichero ya existente en ese directorio.

Enviamos la llave publica para el home del servidor:

$ scp /home/.ssh/id_rsa.pub user@192.168.12.x:

Luego en el servidor renombraremos la clave publica a:

$ mv id_rsa.pub authorized_keys

Luego moveremos ese nuevo fichero a .ssh

$ mv authorized_keys .ssh/

Luego quedaría intentar conectarse desde el host al servidor, si todo está bien
no debería pedir contraseña.

Es funcional, pero hubo una vez que no se que coño paso y no quizo funcionar,
las demas pruebas si fueron exitosas.

========================================
Copias de directorios o ficheros por scp
========================================

scp copies files between hosts on a network. It uses ssh for data transfer, and
uses the same authentica‐tion and provides the same security as ssh(1). scp will
ask for passwords or passphrases if they are needed for authentication.

===================================
Copiar archivos de local a servidor
===================================

Si queremos subir el archivo archivo.txt de nuestro ordenador a la carpeta
/home/usuario del servidor, hacemos lo siguiente:

Se especifica el archivo a copiar, luego el servidor y luego el directorio en
el servidor donde copiaremos el archivo.

$ scp archivo.txt usuario@dominio.com:/home/usuario

===================================
Copiar archivos de servidor a local
===================================

Si queremos copiar el fichero archivo.txt del servidor a nuestro ordenador en la
carpeta Documentos, hacemos lo siguiente:

Especificamos el servidor, luego la ruta y el archivo a copiar y luego el
directorio local donde sera copiado el archivo.

$ scp usuario@dominio.com:/home/usuario/archivo.txt /home/usuario/Documentos

======================================
Copiar archivos de servidor a servidor
======================================

$ scp usuario1@dominio1.com:/home/usuario1/archivo.txt usuario2@dominio2.com:/home/usuario2/

=================================================
Copiar un directorio completo de local a servidor
=================================================

Para copiar un directorio completo de mi ordenador al servidor, por ejemplo
/home/mario/carpeta a /home/usuario, añadimos un -r en el comando:

$ scp -r /home/mario/carpeta usuario@dominio.com:/home/usuario

Con los dos puntos al final se copiara automáticamente en el home del usuario.

$ scp -r /home/mario/carpeta usuario@dominio.com:

=================================================
Copiar un directorio completo de servidor a local
=================================================

Para copiar un directorio completo del servidor al local, por ejemplo
/home/usuario/carpeta a /home/user/docs, añadimos un -r en el comando:

$ scp -r usuario@dominio.com:/home/usuario/carpeta /home/user/docs

---

Si el servidor tiene el mismo usuario "user" en este caso, no hace falta
especificarlo, solamente con la ip del servidor basta, pues toma el nombre del
usuario del host para hacer la conexión y osterior copia.

user$ scp x.txt 192.168.200.x

=======
sshpass
=======

Nos permite enviar el password de SSH en la misma línea con el paquete sshpass,
ejemplo:

$ sshpass -p «PASSWORD» ssh root@servidor

Accedemos remotamente a ese servidor, si la contraseña coincide no debería pedir
mas nada, y despliega el prompt del servidor.

$ sshpass -p 123456 ssh user@192.168.1.200

========================================================
Conexion por nautilus explorador de archivos/directorios
========================================================

Usando el navegador de archivos de Debian, Ubuntu, etc, podemos acceder a
ordenador remoto "servidor" para ver graficamente los directorios, es decir,
desde nuestro navegador de archivos, navegaremos en los directorios del servidor
para acceder vamos a:

$ nautilus

Archivo > Conectar con el servidor // Nos saldrá una ventana para llenar con:

Servidor: 192.168.12.400 // Aqui va la ip del servidor
Puerto: 22 // El puerto que tiene habilitado el ssh_config
Tipo: SSH
Carpeta: /home // Carpeta que abrira al entrar en conexion
Nombre de usuario: // Nombre de usuario, de sesion de ese servidor
Contraseña: // Contraseña de la sesion de usuario del servidor

Si todo esta bien deberia entrar a explorar los directorios del servidor.

=======================
Crear alias de comandos
=======================

Un alias es una palabra o frase que se asignara para remplazar un comando, por
lo generalmente se usa para remplazar comandos muy largos y dificiles de
recordar por lo que es una gran ventaja la creacion de alias.

Un alias Se pueden crear temporalmente, directamente en la consola y durara
hasta que cerremos ese shell, tambien asignar permanentemente escribiendolo en
el archivo .bashrc que esta en el /home

$ alias nombre_alias='comando'

Ejemplo:

$ alias sa='aptitude search apache | grep rt4'

(sa) es ahora el alias de ese comando de busqueda en los repositorios de un
paquete especifico.

Para eliminar el alias creado temporalmente

$ unalias nombre_alias

Otros ejemplos:

# some more ls aliases
alias ll='ls -l --color'
alias buscar='grep --color -n -Ir'
alias texto='echo "imprimir este texto"'

alias ls='ls --color=auto'
alias buscar='grep --color -n -Ir'
alias my_project='cd /home/user/project_app && git status'
alias guias_lenguajes='cd /home/user/Documentos/GIT/GuiasLenguajes/'
alias gitlab='echo "XXXXXX"'
alias github='echo "XXXXXXXX"'
alias MailHog='~/.go/bin/MailHog'
alias ruta='echo /home/user | tee >(xclip -selection clipboard)'

Para que se haga efectivo algun cambio en .bashrc es necesario reiniciar pero
hay otra forma de actualizar el fichero sin reiniciar, entonces:

Bastara para que se apliquen los cambios hechos

$ source .bashrc

Mensaje de bienvenida al usuario

Pegamos esto al final del .bashrc, reiniciamos el fichero y ahora cada vez que
iniciemos un shell nos saludará.

## Mensaje al iniciar
echo "Hola Usuario"

Copiar contenido del alias al portapapeles
==========================================

Si estás en un entorno como GNOME o KDE, normalmente se usa xclip.

Instalar xclip:

$ sudo apt install xclip

Aquí te doy un ejemplo de cómo hacerlo con xclip (necesitarías tener xclip
instalado.

alias ruta='echo /home/user | tee >(xclip -selection clipboard)'

Este comando hará lo siguiente:

echo /home/user: Imprime la ruta en la terminal.

tee >(xclip -selection clipboard): Copia la salida al portapapeles usando xclip mientras también la muestra en la terminal.

Prueba el alias y comprueba si puedes pegar el contenido después de ejecutar
ruta.

alias ruta='echo /home/user | tee >(xclip -selection clipboard)'

Fuente
======

ChatGPT

================================================
Saber la direccion ip de una pagina o un sevidor
================================================

Saber la de google por ejemplo:

user@debian:~$ nslookup google.com
Non-authoritative answer:
Name:   google.com
Address: 216.58.192.110 // Direccion ip de google

==========
Otra forma
==========

Haciendo ping a una pagina.

$ ping google.com

La ip que se muestra es la ip de google

PING google.com (216.58.192.110) 56(84) bytes of data.
64 bytes from mia07s35-in-f14.1e100.net (216.58.192.110): icmp_req=1 ttl=49 time=69.6 ms
64 bytes from mia07s35-in-f14.1e100.net (216.58.192.110): icmp_req=2 ttl=49 time=70.4 ms

--- google.com ping statistics ---
3 packets transmitted, 2 received, 33% packet loss, time 2001ms
rtt min/avg/max/mdev = 69.645665/70.00475/470.48645/0.010 ms

============================
Cambiar permisos de usuarios
============================

Al ver los permisos de los ficehros o directorios nos encontramos con varios
parametros:

En la primera columna se pueden ver una serie de letras y guiones (-rwxr-x---)
estas letras nos dicen quien en el sistema, y que clases de permisos tiene el
fichero o carpeta.

Estas letras están agrupadas en tres grupos con tres posiciones cada uno más una
primera posición que nos dice de que clase de archivo se trata (los mas normales
(d) directorios, o (-) archivos de datos).

El primer grupo de tres (rwx en nuestro caso) nos dice que clase de permisos
tiene el dueño del fichero (u)(user/owner).

El segundo grupo de tres (r-x en nuestro caso) nos dice que clase de permisos
tiene el grupo del fichero (g)(group).

Y el último grupo de tres (--- en nuestro caso) nos dice que clase de permisos
tienen todos los demás usuarios del sistema sobre este fichero (o)(others).

r :significa permiso para leer 
w :significa permiso para escribir  
x :significa permiso para ejecutar

u :permisos para el usuario/dueño del fichero/directorio
g :permisos de grupos
o :permisos de los demás usuarios

Los permisos se pueden especificar de diferentes maneras, una serie de ejemplos,
es lo mejor para comprenderlo:

chmod ugo+rwx (da permisos rwx a todos, user,group,others)
chmod ugo-x test (quita permiso x (ejecucion) a todos, user,group,others) 
chmod o-rwx test (quita permisos rwx a others) 
chmod u=rwx,g=rx (da permisos rwx a user, rx a group y ninguno a others)

Ejemplo de como otorgar permisos a un directorio específico, estos serían los
permisos predeterminados o por defecto de un directorio.

chmod -R u=rwx,g=rx,o=rx /dir/dir2/dir3

==============
chmod en octal
==============

Representación octal de chmod

Lectura tiene el valor de 4
Escritura tiene el valor de 2
Ejecución tiene el valor de 1

Entonces:

rwx |  7  | Lectura, escritura y ejecución
rw- |  6  | Lectura, escritura
r-x |  5  | Lectura y ejecución
r-- |  4  | Lectura
-wx |  3  | Escritura y ejecución
-w- |  2  | Escritura
--x |  1  | Ejecución
--- |  0  | Sin permisos

Por lo tanto:

chmod u=rwx,g=rwx,o=rx  | chmod 775 |
chmod u=rwx,g=rx,o=     | chmod 760 |
chmod u=rw,g=r,o=r      | chmod 644 |
chmod u=rw,g=r,o=       | chmod 640 |
chmod u=rw,go=          | chmod 600 |
chmod u=rwx,go=         | chmod 700 |

=====
chown
=====

Permite modificar a los usuarios o grupos dueños de un archivo o carpeta en el
sistema de archivos.

$ chown usuario archivo/carpeta

$ chown -R usuario archivo/carpeta

$ chown usuario *

# chown -R username directory

Para asignar tanto dueño como grupo usamos

# chown -R username:group directory

============
Criptografía
============

Criptografía es la ciencia y arte de escribir mensajes en forma cifrada o en
código.

Es parte de un campo de estudios que trata las comunicaciones secretas.

La criptografía se ha definido, tradicionalmente, como el ámbito de la
criptología que se ocupa de las técnicas de cifrado o codificado destinadas a
alterar las representaciones lingüísticas de ciertos mensajes con el fin de
hacerlos ininteligibles a receptores no autorizados. Estas técnicas se utilizan
tanto en el arte como en la ciencia y en la tecnología. Por tanto, el único
objetivo de la criptografía era conseguir la confidencialidad de los mensajes,
para lo cual se diseñaban sistemas de cifrado y códigos, y la única criptografía
existente era la llamada criptografía clásica.

La aparición de la informática y el uso masivo de las comunicaciones digitales,
han producido un número creciente de problemas de seguridad. Las transacciones
que se realizan a través de la red pueden ser interceptadas, y por tanto, la
seguridad de esta información debe garantizarse. Este desafío ha generalizado
los objetivos de la criptografía para ser la parte de la criptología que se
encarga del estudio de los algoritmos, protocolos (se les llama protocolos
criptográficos), y sistemas que se utilizan para proteger la información y dotar
de seguridad a las comunicaciones y a las entidades que se comunican.

Para ello los criptógrafos investigan, desarrollan y aprovechan técnicas
matemáticas que les sirven como herramientas para conseguir sus objetivos. Los
grandes avances producidos en el mundo de la criptografía, han sido posibles
gracias a la evolución que se han producido en el campo de la matemática y la
informática.

=======
Fuentes
=======

-https://es.wikipedia.org/wiki/Criptograf%C3%ADa

===========
Criptología
===========

La criptología es, tradicionalmente, la disciplina que se dedica al estudio de
la escritura secreta, es decir, estudia los mensajes que, procesados de cierta
manera, se convierten en difíciles o imposibles de leer por entidades no
autorizadas.

Con la aparición de las tecnologías de la información y la comunicación y el uso
masivo de las comunicaciones digitales, se han producido un número creciente de
problemas de seguridad. El objetivo de la criptología se ha generalizado para
estudiar las técnicas que se encargan de proporcionar seguridad a la
información.

======
Fuente
======

-https://es.wikipedia.org/wiki/Criptolog%C3%ADa

==============
Criptoanálisis
==============

El criptoanálisis es la parte de la criptología que se dedica al estudio de
sistemas criptográficos con el fin de encontrar debilidades en los sistemas y
romper su seguridad sin el conocimiento de información secreta. En el lenguaje
no técnico, se conoce esta práctica como romper o forzar el código, aunque esta
expresión tiene un significado específico dentro del argot técnico. A las
personas que se dedican al criptoanálisis se llaman criptoanalistas.

======
Fuente
======

-https://es.wikipedia.org/wiki/Criptoan%C3%A1lisis

======================
Encriptación o Cifrado
======================

Con frecuencia a los procesos de cifrado y descifrado se les denomina encriptado
y desencriptado, ambos anglicismos de los términos ingleses encrypt y decrypt.
La Real Academia Española recogió esa acepción en la edición de su diccionario
de 2014. Por su parte La Fundación del Español Urgente defiende que encriptar
es un término válido y que no hay razón para censurar su uso.

======
Fuente
======

-https://es.wikipedia.org/wiki/Cifrado_(criptograf%C3%ADa)

=======
Cifrado
=======

Cifrado, en la criptografía.

El cifrado es un procedimiento que utiliza un algoritmo de cifrado con cierta
clave (clave de cifrado) para transformar un mensaje, sin atender a su
estructura lingüística o significado, de tal forma que sea incomprensible o, al
menos, difícil de comprender a toda persona que no tenga la clave secreta (clave
de descifrado) del algoritmo. Las claves de cifrado y de descifrado pueden ser
iguales (criptografía simétrica), distintas (criptografía asimétrica) o de ambos
tipos (criptografía híbrida).

==========================
¿Cómo funciona el cifrado?
==========================

Los métodos de cifrado actuales se basan en fórmulas matemáticas complejas. Se
utilizan estos dos tipos de sistemas:

==================================
El cifrado simétrico y asimétrico
==================================

En el cifrado simétrico, ciframos el archivo con una clave X
Para descifrarlo y obtener el archivo original, utilizamos la misma clave X.

El cifrado asimétrico es más complicado. Aquí no tenemos una sola clave común.
En su lugar cada persona tiene dos claves, una pública y una privada. Para
enviarle un archivo a un amigo lo cifras con su clave pública. De esta forma,
sólo lo puede descifrar él con su clave privada. Es más seguro que el cifrado
simétrico, ya que la clave de descifrado (la privada) nunca se comparte, siempre
la tiene el receptor.

Ejemplo: Sabiendo lo anterior, si queremos que tres compañeros de trabajo nos
manden un archivo cifrado debemos de mandarle nuestra clave pública (que está
vinculada a la privada) y nos podrán mandar de forma confidencial ese archivo
que solo nosotros podremos descifrar con la clave privada.

=======
Fuentes
=======

-https://es.wikipedia.org/wiki/Cifrado_(criptograf%C3%ADa)
-https://www.genbeta.com/desarrollo/tipos-de-criptografia-simetrica-asimetrica-e-hibrida

=============
Firma digital
=============

La firma digital consiste en la creación de un código, a través de la
utilización de una llave privada, de modo que la persona o entidad que recibe un
mensaje conteniendo este código pueda verificar si el remitente es quien dice
ser e identificar cualquier mensaje que pueda haber sido modificado.

=================
Firma Electrónica
=================

Es un método criptográfico que asocia la identidad de una persona o de un equipo
informático al mensaje o documento. En Función del tipo de firma, se puede,
además, asegurar la integridad del documento o mensaje.

==================================
¿Qué es GnuPG? (GNU Privacy Guard)
==================================

Es un derivado libre de PGP y su utilidad es la de cifrar y firmar digitalmente,
siendo además multiplataforma (podéis descargarlo desde la página oficial)
aunque viene incorporado en algunos sistemas Linux, como en Ubuntu o Debian.

GnuPG es una herramienta de GNU para la comunicación y el almacenamiento de
datos de manera segura. Se puede utilizar para cifrar datos y para crear firmas
digitales. Incluye capacidad avanzada de gestión de claves y cumple con el
estándar de Internet OpenPGP propuesto tal como se describe en el RFC 4880.

=========================================================================
Cifrado de ficheros con gpg, cifrado simétrico, asimétrico, firma digital
=========================================================================

Haremos uso del paquete gnupg

Descripción del paquete gnupg: Protección de la privacidad de GNU - un sustituto
libre a PGP.

GnuPG es una herramienta GNU para la comunicación y el almacenamiento de datos
de forma segura. Puede usarse para cifrar datos y crear firmas digitales.

Incluye un avanzado servicio de administración de claves, y cumple el estándar
OpenPGP.

Revisar si está instalado gnupg

$ aptitude search gnupg

================
Anillo de claves
================

GPG tiene un repositorio de claves (anillo de claves) donde guarda todas las que
tenemos almacenadas en nuestro sistema, ya sean privadas o públicas (como
comenté, con la clave pública cifraremos un mensaje que solo podrá descifrar el
que posee la clave privada).

Más adelante cuando veamos un anillo de claves debemos de recordar que pub hace
referencia a la clave pública y sub hace referencia a la privada (y que tenemos
que tener a buen recaudo).

====================
Servidores de claves
====================

Para que nos cifren un mensaje tenemos que compartir la clave pública de nuestro
par de claves para cifrar, y como es un poco engorroso difundir una clave a
muchas personas existen los servidores de claves PGP (compatibles con GPG),
donde subiré una clave pública para el que quiera probar los ejemplos. Unos
ejemplos de servidores son estos: pgp.rediris.es (español, aunque falla algunas
veces) o pgp.mit.edu (americano, del MIT y a mi no me ha dado problemas).

=================
Cifrado simétrico
=================

El cifrado simétrico es el tipo de cifrado más sencillo que hay, es más rápido
de procesar y por desgracia menos seguro que el cifrado asimétrico.

Crear un fichero cualquiera de ejemplo

$ touch prueba.txt

Dentro del fichero copiaremos algún texto de prueba para comprobar luego con el
descifrado, luego en el shell escribimos el comando gpg con el parámetro -c para
cifrar y -d para descifrar.

=========================
Parámetros básicos de gpg
=========================

Encrypt with a symmetric cipher using a passphrase. The default symmetric cipher
used is CAST5.

-c

Decrypt the file given on the command line.

-d

El comando gpg -c nombre_fichero nos aparecerá un cuadro que nos pide la
contraseña luego una confirmacion de la misma, luego  generará un archivo .gpg

$ gpg -c prueba.txt

Para descifrarlo usamos el comando gpg -d notas.txt.gpg introduciendo la
contraseña correcta para poder decifrarlo.

Descifrar el fichero, nos permitira mirar el contenido.

$ gpg -d prueba.txt.gpg

Guardar el contenido descifrado en un archivo:

$ gpg -d prueba.txt.gpg > archivo.txt

Ver el Manual de gpg

$ man gpg

==================
Cifrado asimétrico
==================

Generar las claves

Para poder cifrar asimétricamente primero tenemos que crear la pareja de claves
(pública y privada) con el comando gpg --gen-key.

$ gpg --gen-key
gpg (GnuPG) 1.4.12; Copyright (C) 2012 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Por favor seleccione tipo de clave deseado:
(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sólo firmar)
(4) RSA (sólo firmar)
Su elección:

GPG nos permite elegir el tipo de clave que queremos usar, hay opciones que solo
permiten firmar y otras que permiten firmar y cifrar, en este caso usaremos DSA
y Elgamal.

Las claves DSA pueden tener entre 1024 y 3072 bits de longitud.

¿De qué tamaño quiere la clave? (2048)

Nos pedirá el tamaño de la clave que puede variar entre 1024 bits y 3072 esto es
de libre elección, tomarémos el que propone por defecto (2048).

Nos pide la fecha en la que expirará la clave, la información del emisor de la
clave (nombre, mail y algunos datos extra que queramos dar) y por último nos
pedirá la contraseña que salvaguarda la clave privada.

Tras generar las claves podemos verlas con el comando gpg -k que nos muestra
nuestro anillo de claves, lo importante de este paso es que veremos la
identificación de cada una que es necesaria para poderlas exportar y enviar.

Visualizar anillo de claves públicas importadas.

$ gpg -k

ó

$ gpg --list-key

Eso nos muestra por pantalla lo siguiente:

/home/user/.gnupg/pubring.gpg
--------------------------------

pub   1559C/88651986 2017-01-01
uid               username_lastname (Enunciado de la clave) <username@email.com>
sub   2048g/55GD33FG 2017-01-01

88651986, Éste es el ID de la llave pública.

55GD33FG, Éste es el ID de la llave privada.

Visualizar anillo de claves privadas importadas, si no hay nada entonces debo
importar mis llave/s privadas.

$ gpg --list-secret-key

Para poder usar mi llave privada debo copiar mi directorio /home/my_user/.gnupg
que es donde la genere, eso si quiero usarla en otro equipo.

==================================
Exportar y enviar la clave pública
==================================

El objetivo de esta pareja de claves es que cualquiera nos pueda mandar un
archivo cifrado que solo veremos nosotros y esto se hace difundiendo la clave
pública que acabamos de crear (la pública, nunca la privada), para exportarla en
un archivo usaremos el comando:

La clave pública generada antes tiene la ID 88651986).

$ gpg -output [archivo destino] --export [ID de a clave pública]

$ gpg --output ClavePublica_username.gpg --export 88651986

Fichero generado que contiene la clave pública

$ ls
ClavePublica_username.gpg

Este archivo ahora se puede difundir por el medio que queramos.

===============================================
Subir una clave pública a un servidor de claves
===============================================

Los servidores de claves suelen ser de acceso público (al no haber mucho
problema por difundir una clave pública) y en este caso subiremos una clave a
los servidores del MIT (pgp.mit.edu) usando el comando:

Al igual que antes la ID es 88651986)

$ gpg --send-keys --keyserver [Dirección del servidor] [ID de la clave pública]

$ gpg --send-keys --keyserver pgp.mit.edu 88651986

Entramos a --> https://pgp.mit.edu/ y buscamos nuestra clave pública por El
Nombre y Apellido que añadimos cuando la estuvimos creando.

=======================================================
Importar la clave desde el archivo o servidor de claves
=======================================================

Para poder usar la clave pública para cifrar o comprobar la identidad del
remitente tenemos que importar previamente la clave, desde un archivo debemos de
usar el comando gpg --import [Archivo de la clave pública].

$ gpg --import CPub.gpg

 Eso nos mostrará lo siguiente:

/home/user/.gnupg/pubring.gpg
--------------------------------
pub   2048R/XXXXXX XXXX-XX-XX
uid                  My User <My email>
sub   2048R/XXXX XXX-XX-XX

Para realizar la importación desde el servidor tenemos que usar el comando

$ gpg --keyserver [Dirección del servidor] --recv-keys [ID de la clave]

$ gpg --keyserver pgp.mit.edu --recv-keys 5616846865

=======================================
Borrar una clave de mi anillo de claves
=======================================

Pasamos el id de la clave que queremos borrar.

$ gpg --delete-keys id_pub_key

$ gpg --delete-keys 23484556

=================
Cifrar un fichero
=================

Creamos el fichero, lo llenamos con algo de texto para la prueba, lo guardamos.

$ vim x.txt

Cifrar con una clave pública.

$ gpg --encrypt --recipient [ID de la clave] [Archivo]

Ciframos el fichero con la clave publica creada para la prueba.

$ gpg --encrypt --recipient 88651986 x.txt

Fichero cifrado con la clave pública

Nos creará un fichero: x.txt.gpg

=========================================
Descifrar un archivo con la clave privada
=========================================

$ gpg -d [Archivo]

$ gpg -d x.txt.gpg

Si las llaves con que se cifro el fichero están en el anillo de claves entonces
se podrá descifrar el contenido.

Si las claves no han sido importadas entonces mostrará lo siguiente:

gpg: cifrado con clave RSA, ID XXXXXXXX
gpg: descifrado fallido: clave secreta no disponible

Si importamos nuestra llave/s privadas copiando /home/user/.gnupg a una nueva
máquina, si así fuera el caso, nos mostrará:

Necesita una frase contraseña para desbloquear la clave secreta del usuario:
"Name_user Last_name (comment) <mail@mail.xxx>" clave RSA de 2048 bits, ID
88651986, creada el 201x-xx-xx(ID de clave primaria 5F829889).

Introduzca frase contraseña:

La contraseña es la clave privada, la cual solo tendremos nosotros y nunca
compartiremos, pues es la que nos permite descifrar los ficheros que fueron
cifrados con nuestra clave publica.

===============
Firmar archivos
===============

Una de las medidas de seguridad básicas al pasar un mensaje o fichero es
asegurarnos que el emisor es quien dice ser, para asegurarnos de esto
digitalmente existe la firma digital, podemos cifrar y a su vez firmar ficheros,
que es lo que haremos con el comando:

$ gpg -u [ID de la clave] --output [Archivo resultante] --sign [Archivo para firmar]

...e introduciendo la contraseña de la clave privada.

$ gpg -u 88651986 --output x_firmado.txt.gpg --sign x.txt

...

Necesita una frase contraseña para desbloquear la clave secreta
del usuario: "xxx xxx (xx) <mail@mail.xxx>"
clave RSA de 2048 bits, ID 88651986, creada el 201x-xx-xx

Introduzca frase contraseña: 

...

nos generará el fichero:

x_firmado.txt.gpg

========================================
Verificar y descifrar un archivo firmado
========================================

Cualquiera con la clave pública asociada a la que ha firmado el documento puede
leerlo, de la misma forma que desciframos un archivo (gpg -d [Archivo]) o
verificándolo únicamente con el comando gpg --verify [Archivo].

$ gpg --verify x_firmado.txt.gpg 

muestra...

gpg: Firmado el xxx xx xx 201x xx:xx:xx VET usando clave RSA ID 88651986
gpg: Firma correcta de "User_name Last_name (comment) <user@mail.xxx>"

=========================
Exportar la clave privada
=========================

Si queremos verificar o firmar desde otro equipo con nuestra clave privada
tenemos que tener nuestra clave privada en ese equipo, para eso es necesario
copiar el directorio .gnupg que está en el /home/user de la máquina en la cual
creamos la clave privada a la nueva máquina.

=========================
Configurar sudo en Debian
=========================

Sudo es un paquete que proporciona privilegios limitados de superusuario a
usuarios específicos, En GNU/Linux Debian no viene instalado por defecto.

1- Instalación

# apt install sudo

2- Una vez con el sudo instalado deberemos agregar nuestro usuario en la sección
"User privilege specification" en el archivo /etc/sudoers, de tal forma que la
sección quede así:

# nano /etc/sudoers

Agregamos tu_usuario ALL=(ALL) ALL despues de root, debe quedar así:

User privilege specification
root ALL=(ALL) ALL
tu_usuario ALL=(ALL) ALL

3- Guardamos con nano y listo!

Una vez configurado esto, ya podremos ejecutar acciones de administrador desde
una terminal común, anteponiendo el sudo a la acción a realizar.

=======================================================
Lista de fuentes de los paquetes de debian sources.list
=======================================================

===
Apt
===

Apt (Advanced Package Tool) es un set de herramientas del núcleo de Debian. Apt
hace posible: instalar, eliminar, mantener sus aplicaciones al día y mucho más.

Apt, que basicamente resuelve problemas de dependencias y busca los paquetes
solicitados, trabaja con dpkg, otra herramienta que maneja la instalación y
eliminación de paquetes (aplicaciones). Apt es muy poderoso, y se usa
frecuentemente desde la línea de comandos o consola/terminal. Sin embargo, hay
muchas herramientas GUI/Gráficas para ayudarle a usar Apt sin tener que tocar la
línea de comando.

Al presente, aptitude es la herramienta recomendada para interactuar con la
suite APT. Las herramientas APT deben ser usadas especificamente para manejar
acciones que no puedan ser manejadas por aptitude, o dónde se necesite mayor
control de las dependencias.

APT utiliza un archivo que enlista las "fuentes" en donde se encuentran los
paquetes. Este archivo es: /etc/apt/sources.list

/etc/apt/sources.list 

El contenido de este archivo, normalmente sigue este formato:

deb http://host/debian distribución sección1 sección2 sección3
deb-src http://host/debian distribución sección1 sección2 sección3

Los renglones arriba mencionados son ficticios y no deberán ser usados. La
primera palabra en cada línea, deb o deb-src, indican el tipo del archivo: ya
sea que contenga paquetes binarios (deb), esto es, los paquetes pre-compilados
que normalmente se usan o los paquetes fuente (deb-src), que son los códigos
originales, más el archivo de control de Debian (.dsc) y el diff.gz que
contienen los cambios necesarios para "debianizar" el programa.

Generalmente se encuentra lo siguiente por defecto en el archivo sources.list:

# See sources.list(5) for more information, especialy
# Remember that you can only use http, ftp or file URIs
# CDROMs are managed through the apt-cdrom tool.
deb http://http.us.debian.org/debian stable main contrib non-free
deb http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free
deb http://security.debian.org stable/updates main contrib non-free

# Uncomment if you want the apt-get source function to work
#deb-src http://http.us.debian.org/debian stable main contrib non-free
#deb-src http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free

Éstas son las líneas necesarias para una instalación básica de Debian. La primer
línea deb apunta al archivo en el servidor oficial la segunda línea apunta hacia
el archivo del servidor non-US y la tercera línea apunta hacia el archivo del
servidor de actualizaciones de seguridad.

Las dos últimas líneas están deshabilitadas (con un "#" al inicio), así que
apt-get las ignora. Éstas son las líneas de deb-src esto es, apuntan hacia los
paquetes fuente de Debian. Si frecuentemente descarga paquetes fuente para
probar o recompilar habilítelas (borrando el "#" al inicio de la línea).

El archivo /etc/apt/sources.list puede contener varios tipos de líneas. APT sabe
como interpretar líneas del tipo http, ftp, file (archivos locales, p.e., un
directorio que contiene un CD-ROM) y ssh, según mis conocimientos.

No olvide ejecutar el comando apt-get update después de modificar el archivo
/etc/apt/sources.list. Debe hacer esto para permitir a APT obtener la lista de
paquetes de las fuentes que especificó.

=====================================
Enlaces físicos y simbólicos en Linux
=====================================

===============
Enlaces físicos
===============

Un enlace físico no es más que una etiqueta o un nuevo nombre asociado a un
archivo. Es una forma de identificar el mismo contenido con diferentes nombres.

Éste enlace no es una copia separada del archivo anterior sino un nombre
diferente para exactamente el mismo contenido.

Para crear un enlace físico en Linux del archivo archivo.txt a nuevo_nombre.txt

$ ln archivo.txt nuevo_nombre.txt

El enlace aparecerá como otro archivo más en el directorio y apuntará al mismo
contenido de archivo.txt.

Cualquier cambio que se haga se reflejará de la misma manera tanto para
archivo.txt como para nuevo_nombre.txt.

Un enlace se puede borrar usando el comando rm de la misma manera en que se
borra un archivo, sin embargo el contenido del iniodo no se eliminará mientras
haya un enlace físico que le haga referencia. Esto puede tener varias ventajas,
pero también puede complicar la tarea de seguimiento de los archivos.

Un enlace físico tampoco puede usarse para hacer referencia a directorios o a
archivos en otros equipos.

==================
Enlaces simbólicos
==================

Un enlace simbólico también puede definirse como una etiqueta o un nuevo nombre
asociado a un archivo pero a diferencia de los enlaces físicos el enlace
simbólico no contiene los datos del archivo, simplemente apunta al registro del
sistema de archivos donde se encuentran los datos.

Tiene mucha similitud a un acceso directo en guindows o un alias en OS X.

Situados en "b" crearemos un enlace simbólico del fichero x.txt que está en la
carpeta "a".

b$ ln -s ../a/x.txt

Éste enlace también aparecerá como otro archivo más en el directorio y apuntará
al mismo contenido de archivo.txt, reflejando todos los cambios que se hagan
tanto para archivo.txt como para nuevo_nombre.txt.

Sobre un enlace simbólico también se pueden usar todos los comandos básicos de
archivos (rm, mv, cp, etc). sin embargo cuando el archivo original es borrado o
movido a una ubicación diferente el enlace dejará de funcionar y se dice que el
enlace está roto.

Un enlace simbólico permite enlazar directorios y, usando NFS, también permite
enlazar archivos fuera del equipo.

Ejemplo práctico:

# ln -s /etc/nginx/sites-available/prueba /etc/nginx/sites-enabled/

===========
debootstrap
===========

Es una herramienta que instala un sistema basado en Debian dentro de un
subdirectorio de otro sistema ya instalado. Esto no requiere un CD de
instalación, solamente acceso a al repositorio de Debian. Este puede también
ser instalado y ejecutado desde otro sistema operativo.

Definimos un directorio en la raíz del sistema donde se ejecutará el sistema
enjaulado, en este ejemplo lo mostrare para debían Wheezy pero siguiendo la
misma secuencia y sustituyendo adecuadamente se puede instalar cualquier versión
de debían.

======
Fuente
======

-https://wiki.debian.org/es/debootstrap

======
chroot
======

Todo lo que chroot hace es, para todos los procesos hijo, reemplazar el
directorio raíz con uno especificado.

======
Fuente
======

-https://wiki.debian.org/es/debootstrap

============
jaula chroot
============

Con los programas chroot y debootstrap, es posible configurar un sistema Debian
aislado en el cual poder entrar y hacer pruebas, sin temor alguno a destruir su
sistema principal.

# mkdir /home/user/jaulas/wheezy

Instalamos la aplicación necesaria para ejecutar la jaula:

# apt-get install debootstrap

Creamos la jaula indicando el mirror

$ sudo debootstrap wheezy /home/user/jaulas/wheezy http://ftp.us.debian.org/debian/

O usamos un repo local o mas cercano para que las descarga de los ficheros sea
mas rápida

# debootstrap wheezy /home/user/jaulas/wheezy http://debian.cenditel/debian/

Y también se puede especificar la arquitectura:

# debootstrap -arch i386 /home/user/jaulas/wheezy http://ftp.es.debian.org/debian

Cuando termine, dependiendo de la velocidad de descarga, habrá creado todo el
sistema básico para correr debían wheezy en el directorio definido.

Antes de ejecutar la jaula se deben montar algunos directorios:

# mount -o bind /proc /home/user/jaulas/wheezy/proc

Si senecesita conexión a periféricos como un módem usb o una impresora estos se
guardan en el directorio /dev/ por ende tambien se debe montar.

# mount -o bind /dev/ /home/user/jaulas/wheezy/dev/

# mount -o bind /dev/pts/ /home/user/jaulas/wheezy/dev/pts/

# mount -o bind /sys/ /home/user/jaulas/wheezy/sys/

o creamos un script para montar los directorios, creamos el script: montar.sh

---

#!/bin/bash
mount -o bind /proc /home/user/jaulas/wheezy/proc
mount -o bind /dev/ /home/user/jaulas/wheezy/dev/
mount -o bind /dev/pts/ /home/user/jaulas/wheezy/dev/pts/
mount -o bind /sys/ /home/user/jaulas/wheezy/sys/

---

y lo ejecutamos con:

# ./montar.sh

Para desmontar por alguna razón (borrar la jaula por ejemplo), creamos un
desmontar.sh:

---

#!/bin/bash
umount /home/user/jaulas/wheezy/proc
umount /home/user/jaulas/wheezy/dev/
umount /home/user/jaulas/wheezy/dev/pts/
umount /home/user/jaulas/wheezy/sys/

---

# ./desmontar

A partir de este momento ya tienes el sistema listo y puedes hacer cualquier
tipo de prueba sin que corra riesgo tu sistema base para salir de la jaula y
continuar con tu sistema solo debes ejecutar:

# exit

Para accecer a la jaula o ejecutarla debes ser usuario root o usar sudo

# chroot /home/user/jaulas/wheezy

========================
Problemas para desmontar
========================

Si no se dejan desmontar algunos recursos montados es porque aún se están
usando, ejecuta:

$ lsof | grep /home/user/Documentos/jaulas/bullseye

Esto te mostrará los procesos que están utilizando recursos dentro de la jaula
chroot. Debes finalizarlos o cerrarlos antes de desmontarla, con kill -9
y el ID de proceso se puede hacer.

$ kill -9 XXX

Detener servicios: Si estás ejecutando servicios dentro de la jaula chroot,
asegúrate de detenerlos antes de desmontarla. Puedes usar los comandos
específicos para detener los servicios, como systemctl stop, service stop, etc.,
dependiendo del sistema y servicios que estés utilizando dentro de la jaula.

Una vez que hayas realizado estos pasos y asegurado que no hay procesos o
aplicaciones utilizando la jaula chroot, intenta desmontarla nuevamente con el
comando:

# umount /home/user/Documentos/jaulas/bullseye/proc

Fuente
======

ChatGPT

======================================
Copia de seguridad de una jaula chroot
======================================

Es posible hacer una copia de la jaula chroot como una copia de seguridad del
estado actual. De hecho, hacer copias de seguridad periódicas de tu jaula chroot
es una práctica recomendada para evitar pérdida de datos o configuraciones
importantes.

Para hacer una copia de seguridad de tu jaula chroot, puedes seguir estos pasos:

Detener cualquier proceso en la jaula chroot: Antes de hacer una copia de
seguridad, asegúrate de detener todos los procesos y servicios que se estén
ejecutando dentro de la jaula. Esto garantizará que todos los archivos estén en
un estado coherente.

Copiar los archivos: Utiliza el comando cp para copiar todos los archivos y
directorios de la jaula chroot a una nueva ubicación de copia de seguridad.
Puedes hacerlo con el siguiente comando:

# cp -a /home/user/Documentos/jaulas/bullseye /ruta/donde/quieres/crear/la/copia

El argumento -a en cp garantiza que se conserve toda la estructura de
directorios, atributos y permisos durante la copia.

Desmontar la jaula chroot: Una vez que hayas hecho la copia de seguridad,
desmonta la jaula chroot utilizando el comando umount:

# umount /home/user/Documentos/jaulas/bullseye

Almacenar la copia de seguridad en un lugar seguro: Guarda la copia de seguridad
en un lugar seguro fuera de la jaula chroot original, preferiblemente en un
dispositivo de almacenamiento externo o en una ubicación que no esté sujeta a
los cambios que puedan ocurrir dentro de la jaula.

Recuerda que hacer copias de seguridad regulares te ayudará a mantener tus datos
y configuraciones seguros y te permitirá restaurar la jaula chroot en caso de
algún problema o pérdida de información. Siempre es recomendable realizar copias
de seguridad antes de realizar cambios significativos en la jaula chroot o al
actualizar el sistema operativo dentro de la jaula.

Fuente
======

ChatGPT

===========================
Instalar el paquete locales
===========================

# apt install locales y locales-all

$ dpkg-reconfigure locales

Escogemos las configuraciones regionales que desea generar:

es_VE.UTF-8 UTF-8

Configuración regional predeterminada para el entorno del sistema:
es_VE.UTF-8

==================================================
Montando una jaula para GNU-Linux Debian 10 Buster
==================================================

Instalar la jaula

# debootstrap buster /home/user/jaulas/debian/buster http://deb.debian.org/debian/

Montar directorios

# mount -o bind /proc /home/user/jaulas/debian/buster/proc/

# mount -o bind /dev/ /home/user/jaulas/debian/buster/dev/

# mount -o bind /dev/pts/ /home/user/jaulas/debian/buster/dev/pts/

# mount -o bind /sys/ /home/user/jaulas/debian/buster/sys/

El siguiente paso solo se realiza luego de comprobar que los archivos no
existan:

Copiar el archivo /etc/hosts del entorno principal al entorno chroot:

# cp /etc/apt/sources.list /home/user/jaulas/debian/buster/etc/apt/sources.list

# cp /etc/hosts /home/user/jaulas/debian/buster/hosts

Acceder a la jaula

# chroot /home/user/jaulas/debian/buster

====
Nota
====

Este sistema solo puede ejecutar aplicaciones en el terminal si se requiere
interfaz gráfica se debe utilizar una aplicación como Xnest que su utilización
te detallo a continuación:

$ sudo apt-get xnest

Ejecución:

En terminal 1 ejecutas 

$ Xnest -ac -geometry 800x600 :1 

en un segundo terminal inicias la jaula 

# sudo chroot /jaulas/wheezy 

y dentro de la jaula ejecutas 

# export DISPLAY=localhost:1 

En este momento toda aplicación que ejecutes en dicha jaula que posea interfaz
gráfica se mostrara en la pantalla mostrada por Xnest adicionalmente cabe
destacar que puedes colocar cualquier geometria de ventana al ejecutar xnest.

Cada ves que reinicies la pc debes volver a montar los directorios /proc,
/dev/pts y /dev, esto lo puedes automatizar agregando las siguientes siguientes
lineas en el archivo /etc/fstab o corriendo un script con esas sentencias.

/proc      /home/user/jaulas/wheezy/proc/        auto     bind 0       0
/dev       /home/user/jaulas/wheezy/dev/pts/     auto     bind 0       0
/dev/pts   /home/user/jaulas/wheezy/dev/pts/     auto     bind 0       0
/sys       /home/user/jaulas/wheezy/sys/      auto     bind 0       0

Descargamos los paquetes locales y locales-all y ejecutamos:

$ dpkg-reconfigure locales 

Escogemos las configuraciones regionales que desea generar:

es_VE.UTF-8 UTF-8

Configuración regional predeterminada para el entorno del sistema:
es_VE.UTF-8

Listo, jaula de wheezy lista!

=========================
Remover un entorno chroot
=========================

Desmontar los directorios montados y borrar el directorio que alverga la jaula
(wheezzy)

================================
El error con el update y el /tmp
================================

Couldn't create temporary file /tmp/apt.conf for passing config to apt-key

# chown root:root /tmp

# chmod ugo+rwXt /tmp

====================
Variables de entorno
====================

Las variables de entorno contienen información a la que se accede a través del
nombre de la variable (al igual que ocurre en los lenguajes de programación).

Por ejemplo, PWD es una variable de entorno. Algo que puedo comprobar así:

$ echo $PWD
/home/user

Lo que significa que el comando "pwd" es una llamada a "echo $PWD"

Consultar todas mis variables de entorno.

$ env

$ printenv

Crear una variable de entorno

$ export name_var=Value

Eliminar una variable de entorno

$ export name_var=

============
Terminal tty
============

tty es la consola que nos permite en GNU/Linux acceder a nuestro sistema
operativo fuera de su entorno gráfico (X-Window). En general disponemos de hasta
seis terminales, para acceder:

Ctrl + Alt + F1 para acceder a la primera, F2 para la segunda y así hasta F6
para la sexta y F7 para volver al entorno gráfico.

No debemos confundir las consolas tty con la que habitualmente usamos sobre el
entorno gráfico X-Window.

=======
tasksel
=======

El paquete Tasksel proporciona una interfaz sencilla para los usuarios que
quieren configurar su sistema para realizar una tarea específica. Este programa
es utilizado durante el proceso de instalación, pero los usuarios puede usarlo
también en cualquier momento.

=====================
Entorno de escritorio
=====================

Después de instalar un sistema básico, usted puede instalar el
DesktopEnvironment utilizando tasksel. La orden tasksel (ingresado como root)
le muestra algunas opciones (de alto nivel de abstraccion) para instalar
paquetes. Podría usted simplemente marcar la opción Desktop environment.

Instalará los paquetes de Gnome y algunos paquetes considerados como estándar
para un escritorio Debian.

====
dhcp
====

DHCP (siglas en inglés de Dynamic Host Configuration Protocol, en español
«protocolo de configuración dinámica de host») es un servidor que usa protocolo
de red de tipo cliente/servidor en el que generalmente un servidor posee una
lista de direcciones IP dinámicas y las va asignando a los clientes conforme
éstas van quedando libres, sabiendo en todo momento quién ha estado en posesión
de esa IP, cuánto tiempo la ha tenido y a quién se la ha asignado después. Así
los clientes de una red IP pueden conseguir sus parámetros de configuración
automáticamente.

============================
Asignación de direcciones IP
============================

Cada dirección IP debe configurarse manualmente en cada dispositivo y, si el
dispositivo se mueve a otra subred, se debe configurar otra dirección IP
diferente. El DHCP le permite al administrador supervisar y distribuir de forma
centralizada las direcciones IP necesarias y, automáticamente, asignar y enviar
una nueva IP si fuera el caso en que el dispositivo es conectado en un lugar
diferente de la red.

El protocolo DHCP incluye tres métodos de asignación de direcciones IP:

============================
Asignación manual o estática
============================

Asigna una dirección IP a una máquina determinada. Se suele utilizar cuando se
quiere controlar la asignación de dirección IP a cada cliente, y evitar,
también, que se conecten clientes no identificados.

=====================
Asignación automática
=====================

Asigna una dirección IP a una máquina cliente la primera vez que hace la
solicitud al servidor DHCP y hasta que el cliente la libera. Se suele utilizar
cuando el número de clientes no varía demasiado.

===================
Asignación dinámica
===================

El único método que permite la reutilización dinámica de las direcciones IP. El
administrador de la red determina un rango de direcciones IP y cada dispositivo
conectado a la red está configurado para solicitar su dirección IP al servidor
cuando la tarjeta de interfaz de red se inicializa. El procedimiento usa un
concepto muy simple en un intervalo de tiempo controlable. Esto facilita la
instalación de nuevas máquinas clientes.

Algunas implementaciones de DHCP pueden actualizar el DNS asociado con los
servidores para reflejar las nuevas direcciones IP mediante el protocolo de
actualización de DNS establecido en RFC 2136 (Inglés).

El DHCP es una alternativa a otros protocolos de gestión de direcciones IP de
red, como el BOOTP (Bootstrap Protocol). DHCP es un protocolo más avanzado, pero
ambos son los usados normalmente.

======================
Configuración del grub
======================

Fichero de configuración donde se define el tiempo de espera del grup para
mostrar la lista de SO disponibles y sus opciones.

/etc/default/grub

=====================================
w3m - Nnavegador web desde la consola
=====================================

w3m es un navegador web basados en texto/paginador.

# apt-get install w3m

Para iniciar el navegador en modo interactivo

$ w3m https://www.debian.org

Volcado de una página con formato de salida estándar

$ w3m https://www.debian.org -dump

=====================================
Atajos de teclado en modo interactivo
=====================================

Salir del navegador: q
Página anterior: B
Descargar página actual: a
Ir a inicio: g
Saltar al final: G
Desplazarse hacia arriba una página: -
Desplazarse hacia abajo una página: +
Abrir URL: U

=========================================
apg - generador automático de contraseñas
=========================================

apg (Automatic Password Generator)

Instalación:

# apt-get install apg

Apg es capaz de generar un listado de contraseñas.

Usa un algoritmo para generar contraseñas pronunciables e impronunciables
también permite generar contraseñas aleatorias definidas a partir de conjuntos
de símbolos definidos por el usuario (dígitos, letras mayúsculas y minúsculas, y
símbolos especiales.) Por defecto, apg genera 6 contraseñas con caracteres
alfanuméricos que además son pronunciables (en inglés)

$ apg

Please enter some random data (only first 16 are significant)
(eg. your old password):>
OrwefdyetEc6 (Or-wef-dyet-Ec-SIX)
9ovCaulvac5 (NINE-ov-Caulv-ac-FIVE)
EryidribMeb7 (Er-yi-drib-Meb-SEVEN)
beoddIcox2 (be-odd-Ic-ox-TWO)
Oamyalirl6 (Oam-yal-irl-SIX)
IgPiham1 (Ig-Pi-ham-ONE)

Ahora generemos 4 contraseñas con una longitud mínima de 8 caracteres, máxima de
12 y que además sean impronunciables, usan el segundo algoritmo:

-n x = Número de contraseñas a generar.
-m x = Mínimo de caractéres que deberá tener la contraseña.
-x x = Máximo de caractéres que deberá tener la contraseña.

$ apg -n 4 -m 8 -x 8 -a 1

Mínimo 8 máximo 12, incluyendo caractéres especiales.

$ apg -n 4 -m 8 -x 12 -a 1

Mínimo 8 máximo 12, incluyendo caractéres especiales en menor medida.

$ apg -n 4 -m 8 -x 12 -a 0

===================================================
Actualizar la versión de GNU/Linux Debian instalada
===================================================

En este ejemplo actualizaremos la versión GNU/Linux Debian 8 a la 9.

Actualizamos el fichero source.list con los repositorios de GNU/Linux Debian 9
Stretch. Como usuario root editamos y comentamos todo su contenido, los
comentarios en ese fichero comienzan con #.

# nano /etc/apt/sources.list

Una vez que todo esté comentado, agregamos lo siguiente:

# ==========================
# Debian GNU/Linux 9 Stretch
# ==========================

deb http://deb.debian.org/debian stretch-updates main
deb http://deb.debian.org/debian stretch main contrib non-free
deb http://http.debian.net/debian/ stretch main contrib non-free
deb http://security.debian.org/debian-security/ stretch/updates main
deb https://fasttrack.debian.net/debian-fasttrack/ stretch-fasttrack main contrib
deb https://fasttrack.debian.net/debian-fasttrack/ stretch-backports-staging main contrib

Actualizamos la lista de los repositorios con:

# apt-get update

Actualizamos los paquetes del sistema, para que instale las versiones de
GNU/Linux Debian 9 Stretch:

# apt-get upgrade

Finalmente actualizamos todo de manera inteligente y segura:

# apt-get dist-upgrade

Ahora Reiniciamos el sistema, con eso ya deberíamos estar en GNU/Linux Debian 9
Stretch:

# reboot

Hay que estar pendiente de la consola, porque seguro va a pedir revisión manual
de algunos paquetes, donde te dirá si quieres conservar la versión y
configuración actual, como ssh, vim, postgresql, otros...

====================
sources.list example
====================

En distribuciones GNU/Linux derivadas de Debian el fichero sources.list es el
archivo hallado donde se enlistan las "fuentes" o "repositorios" disponibles de
los paquetes de software candidatos a ser: actualizados, instalados, removidos,
buscados, sujetos a comparación de versiones, etc.

**The format is
deb <respository server/mirror> <repository name> <sub branches of the repo>

#===== Debian GNU/Linux Testing & Unstable =====

# Testing repository - main, contrib and non-free branches
#deb http://http.us.debian.org/debian testing main non-free contrib
#deb-src http://http.us.debian.org/debian testing main non-free contrib

# Testing security updates repository
#deb http://security.debian.org/ testing/updates main contrib non-free
#deb-src http://security.debian.org/ testing/updates main contrib non-free

# Unstable repo main, contrib and non-free branches, no security updates here
#deb http://http.us.debian.org/debian unstable main non-free contrib
#deb-src http://http.us.debian.org/debian unstable main non-free contrib

#===== Debian GNU/Linux 13 (Trixie) =====

deb https://deb.debian.org/debian trixie main non-free-firmware
deb https://security.debian.org/debian-security trixie-security main non-free-firmware
deb https://deb.debian.org/debian trixie-updates main non-free-firmware

#===== Debian GNU/Linux 12 (Bookworm) =====

deb http://deb.debian.org/debian bookworm main contrib non-free non-free-firmware
deb http://deb.debian.org/debian bookworm-updates main contrib non-free non-free-firmware
deb http://deb.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware

#===== Debian GNU/Linux 12 (Bookworm) espejo de CENDITEL =====

deb http://debian.cenditel/debian bookworm main contrib non-free non-free-firmware
deb http://debian.cenditel/debian bookworm-updates main contrib non-free non-free-firmware
deb http://debian.cenditel/debian-security bookworm-security main contrib non-free non-free-firmware

#===== Debian GNU/Linux 11 (bullseye) Updates =====

deb http://deb.debian.org/debian bullseye main contrib non-free
deb http://deb.debian.org/debian bullseye-updates main
# Actualizaciones de seguridad
deb http://security.debian.org/debian-security bullseye-security main contrib non-free

#===== Debian GNU/Linux 10 (Buster) Updates =====

deb http://deb.debian.org/debian buster main contrib non-free
deb-src http://deb.debian.org/debian buster main contrib non-free

deb http://security.debian.org/debian-security/ buster/updates main contrib non-free
deb-src http://security.debian.org/debian-security/ buster/updates main contrib non-free

#===== Non free =====

deb http://deb.debian.org/debian buster main contrib non-free
deb-src http://deb.debian.org/debian buster main contrib non-free

#===== Debian GNU/Linux 9 (Stretch) Updates =====

deb http://deb.debian.org/debian stretch main contrib non-free
deb-src http://deb.debian.org/debian stretch main contrib non-free

deb http://security.debian.org/debian-security/ stretch/updates main contrib non-free
deb-src http://security.debian.org/debian-security/ stretch/updates main contrib non-free

deb http://deb.debian.org/debian stretch-updates main contrib non-free
deb-src http://deb.debian.org/debian stretch-updates main contrib non-free

#===== Non free =====

#deb http://deb.debian.org/debian stretch main contrib non-free
#deb-src http://deb.debian.org/debian stretch main contrib non-free

#===== Debian GNU/Linux 8 (Jessie) Estable =====

# Repositorio Oficial
deb http://http.us.debian.org/debian/ jessie main contrib non-free
deb-src http://http.us.debian.org/debian/ jessie main contrib non-free
deb http://httpredir.debian.org/debian/ jessie main
deb-src http://httpredir.debian.org/debian/ jessie main

# jessie-updates, previously known as 'volatile'
deb http://httpredir.debian.org/debian/ jessie-updates main
deb-src http://httpredir.debian.org/debian/ jessie-updates main

# Repositorio de Seguridad
deb http://security.debian.org/ jessie/updates main contrib non-free
deb-src http://security.debian.org/ jessie/updates main contrib non-free
deb http://security.debian.org/ jessie/updates main
deb-src http://security.debian.org/ jessie/updates main

#===== Debian GNU/Linux 7 (Wheezy) Estable =====

#Repositorio Oficial
deb http://ftp.us.debian.org/debian/ wheezy main contrib
deb-src http://ftp.us.debian.org/debian/ wheezy main contrib

#Actualizaciones de Seguridad
deb http://security.debian.org/ wheezy/updates main contrib
deb-src http://security.debian.org/ wheezy/updates main contrib

#Actualizaciones de Wheezy
deb http://ftp.debian.org/debian wheezy-updates main contrib non-free
deb-src http://ftp.debian.org/debian wheezy-updates main contrib non-free

#Backports
deb http://ftp.debian.org/debian/ wheezy-backports main

#===== Debian GNU/Linux 8 (Jessie) Multimedia repo =====

deb http://www.deb-multimedia.org jessie main non-free
#or
#deb ftp://ftp.deb-multimedia.org jessie main non-free
#or
#deb http://www.deb-multimedia.org stable main non-free
#or
#deb ftp://ftp.deb-multimedia.org stable main non-free

#===== Debian GNU/Linux 7 (Wheezy) Multimedia repo =====

deb http://www.deb-multimedia.org wheezy main
#or
#deb ftp://ftp.deb-multimedia.org wheezy main
#or
#deb http://www.deb-multimedia.org oldstable main
#or
#deb ftp://ftp.deb-multimedia.org oldstable main

#===== CENDITEL mirror - Debian GNU/Linux 11 (Bullseye) =====

# Debian CENDITEL
deb http://debian.cenditel/debian bullseye main contrib non-free
deb http://debian.cenditel/debian bullseye-updates main contrib non-free
deb http://debian.cenditel/debian bullseye-proposed-updates main contrib non-free
deb http://debian.cenditel/debian bullseye-updates main contrib non-free
deb http://debian.cenditel/debian-security bullseye-security main contrib non-free
deb http://debian.cenditel/debian-multimedia bullseye main non-free

Para que no falle la firma del repositorio multimedia ejecute:

$ wget http://www.deb-multimedia.org/pool/main/d/deb-multimedia-keyring/deb-multimedia-keyring_2016.8.1_all.deb

Luego instale con dpkg

# dpkg -i *.deb

Pero se recomienda:

# Debian CENDITEL
deb http://debian.cenditel/debian bullseye main contrib non-free
deb http://debian.cenditel/debian bullseye-updates main contrib non-free
deb http://debian.cenditel/debian-security bullseye-security main contrib non-free

#===== CENDITEL mirror - Debian GNU/Linux 10 (Buster) =====

deb http://debian.cenditel/debian buster main contrib non-free
deb-src http://debian.cenditel/debian stretch main contrib non-free

deb http://debian.cenditel/debian buster-updates main contrib non-free
deb-src http://debian.cenditel/debian stretch-updates main contrib non-free

#===== CENDITEL mirror - Debian GNU/Linux 9 (Stretch) =====

deb http://debian.cenditel/debian stretch main contrib non-free
deb-src http://debian.cenditel/debian stretch main contrib non-free

deb http://debian.cenditel/debian stretch-updates main contrib non-free
deb-src http://debian.cenditel/debian stretch-updates main contrib non-free

deb http://debian.cenditel/debian-security stretch/updates main contrib non-free
deb-src http://debian.cenditel/debian-security stretch/updates main contrib non-free

#===== CENDITEL mirror - Debian GNU/Linux 8 (Jessie) Estable =====

deb http://debian.cenditel/debian/ jessie main contrib non-free
deb-src http://debian.cenditel/debian/ jessie main contrib non-free

# jessie-updates, previously known as 'volatile'
deb http://debian.cenditel/debian/ jessie-updates main contrib non-free
deb-src http://debian.cenditel/debian/ jessie-updates main contrib non-free

#deb http://repositorio.cenditel.gob.ve/debian/ jessie main contrib non-free
#deb http://tibisay.cenditel.gob.ve/repositorio jessie main contrib non-free

# Agregar la llave del repositorio al sistema, como root escribimos:
# wget -q -O- http://repositorio.cenditel.gob.ve/debian/repositorio_cenditel.asc | apt-key add -

#===== CENDITEL mirror - Debian GNU/Linux 7 (Wheezy) Estable =====

deb http://debian.cenditel/debian/ wheezy main
deb-src http://debian.cenditel/debian/ wheezy main

# wheezy-updates, previously known as 'volatile'
deb http://debian.cenditel/debian/ wheezy-updates main
deb-src http://debian.cenditel/debian/ wheezy-updates main

======================
Repositorios de Debian
======================

Aquí podemos encontrar un espejo donde poder descargar los paquetes de todas las
versiones de Debian:http://archive.debian.org/debian/README

O simplemente agregando el repositorio en el source.list, por ejemplo:

#deb http://archive.debian.org/debian/ squeeze main contrib
#deb http://archive.debian.org/debian/ wheezy main contrib
deb http://archive.debian.org/debian/ jessie main contrib

===========================================
Para compilacion y construcción de paquetes
===========================================

build-essential
gcc
dpkg-dev
fakeroot
cmake
devscripts
autoconf
automake
dh-make
debhelper
autotools-dev
gnupg
lintian
quilt
packaging-dev

==========
Desarrollo
==========

curl
Sublime (Instalar el .deb de la página o buscar en los repos, > a v2.)
python (Probarlo)
python-pip
virtualenv
virtualenvwrapper
python-requests
django (Opcional)
    pip install django-compressor (Opcional)
    pip install south (Opcional)
    pip install django-extensions (Opcional)

ruby (Probarlo)
ruby on rails (Opcional)
Qt-Creator (Opcional)

=====================
Navegador Web Firefox
=====================

Poner firefox en español.

# apt-get install firefox-esr-l10n-es-es

Descargar cualquier versión requerida de Mozilla Firefox
========================================================

Se puede hacer la descarga directa desde el directorio ftp oficial del proyecto

https://ftp.mozilla.org/pub/firefox/releases/

-----

adblock-plus para bloquear puplicidad.

https://addons.mozilla.org/es/firefox/addon/adblock-plus/

-----

Complemento de Firefox para traducir las páginas a español con un click.

https://addons.mozilla.org/es/firefox/addon/traduzir-paginas-web/

-----

Tema Hacker para firefox

https://addons.mozilla.org/es/firefox/addon/hacker-animated/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=rating

-----

Diccionario en español Venezuela para firefox

Marca en rojo las palabras mal escritas.

https://addons.mozilla.org/es/firefox/addon/diccionario-espa%C3%B1ol-venezuela/

===============================
Touch VPN, una VPN para Firefox
===============================

1) Navegar hasta https://addons.mozilla.org/es/firefox/addon/touch-vpn/

2) “Agregar a Firefox” y se instalará.

2) Ir a Touch Firefox VPN.

Aunque está en inglés no será ningún problema conectarte a cualquiera de las 7
ubicaciones disponibles de esta vpn, haces clic en donde dice “best choice” o
puedes escoger entre: Alemania, Canadá, Rusia, Países Bajos, Estados Unidos,
Francia y Reino Unido para cambiar tu IP.

=====================================
Complemento web developer form filler
=====================================

Complete formularios en sitios web, guarde los datos del formulario con un click
y rellene fácilmente los formularios con los datos guardados de nuevo con un
click.

Fuente
======

https://addons.mozilla.org/es/firefox/addon/web-dev-form-filler/

===========================================================================
Instalación de Virtualbox 6 con el .run de la página en GNU/Linux Debian 11
===========================================================================

Descargar el .run desde https://www.virtualbox.org/wiki/Linux_Downloads

De la lista, descargar el que dice "All distributions (built on EL6 and
therefore not requiring recent system libraries)"

En este caso he descargado el VirtualBox-6.1.22-144080-Linux_amd64.run

$ sudo apt install build-essential linux-headers-amd64

$ sudo chmod +x VirtualBox*.run

$ sudo ./VirtualBox*.run

Los siguientes pasos no los ejecuté, ya que sirvió hasta el paso anterior.

$ vboxversion=$(wget -qO - https://download.virtualbox.org/virtualbox/LATEST.TXT)

$ wget "https://download.virtualbox.org/virtualbox/${vboxversion}/Oracle_VM_VirtualBox_Extension_Pack-${vboxversion}.vbox-extpack"

$ sudo vboxmanage extpack install --replace Oracle_VM_VirtualBox_Extension_Pack-${vboxversion}.vbox-extpack

$ sudo usermod -aG vboxusers [username]

$ sudo reboot

=======================================================
Instalación de Virtualbox en GNU/Linux Debian 9 Stretch
=======================================================

Agregamos la siguiente línea en el /etc/apt/sources.list

deb http://download.virtualbox.org/virtualbox/debian stretch contrib

Añade la Public Key de VirtualBox 5.2

# apt-get install curl

$ curl -O https://www.virtualbox.org/download/oracle_vbox_2016.asc

# apt-key add oracle_vbox_2016.asc

# apt-get update

# apt-get install virtualbox-5.2

==========================================================================
Instalación en GNU/Linux Debian 9 Stretch desde los repositorios backports
==========================================================================

Agregamos la siguiente línea en el /etc/apt/sources.list

deb http://deb.debian.org/debian/ stretch-backports main contrib non-free

# apt-get update

# apt-get install virtualbox

=======================================================
Instalación de Virtualbox en GNU/Linux Debian 10 Buster
=======================================================

Hay que poner a apuntar a los repositorios de Stretch y seguir los pasos de
arriba y ligar que no haya peos con dependencias y versiones de paquetes,
prender una vela a Neo en este proceso.

# apt-get install virtualbox-5.2

y si da peo instalar

# apt install virtualbox-5.1

=================================================
Instalar Guest Additions de Virtual Box en Debian
=================================================

Primero instalamos los siguientes paquetes:

# apt-get install build-essential

# apt-get install linux-headers-$(uname -r)

En el menú de VirtualBox de la máquina “guest” con Debian pulsamos en
Dispositivos / Insertar imagen de CD de las Guest Additions.

Por lo general, Virtualbox trae integrada entre sus ficheros las Guest Additions
en una imágen .iso, siguiendo el paso anterior esa imagen debería montarse
automáticamente, ahora solo queda ejecutar el script de instalación:

# bash /media/cdrom0/VboxLinuxAdditions.run

Si no hay problemas con la instalación, reiniciamos la máquina virtual  y ya se
debería poder usar el modo pantalla completa, el modo fluido o la función de las
carpetas compartidas.

======================
Desinstalar VirtualBox
======================

# apt-get remove --purge virtualbox

# rm -rf VirtualBox\ VMs/

# rm -rf .config/VirtualBox/

Otra forma
==========

Si instaló VirtualBox a través del script de instalación, puede encontrar el
directorio donde está instalado ejecutando

$ cat /etc/vbox/vbox.cfg

# VirtualBox installation directory
INSTALL_DIR='/opt/VirtualBox'
# VirtualBox version
INSTALL_VER='6.1.22'
INSTALL_REV='144080'
# Build type and user name for logging purposes
BUILD_TYPE='release'
USERNAME='vbox'

Luego puede ejecutar el script de desinstalación ubicado en el directorio de
instalación. Suponiendo que esté instalado en /opt/VirtualBox, ejecute:

$ sudo /opt/VirtualBox/uninstall.sh

VirtualBox 6.1.22 r144080 has been removed successfully.

$ sudo rm -rf /opt/VirtualBox

Fuente
======

https://askubuntu.com/questions/703746/how-to-completely-remove-virtualbox

=====
Otros
=====

Usar tty en la máquina virtual

Entrar en tty1 desde la máquina virtual, lo mismo para ttyn...

RightCtrl + F1

===========
Gnome Boxes
===========

GNOME Boxes es una aplicación del entorno de escritorio GNOME, que se utiliza
para acceder a sistemas remotos o virtuales. Boxes utiliza las tecnologías de
virtualización QEMU, KVM y libvirt.

GNOME Boxes requiere que la CPU sea compatible con algún tipo de virtualización
sistida por hardware (Intel VT-x , por ejemplo); por lo tanto, GNOME Boxes no
funcionan con las CPU con procesador Intel Pentium / Celeron ya que carecen de
esta característica.

Instalación
===========

# apt-get install -y gnome-boxes qemu-kvm libvirt0 virt-manager bridge-utils

¿Dónde guarda Cajas las imágenes de los discos?
===============================================

/home/user/.local/share/gnome-boxes/images

================
Debian backports
================

Proporciona paquetes para nuevas versiones de determinadas aplicaciones que se
van incluyendo a lo largo del periodo de vida de la versión. Sin embargo desde
el sitio oficial (http://backports.debian.org/Instructions/) recomiendan
utilizar este repositorio con precaución ya que en ocasiones pueden existir
incompatibilidades de dependencias entre estos paquetes y los estables.

=====
bind9
=====

El Nombre de Dominio de Internet de Berkeley (BIND) implementa un servidor de
nombres de dominio de Internet. BIND es el servidor de nombres más ampliamente
utilizado en Internet, y tiene el respaldo del Consorcio de «Software» de
Internet, www.isc.org. Este paquete proporciona el servidor y los archivos de
configuración relacionados.

Instalación del paquete bind9

# apt-get install bind9 bind9-doc

Editamos /etc/resolv.conf para que lea el localhost

nameserver 127.0.0.1

En /etc/bind están los archivos de configuración del paquete.

====
vlan
====

Una VLAN, acrónimo de virtual LAN (Red de área local virtual), es un método para
crear redes lógicas independientes dentro de una misma red física.

Varias VLAN pueden coexistir en un único conmutador físico o en una única red
física. Son útiles para reducir el tamaño del dominio de difusión y ayudan en la
administración de la red, separando segmentos lógicos de una red de área local
(los departamentos de una empresa, por ejemplo) que no deberían intercambiar
datos usando la red local (aunque podrían hacerlo a través de un enrutador o un
conmutador de capa 3 y 4).

Una VLAN consiste en dos o más redes de computadoras que se comportan como si
estuviesen conectados al mismo conmutador, aunque se encuentren físicamente
conectados a diferentes segmentos de una red de área local (LAN). Los
administradores de red configuran las VLAN mediante software en lugar de
hardware, lo que las hace extremadamente fuertes.

===
vpn
===

Una red privada virtual (en inglés: Virtual Private Network (VPN)) es una
tecnología de red de computadoras que permite una extensión segura de la red de
área local (LAN) sobre una red pública o no controlada como Internet.

Permite que la computadora en la red envíe y reciba datos sobre redes
compartidas o públicas como si fuera una red privada con toda la funcionalidad,
seguridad y políticas de gestión de una red privada.

Esto se realiza estableciendo una conexión virtual punto a punto mediante el uso
de conexiones dedicadas, cifrado o la combinación de ambos métodos.

Ejemplos comunes son la posibilidad de conectar dos o más sucursales de una
empresa utilizando como vínculo Internet, permitir a los miembros del equipo de
soporte técnico la conexión desde su casa al centro de cómputo, o que un usuario
pueda acceder a su equipo doméstico desde un sitio remoto, como por ejemplo un
hotel. Todo ello utilizando la infraestructura de Internet.

La conexión VPN a través de Internet es técnicamente una unión wide area network
(WAN) entre los sitios pero al usuario le parece como si fuera un enlace
privado, de allí la designación "virtual private network".

===================================
Desactivar actualización en firefox
===================================

Probado en Firefox 55 o menor.

La desactivación la podemos hacer desde la interfáz del navegador pero para
hacerla a nivel de codigo editamos el fichero:

firefox/defaults/pref/channel-prefs.js

Nos quedará así:

---

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/*pref("app.update.channel", "release");*/
pref("app.update.channel", "false");

---

Guardamos, reiniciamos el firefox y listo, actualizaciones desactivadas.

=====================
Reiniciar un servicio
=====================

Funcional para GNU/Linux Debian 7 Wheezy

user@debian7:~$ /etc/init.d/ssh 
force-reload  reload        restart       start         status        stop          try-restart   
user@debian7:~$ /etc/init.d/ssh restart

==========================================================
Instalar esto para porder descargar repositorios con https
==========================================================

# apt-get install apt-transport-https

=================================================
Winetricks, Instalando librerias (DLLs) para Wine
=================================================

Wine es la aplicacion que generalmente empleamos para ejecutar aplicaciones de
Windows en Linux, pero muchas veces, la aplicacion falla porque no tenemos una
determinada libreria de enlace dinamico (DLL) instalada. Winetricks es un script
que nos va a ayudar un poco en esta faena, con este script podemos descargar e
instalar en wine, las principales librerias que nos solicitan los programas
windows.

Para instalarlo:

$ sudo apt install cabextract

$ wget https://raw.githubusercontent.com/Winetricks/winetricks/master/src/winetricks

Le damos permisos de ejecucion:

$ chmod +x ./winetricks

Y si quisieramos ya instalar una determinada libreria, podriamos hacerlo
directamente. Por ejemplo:

$ sh winetricks corefonts vcrun6

Para instalar unas fuentes de texto, y el runtime de VisualC.

Si lo ejecutamos sin parametros, se abre una ventana y nos permite seleccionar
las librerias a instalar.

======
Fuente
======

https://ubuntulife.wordpress.com/2008/10/16/winetricks-instalando-librerias-dlls-para-wine/

https://github.com/Winetricks/winetricks

=====
xkill
=====

Probado en gnome-desktop

xkill permite formar el cierre de programas rebeldes desde la interfáz gráfica,
con solo escribir xkill en la consola el cursor del mouse se transforma en una
calavera, acto seguido podemos cliquear derecho sobre alguna ventana para matar
ese proceso.

$ xkill

===================
Instalar Unetbootin
===================

Netbootin le permite crear unidades USB Live de Ubuntu y otras distribuciones de
Linux sin necesidad de grabar un CD.

Página para descarga: https://unetbootin.github.io/linux_download.html

Podemos descargamos directamente el .bin, este enlace es para arquitecturas de
64bits

$ wget -c https://github.com/unetbootin/unetbootin/releases/download/657/unetbootin-linux64-702.bin

Eso nos descargara el fichero unetbootin-linux64-702.bin

Instalamos lo siguiente, que son unas herramientas para manipular archivos
MSDOS.

# apt-get install mtools

Ejecutamos el programa unetbootin-linux64-702.bin

# ./unetbootin-linux64-702.bin

Listo, se nos debería ejecutar la ventana del programa.

Si da problemas de permiso denegado cambiamos los permisos del script .bin

# chmod -R 777 unetbootin-linux64-702.bin

Luego, ejecutamos el programa unetbootin

# ./unetbootin-linux64-702.bin

============================================
Instalar Google Chrome en GNU/Linux Debian 8
============================================

Primero hay que añadir un repositorio de google en el  /etc/apt/sources.list, es el siguiente:

# Chrome de 64bits
deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main

Ahora añadimos la llave pública del repositorio “Google Chrome stable” a apt.

# gpg --keyserver keys.gnupg.net --recv-key A040830F7FAC5991

# gpg --export --armor A040830F7FAC5991 | apt-key add -

Actualizamos la lista de paquetes de los repositorios.

# apt-get update

Si sale el siguiente error:

W: No existe ninguna clave pública disponible para los siguientes
identificadores de clave:
1397BC53640DB551

Ejecutamos los siguiente:

# wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | apt-key add -

Actualizamos la lista de paquetes de los repositorios.

# apt-get update

Ahora instalamos Google Chrome stable con:

# apt-get install google-chrome-stable

Si toda va bien, debería estar disponible en la sección internet de nuestro
GNU/Linux Debian 8 o 9

Actualizar chrome
=================

1- Se debe tener habilitado esto en los repos:

deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main

2- Luego actualizar la lista de paquetes:

$ sudo apt update

$ sudo apt install --only-upgrade google-chrome-stable

==================================================
Instalar Google Chrome en GNU/Linux Debian 10 y 11
==================================================

Debes descargar el paquete de la siguiente URL:

https://www.google.com/chrome/

En este caso, descargué el de 64Bits

Antes de instalar el paquete debes tener instalada el paquete wget, que es una
dependencia que se debe cumplir para poder instalar Chrome, lo puedes hacer con
este comando:

$ sudo apt install wget libappindicator3-1

De libappindicator, Instalas el que esté disponible, en mi caso el 3-0.

Luego puedes instalar Google Chrome, mediante el comando:

$ sudo dpkg -i google-chrome-stable_current_amd64.deb

Luego lo lanzas con:

$ google-chrome

Listo!

=======================================
Instalar Chromium en GNU/Linux Debian 8
=======================================

# apt-get install chromium chromium-l10n

======
cheese
======

# apt-get install cheese

A webcam application that supports image and video capture.

Paquete para probar la cámara web de la computadoras/laptop en debian.

===========
pavucontrol
===========

# apt-get install pavucontrol

PulseAudio Volume Control (pavucontrol) es una herramienta de control de volumen
basada en GTK + (mezclador) para el servidor de sonido PulseAudio. A diferencia
de las herramientas de mezclador clásicas, esta le permite controlar tanto el
volumen de los dispositivos de hardware como los de cada secuencia de
reproducción por separado. También le permite redirigir una secuencia de
reproducción a otro dispositivo de salida sin interrumpir la reproducción.

=====================================
Debian 8 (live cd) login and password
=====================================

username "user" and the default password "live".

=============================================================
Resetear password o contraseña del usuario root desde el grub
=============================================================

Cuando inicia la pc y estando en el grub, seleccionamos editar presionando la
letra e

Esto nos abre un fichero que podemos editar, ubicamos la parte que dice:

linux /boot/vmlinuz-3.2.0-4-xxx-xxx root=UUID=04064ae3XXXXXXXX ro quiet

y agregamos al final de esa línea lo siguiente: init=/bin/bash y nos quedará así:

linux /boot/vmlinuz-3.2.0-4-xxx-xxx root=UUID=04064ae3XXXXXXXX ro quiet init=/bin/bash

Presionamos f10 para que se guarden los cambios y continúe con la carga del
sistema, luegos nos aparece la terminal o consola, como root.

Escribiremos el siguiente comando para montar el sistema de ficheros:

# mount -o remount -rw /

Luego ya procedemos a cambiar la contraseña de root, ejecutamos el comando:

# passwd root

El sistema nos pide la nueva contraseña, luego nos pide que la volvamos a
escribir la nueva contraseña y validara que sea iguales. (cuando ponemos la
contraseña por seguridad en linux no aparece lo que tecleamos y al terminar de
poner la contraseña pulsamos enter y ¡listo! Contraseña del usuario root
cambiada.

=======
Fuentes
=======

http://primeros-pasos-linux.blogspot.com/2013/03/guia-pasoa-apaso-recuperar-contrasena.html

==================================
Encriptar directorios con Ecryptfs
==================================

ECryptfs es una herramienta que nos permite encriptar la informacion contenida
en un directorio.

Instalamos ecryptfs:

# apt-get install ecryptfs-utils

Creamos el directorio a encriptar

$ mkdir private

Asignamos permisos para que solo nuestro usuario pueda acceder

$ chmod 700 private

Montamos el nuevo filesystem eCryptfs en la nueva carpeta creada:

# mount -t ecryptfs private private

Nos hara una serie de preguntas como la palabra secreta a utilizar. Por defecto
usa la encriptación AES, con una longitud de 16 bytes de longitud.

En resumen, las preguntas que nos hace son:

La passphrase o la clave para la encriptación.

El algoritmo de cifrado que de manera predeterminada es AES.

Magnitud de la clave, que es de 16 bytes de manera predeterminada Plaintext
passthrough para poder llegar a ficheros que no están cifrados.

filename encryption o encriptar los nombres de los ficheros, esta opción me ha
dado algunos problemas, me falta seguir probandola bien para poder recomendarla,
por ahora no la usaremos.

# mount -t ecryptfs private private
Select key type to use for newly created files:
 1) tspi
 2) passphrase
Selection: 2
Passphrase:
Select cipher:
 1) aes: blocksize = 16; min keysize = 16; max keysize = 32
 2) blowfish: blocksize = 8; min keysize = 16; max keysize = 56
 3) des3_ede: blocksize = 8; min keysize = 24; max keysize = 24
 4) twofish: blocksize = 16; min keysize = 16; max keysize = 32
 5) cast6: blocksize = 16; min keysize = 16; max keysize = 32
 6) cast5: blocksize = 8; min keysize = 5; max keysize = 16
Selection [aes]: 1
Select key bytes:
 1) 16
 2) 32
 3) 24
Selection [16]: 1
Enable plaintext passthrough (y/n) [n]: n
Enable filename encryption (y/n) [n]: n
Attempting to mount with the following options:
  ecryptfs_unlink_sigs
  ecryptfs_key_bytes=16
  ecryptfs_cipher=aes
  ecryptfs_sig=5e2dd35dd40f619a
Mounted eCryptfs

Ahora ya podemos crear archivos, moverlos, trabajar dentro del directorio
private.

Cuando terminemos de trabajar con el directorio private, desmontamos el sistema
de ficheros.

# umount private

Si ahora accedemos a la carpeta, veremos los nombres de los ficheros y
directorios, pero si intentamos abrirlos veremos que estan encriptados y no
podemos ver la informacion. Podemos usar un editor hexadecimal para ver su
contenido, pero no sera legible.

Si queremos volver a acceder a los archivos, tendremos que montar de nuevo el
filesystem

# mount -t ecryptfs private private

Nos pedira la frase de paso para poder desencriptar, tambien que respondamos a
las otras preguntas que respondimos cuando hicimos la primera encriptación, pero
podemos dar enter a todas(usar los valores por defecto), si todo esta bien nos
debe mostrar el mensaje: Mounted eCryptfs.

=======
Fuentes
=======

-https://ubuntulife.wordpress.com/2008/08/07/crea-un-directorio-privado-encriptado-con-ecryptfs/
-https://blog.desdelinux.net/cifra-directorios-en-gnulinux-con-ecryptfs/

=======================================
Reducir tamaño de ficheros mp3 con Lame
=======================================

Lame es una biblioteca de codificación MP3

Un poco de teoría primero

Mono

Una señal monofónica es una señal grabada con un solo micrófono.

Al escuchar la grabación con dos altavoces o auriculares, la señal se duplica y
oímos lo mismo por la izquierda que por la derecha. Al grabar una voz con un
solo micrófono, lo haremos en una pista mono de nuestro programa de grabación.

Stereo

En cambio, una señal estereofónica es una señal grabada con un "par stereo"
(pareja de dos micrófonos iguales). Al escuchar la grabación, por la izquierda
oímos la grabación de un micrófono y por la derecha la del otro. Al grabar un
ambiente la diferencia entre mono y stereo se nota muchísimo. Una grabación en
stereo es mucho más realista ya que los humanos lo escuchamos todo por dos
oídos. Cuando grabamos una batería acústica, utilizamos un par stereo (aereos)
para captar los platos y un poco de ambiente.

Debes saber que…

Un archivo en stereo “pesa” aproximadamente el doble que el mismo archivo en
mono, siempre que sea la misma señal de audio. Cuando digo que un archivo "pesa"
me refiero al espacio que dicho archivo ocupa en el disco duro de tu ordenador.

El archivo mono solo contiene una pista mientras que el archivo en stereo
contiene dos, una para la señal izquierda y otra para la
derecha, y se tienen que guardar el doble de datos.

Instalamos lame:

# apt-get install lame

Entre los parámetros que podemos usar están:

-b 90 es el BitRate, si deseamos otro distinto lo modificamos.

-q 0 puede ser sustituida por -h (-q 2), hay que tener en cuenta que
cuanto menor sea la calidad, mayor es la velocidad de conversión, el rango va del 0 al 9.

-a mono channel

-s stereo channel

Con el siguiente comando las canciones se comprimen pero resultan en canal mono:

$ lame -a -h -b 90 -q 0 archivo_a_reducir.mp3 archivo_resultante.mp3

Con el siguiente comando las canciones se comprimen pero resultan en canal
stereo:

$ lame -s -h -b 90 -q 0 archivo_a_reducir.mp3 archivo_resultante.mp3

y listo, la compresión es cerda del 50% en relación al peso anterior y no se
nota en la calidad del audio, mejor dicho, es casi imperceptible un cambio o
baja en al calidad del audio.

=======
Fuentes
=======

-http://www.kacharreando.com/ubuntu/reducir-mp3/
-http://www.comograbar.com/conceptos-basicos/diferencia-entre-mono-y-stereo/

====================================================
Instalar steam client en GNU/Linux Debian de 64 bits
====================================================

1- Descargar el .deb de la página oficial de steam, debe ser el archivo
steam_latest.deb

2- Habilitar el soporte multi-arch y actualizar la lista de paquetes
disponibles:

# dpkg --add-architecture i386

$ sudo aptitude update

3- Instalar esta dependencia dependencia

$ sudo apt-get install libc6-i386

# dpkg -i steam_latest.deb

4- Luego ya saldrá steam en las opciones del menú, al darle click, te pide dar
enter para actualizarse.

Nota: Lo anterior no me funciono, me dio problemas de dependencias, hay que
probarlo bien.

Instalación con snap
====================

Nota: Leer guía de Sanp por si hay dudas.

$ sudo apt update

$ sudo apt install snapd

$ sudo snap install core

$ sudo snap install steam --candidate

=============================================================
Cambiar el nombre de la máquina o el host en GNU/Linux Debian
=============================================================

El hostname es el nombre que configuramos para la máquina en el momento de la
instalación del sistema operativo, después de la instalación del sistema este
nombre puede ser alterado.

El nombre del sistema, o hostname, está guardado en el archivo /etc/hostname.

Este archivo debe contar sólo con el nombre del sistema y no con el nombre
completo del dominio: 

Para ver el nombre del host, En este caso el nombre es debian.:

$ hostname

mi_user@debian:~$

Para cambiar el hostname editamos el archivo /etc/hostname 

# vim /etc/hostname

Tambien editamos a /etc/hosts y cambiamos el nombre de la máquina:

# vim /etc/hosts

Ahora corremos para reiniciar el servicio de hostname

# /etc/init.d/hostname.sh start

ó

# invoke-rc.d hostname.sh start

Para ver si se hizo el cambio correctamente escribimos:

$ hostname

A veces es mejor cerrar sesión y volver a entrar a ver si se hizo el cambio.

========================================================
Ajustar el brillo del monitor desde la línea de comandos
========================================================

Primero, necesitamos verificar el estado actual de la visualización del sistema.
Para hacerlo, ejecuta:

$ xrandr -q

Salida

Screen 0: minimum 320 x 200, current 1366 x 768, maximum 8192 x 8192
LVDS-1 connected primary 1366x768+0+0 (normal left inverted right x axis y axis) 344mm x 194mm
1366x768 60.00*+ 40.00
1280x720 60.00 59.99 59.86 59.74
1024x768 60.04 60.00
960x720 60.00
928x696 60.05
896x672 60.01
.
.
.

ó

$ xrandr | grep ' connected'

El valor de brillo debe estar entre 0.0 y 1.0, donde 0.0 se refiere al valor más
bajo (negro completo) y 1.0 se refiere al valor más brillante. Por ejemplo para
configurar el valor de brillo de la pantalla como 0.7, ejecuta:

$ xrandr --output LVDS-1 --brightness 0.7

No uses nada por encima de 1.0. Puede convertir la pantalla en blanco completo y
es posible que no veas claramente nada.

============================================
Activar pantalla HDMI cuando no es detectada
============================================

$ xrandr --setprovideroutputsource 1 0

======
Fuente
======

https://maslinux.es/como-ajustar-el-brillo-del-monitor-desde-la-linea-de-comandos-en-gnu-linux/

=========================================================
Instalar la última versión del kernel disponible (estable)
=========================================================

# apt-get update

# apt-get install linux-image-amd64

# apt-get dist-upgrade

# reboot

===============================
Instalar WPS Office en Debian 9
===============================

1) Instalar Qt 4 Settings

# apt install qt4-qtconfig

2) Entrar en Qt 4 Settings

$ qtconfig-qt4

3) Selecione GTK+ en Qt Conifiguration > GUI Style y guardar los cambios.

4) Descargar e instalar la dependencia libpng12

$ wget -c http://ftp.us.debian.org/debian/pool/main/libp/libpng/libpng12-0_1.2.50-2+deb8u3_amd64.deb

# dpkg -i libpng12-0_1.2.50-2+deb8u3_amd64.deb

5) Descargar e instalar de WPS Office

$ wget -c http://kdl1.cache.wps.com/ksodl/download/linux/a21//wps-office_10.1.0.5707~a21_amd64.deb -O wps-office.deb

$ wget -c http://kdl.cc.ksosoft.com/wps-community/download/fonts/wps-office-fonts_1.0_all.deb -O fonts.deb

# dpkg -i *.deb

6) Abrir WPS Office desde el menú o con el comando:

$ wps

===============================
Instalar las fuentes faltantes
===============================

1) Descargar el .zip desde https://github.com/IamDH4/ttf-wps-fonts, este fichero
contiene las fuentes que necesita WPS Office para que no se queje con el mensaje
que sale, luego de descargarlo lo descomprimimos

2) Borramos todos los archivos descomprimidos exeptuando los .ttf y TTF y los
guardamos en una carpeta que llamaremos wps_office.

3) Copiamos la carpeta creada que contiene las fuentes a la ruta
/usr/share/fonts/truetype/

$ sudo cp -r wps_office /usr/share/fonts/truetype/

4) Recargamos las fuentes del sistema

# fc-cache -f -v

Listo ya podemos abrir WPS Office y no debería quejarse por fuentes faltantes.

==============================
Poner en español el WPS Office
==============================

1) Descargar el fichero wps-full-fix-es_1.0-2019_all.deb desde aquí:

https://drive.google.com/file/d/1WjvO0tGffN0nI7uAxoq9VR-DmHdqmjlE/view?usp=sharing

2) Instalar el fichero descargado

$ sudo dpkg -i wps-full-fix-es_1.0-2019_all.deb

3) Abrir WP Office y cambiar el idioma en el ícono con la letra A que está
debajo de la X y el de minimizar, al lado de "?".

==================================
Instalar el diccionario en español
==================================

1) Desde http://wps-community.org/download/dicts descargamos es_ES.zip

2) Descomprimimos el fichero y eso nos deja la carpeta es_ES

3) Copiamos la carpeta es_ES a la ruta /opt/kingsoft/wps-office/office6/dicts/spellcheck

# cp -r es_ES /opt/kingsoft/wps-office/office6/dicts/spellcheck/

4) Ahora ya podemos abrir WPS Office. Nos dirigimos a la pestaña Revisar,
clicamos el botón de Revisión Ortográfica y cuando aparezca el submenú clicamos
encima de Establecer idioma. A continuación aparecerá la ventana donde tenemos
que seleccionar el idioma del corrector ortográfico. En nuestro caso
seleccionamos Español y presionamos encima del botón Establecer predeterminado.

La verdad es que lo estuve probando y esa verga funciona ahí más o menos, se
recomienda tener cuidado con la escritura.

=========================
Instalar megasync desktop
=========================

Descargar el .deb desde https://mega.nz/sync, en este caso descargué
megasync-Debian_9.0_amd64.deb

# apt-get install libc-ares2 libcrypto++6 libmediainfo0v5 libtinyxml2-4 libzen0v5 apt-transport-https libraw10

# dpkg -i megasync-Debian_9.0_amd64.deb

Listo!!!

===============================
Problema con /var/lib/dpkg/lock
===============================

Si da problemas con el fichero dir/dir/lock por ejemplo, lo borramos

# rm -f dir/dir/lock

No se pudo bloquear /var/lib/dpkg/lock - open (11: Recurso no disponible
temporalmente)

Solución...

$ sudo fuser -vki /var/lib/dpkg/lock

========================================
Problema con /var/lib/dpkg/lock-frontend
========================================

Citing for cache lock: Could not get lock /var/lib/dpkg/lock-frontend. It is
held by process 1434 (packagekitd)... 54s

Solución...

$ sudo fuser -vki /var/lib/dpkg/lock

-----

En Debian 11 Bullseye el problema puede ser:

E: Could not get lock /var/lib/apt/lists/lock. It is held by process 1232 (packagekitd)
N: Be aware that removing the lock file is not a solution and may break your system.

# rm -f /var/lib/apt/lists/lock

------

Simple, easy to use paint program for GNOME

gnome-paint

-----

Herramienta sencilla para la edición de menús de GNOME

alacarte

-----

Muestra un árbol de directorios con sangría, en color.

tree

-----

Busca y muestra información sobre el sistema operativo que estemos utilizando,
datos como el tipo de distribución, kernel, entorno de escritorio, windows
manager, CPU, themes, RAM, etc.

screenfetch

==================================
Grabar el escritorio de la máquina
==================================

kazam

$ sudo apt-get install kazam

Para abrirlo.

$ kazam

O buscarlo en el menú de programas.

==================================
Grabar el escritorio de la máquina
==================================

Vokoscreen

$ sudo apt install vokoscreen

Para abrirlo:

$ vokoscreen

O buscarlo en el menú de programas.

=============================
Grabar el audio de la máquina
=============================

Lista filtrada de dispositivos de audio del sistema.

$ pacmd list-sources | egrep '^\s+name: .*alsa_output'

Eso nos mostrará algo como esto:

name: <alsa_output.pci-0000_00_1b.0.analog-stereo.monitor>

Luego de identificar el dispositivo usaremos el comando para grabar el audio de
la máquina usando el dispositivo que identificamos:

$ parecord --channels=1 -d alsa_output.pci-0000_00_1b.0.analog-stereo.monitor grabacion.wav

Con Ctrl + c detenemos la grabación.

Nota: En Linux Debian 12 ya no funciona porque el sistema migró a PipeWire, que
reemplaza a PulseAudio en muchas distribuciones modernas (Fedora, Ubuntu, etc.).

Otra opción es usar es usa ffmpeg

========================================
Grabar el audio de la máquina con ffmpeg
========================================

1. Identificar el dispositivo de monitorización:

$ pactl list short sources

Salida:

50	alsa_output.pci-0000_00_1b.0.analog-stereo.monitor	PipeWire	s32le 2ch 48000Hz	IDLE
51	alsa_input.pci-0000_00_1b.0.analog-stereo	PipeWire	s32le 2ch 48000Hz	SUSPENDED

En tu lista aparece:
50 alsa_output.pci-0000_00_1b.0.analog-stereo.monitor

Este es el dispositivo que necesitas (termina en .monitor).

2- Grabar el audio con ffmpeg:

$ ffmpeg -f pulse -i alsa_output.pci-0000_00_1b.0.analog-stereo.monitor -c:a pcm_s16le grabacion.wav

Esto creara el archivo grabacion.wav.

Fuente
======

DeepSeek

===============================================
Particionado recomendado de discos en GNU/Linux
===============================================

* swap: Las particiones swap sirven para soportar la memoria virtual. En otras
palabras los datos se escriben en una partición swap cuando no hay suficiente
memoria RAM para almacenar la información que su sistema está procesando.

* /boot: La partición montada en /boot/ contiene el kernel del sistema operativo
(el cual permite a su sistema arrancar el SO) junto con archivos utilizados
durante el proceso de arranque.

* /: Aquí es donde se localiza "/" (el directorio raíz). En esta configuración,
todos los archivos (excepto aquellos almacenados en /boot) están en la partición
raíz.

La partición / (o raíz) es la cima de la estructura del directorio. El
directorio /root (algunas veces pronunciado "slash-root") es el directorio
principal de la cuenta del usuario-administrador del sistema.

* /home: Para almacenar datos de forma independiente de los datos del sistema,
cree una partición dedicada dentro de un grupo de volumen para el directorio
/home. Así podrá actualizar o reinstalar el SO sin borrar archivos de datos de
los usuarios.

Imaginemos que tenemos un disco SATA de 500GB.

-- Partición primaria:

/boot = 500mb

-- Particiones extendidas:

swap = El doble de la memoria RAM

/ = 30 GB

/home = 465GB o lo que sobre para los usuarios del SO

El particionamiento no es una ciencia exacta, y mucho menos con las miles de
combinaciones que hay, pero os aseguramos que separar el punto de montaje /home
del resto nos ahorrará muchos problemas, sobre todo en actualizaciones, donde
no perderemos ni un solo dato.

===================
Instalación de Mate
===================

# apt-get install mate-desktop-environment-extras

========================================
Conectar 2 computadoras de punto a punto
========================================

Conectar con un cable de red, de puerto eternet a puerto eternet 2 pc

Entrar en la pc A, luego escribimos:

% ip link

Con esto veremos los dispositivos de red y su configuración, algo como esto

user@debian:~$ ip link
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc pfifo_fast state DOWN mode DEFAULT group default qlen 1000
    link/ether 00:26:2d:9c:39:12 brd ff:ff:ff:ff:ff:ff
3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DORMANT group default qlen 1000
    link/ether 88:9f:fa:4d:5d:53 brd ff:ff:ff:ff:ff:ff

Falta probar bien...

================
Telegram desktop
================

===========
Instalacion
===========

Para instalar el telegram desktop se debe descargar y descomprimir el fichero
desde la pagina oficial de telegram, al descomprimir nos dejara un directorio
que contiene 2 ficheros:

Telegram Updater

Para ejecutar la instalacion, ejecutamos desde la consola:

$ ./Telegram

Luego de eso, si no hay errores, deberia aparecer en el menu el icono de
telegram.

================
Remover Telegram
================

Borramos la carpeta donde esta el script de instalacion de telegra, la del paso
anteior, de la de instalacion

y tambien borramos la carpeta que esta en el hoem del usuario:

.local/shares/TelegramDesktop

=======================
Instalar snap en Debian
=======================

En Debian 9 (Stretch) y Debian 10 (Buster), snap puede ser instalado
directamente desde la linea de comandos con:

$ sudo apt update

$ sudo apt install snapd

$ snap install core

$ snap install hello-world

hello-world 6.3 from Canonical✓ installed

Este paso final no se por que coño no me funciono.

$ hello-world

Hello World!

======================
Solucion de aviso dpkg
======================

dpkg: aviso: `ldconfig' no se ha encontrado en el PATH o no es ejecutable

Ejecutar:

$ echo 'export PATH=$PATH:/usr/local/sbin:/usr/sbin:/sbin' >> /home/usuario/.bashrc

Otro error...

dpkg: atención: `ldconfig' no se ha encontrado en el PATH o no es ejecutable

Ejecutar:

$ export PATH=$PATH:/usr/local/sbin:/usr/sbin:/sbin

=============================
Instalar Sublime Text con apt
=============================

Install the GPG key:

$ wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -

Ensure apt is set up to work with https sources:

$ sudo apt-get install apt-transport-https

Select the channel to use:

Stable

echo "deb https://download.sublimetext.com/ apt/stable/" | sudo tee /etc/apt/sources.list.d/sublime-text.list

Dev

echo "deb https://download.sublimetext.com/ apt/dev/" | sudo tee /etc/apt/sources.list.d/sublime-text.list

Update apt sources and install Sublime Text

$ sudo apt-get update

$ sudo apt-get install sublime-text

=============================================================
Instalar Sublime Text con apt en Debian 12 Y 13 (Actualizado)
=============================================================

Add Sublime Text repository signing key to verify downloaded packages:

$ wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/sublimehq-archive.gpg > /dev/null

Create File with repository information in /etc/apt/sources.list.d directory.

For stable releases of Sublime Text:

$ echo "deb https://download.sublimetext.com/ apt/stable/" | sudo tee /etc/apt/sources.list.d/sublime-text.list

$ sudo apt install apt-transport-https

Update the list of available packages

$ sudo apt update

And install Sublime Text

$ sudo apt install sublime-text

Instalar Package Control
========================

1) Abrir consola de comando sde sublime con:

ctrl+shift+p

2) Escribir

Install Package Control

3) Presionar enter y listo

Instalando Themes y ColorSchemes
================================

Para instalar un theme tenemos que saber el nombre de este, para eso tienes que
navegar entre el listado de themes y buscar el que mas te guste.

Lista de themes: https://packagecontrol.io/browse/labels/theme

Una vez hayas identificado el que te ha gustado tienes que descargarlo para ello
nos vamos a Sublime Text y presionamos:

Ctrl + Shift + P

Esto nos abrirá una ventana en la que escribiremos:

install

Y seleccionaremos la opción que dice:

Package Control: Install Package

Presionamos Enter una vez mas y ahora tendremos un listado con todos los
plugins, themes y colorschemes de sublime text. Basta con buscar el que queremos
y seleccionarlo y darle enter.

Temas y paquetes recomendados
=============================

-SublimeCodeIntel: Plugin  mas completo para el auto completado de código y
también reconoce las funciones definidas en nuestro proyecto.

-babel-sublime: Para mejorar la coloración de sintaxis de babel y .jsx.
Syntax definitions for ES6 JavaScript with React JSX extensions.

-JavaScript Completions: JavaScript Completions for sublime text. It helps you
to write your scripts more quickly with hints and completions.

-Sublime-HTMLPrettify

-VUEFormatter

-vue-syntax-highlight

-ReactIDE

-Laravel Blade Highlighter

-A File Icon.

-Spacefunk.

-Theme Monokai Pro (Actual).

Buscarlos e instalarlos con las directrices anteriores:

-A File Icon: Se activa desde las Preferences

-Spacefunk: Para activar el theme tenemos que ir a:

Precerencias > Settigs - User

Esto nos abrirá un documento con algunas lineas de código, modificamos a:

Preferences.sublime-settings - User, y nos debe quedar así:

{
	"color_scheme": "Packages/Color Scheme - Default/Monokai.sublime-color-scheme",
	"font_size": 11,
	"ignored_packages":
	[
		"Vintage"
	],
	//"theme": "Default.sublime-theme"
	"theme": "Spacefunk (Blue Monday).sublime-theme"
}

Guardamos y reiniciamos SublimeText.

=====================================
Eliminar cualquier paquete de Sublime
=====================================

1- Vaya al menú Sublime-> Preferencia o presione Ctrl + Shift + P.

2- Elija -> la opción Eliminar paquete, después de elegir, mostrará todos los
paquetes instalados en su sublime, seleccione uno de ellos.

3. Después de la selección, se eliminará o, para mejor, puede reiniciar su
sistema.

====================================================================
Configuraciones de Sublime Text esenciales después de la instalación
====================================================================

1) Ir a menú Preferences > Settings.

2) Translate Tabs To Spaces

translate_tabs_to_spaces está por defecto en false, cambiarla a true. Esta
configuración creará espacios (\s) en vez de tabs (\t) al presionar la tecla
Tab.

3) Draw White Space

Esta configuración de draw_white_space por defecto está en selection. Al
cambiarla a all permite visualizar los espacios en blanco en cualquier parte del
código sin necesidad de que esté seleccionado.

Fuente
======

-https://blog.pleets.org/article/configuraciones-de-sublime-text-esenciales

=================
Programa progress
=================

Progress , anteriormente conocido como Coreutils Viewer, es un comando ligero C
que busca los comandos básicos de coreutils como cp , mv , tar, dd , gzip/gunzip
, cat, grep, etc. actualmente en ejecución en el sistema y muestra el porcentaje
de datos copiados, solo se ejecuta en sistemas operativos Linux y Mac OS X.

# apt install progress

Luego usamos el comando cp para copiar algun directorio

$ cp -r dir /tmp

Ahora podemos ver el % de avance de la copia si ejecutamos el siguiente comando
en otra consola

$ progress -q

[28281] cp /tmp
    10.0% (380.2 MiB / 3.7 GiB)

Para ver en vivo el progreso usamos -m

$ progress -m

[28281] cp /tmp
    10.0% (380.2 MiB / 3.7 GiB)

=======
Fuentes
=======

-https://es.linux-console.net/?p=896

=============================
Paquete locales y locales-all
=============================

Este paquete contiene los datos regionales precompilados de todas las regiones
que se pueden elegir. Un alternativa mejor es instalar el paquete locales y
seleccionar sólo las regiones deseadas, pero puede ser útil en una máquina con
poca memoria porque algunos archivos regionalización necesitan un montón de
memoria para compilarse.

# apt install locales y locales-all

$ dpkg-reconfigure locales

Escogemos las configuraciones regionales que desea generar:

es_VE.UTF-8 UTF-8

Configuración regional predeterminada para el entorno del sistema:
es_VE.UTF-8

=============================================
Cron y Crontab en Linux para programar tareas
=============================================

¿Has intentado programar una tarea en Linux y no has sabido como? ¿A pesar de
consultar el manual propio no has sido capaz? Primero hay que entender a  Cron y
Crontab. Estos dos elementos son muy importantes a la hora de programar tareas
periódicas y que se ejecuten sin que tengamos que estar pendientes de su estado.

En los sistemas operativos Windows existe algo similar denominado Tareas
Programadas. En esta ocasión el proceso no se realiza de forma gráfica y se
tiene que realizar a través de terminal.

Hemos mencionado con anterioridad Cron y Crontab. En primer lugar, vamos a ver
que diferencias existen entre ambos elementos. Posteriormente aprenderemos a
agregar tareas y para finalizar nos adentraremos en la gestión de los jobs
(trabajos) de Cron.

================================
Diferencias entre Cron y Crontab
================================

Aunque pueda parecer que estamos hablando de lo mismo, no es así, y se podrían
considerar dos elementos dependientes uno del otro. Para ser más claros, son los
encargados de que la programación de tareas en sistemas Linux sea posible.

===========
Qué es Cron
===========

Es un demonio (proceso en segundo plano) que se ejecuta desde el mismo instante
en el que arranca el sistema. Comprueba si existe alguna tarea (job) para ser
ejecutado de acuerdo a la hora configurada en el sistema. Muy importante que la
zona horaria esté bien configurada ya que de lo contrario las ejecuciones puede
que no coincidan con los ajustado.

En función de la distribución, se inicia utilizando las carpetas /etc/rc.d/ o
/etc/init.d y cada minuto comprueba los ficheros /etc/crontab o /var/spool/cron
es busca de posibles ejecuciones (ahora empieza todo a cuadrar).

==============
Qué es Crontab
==============

Un archivo de texto. Por simple que parezca la definición es así. Aunque es
verdad que se trata de un archivo con contenido especial. Posee una lista con
todos los scripts a ejecutar. Generalmente cada usuario del sistema posee su
propio fichero Crontab. Se considera que el ubicado en la carpeta etc pertenece
al usuario root.

Para generar el archivo propio, cada usuario deberá hacer uso del comando
crontab (sí, es el mismo nombre).

Cada usuario tiene sus crontabs, el root tiene los suyos y los demás usuarios
los suyos.

Para ver los contrabs configurados del usuario regular utilizamos este comando:

$ crontab -l

Para ver los contrabs configurados del usuario root utilizamos este comando:

# crontab -l

Para editarlos el crontab por defecto del usuario regular

$ crontab -e

Para editarlos el crontab por defecto del usuario root

# crontab -e

=====================
Formato de las tareas
=====================

Las tareas cron siguen una determinada sintaxis. Tienen 5 asteriscos seguidos
del comando a ejecutar. Ahora explicaré para qué sirve cada cosa.

* * * * * /bin/ejecutar/script.sh

Los 5 asteriscos, de izquierda a derecha, representan:

Minutos: de 0 a 59.
Horas: de 0 a 23.
Día del mes: de 1 a 31.
Mes: de 1 a 12.
Día de la semana: de 0 a 6, siendo 0 el domingo.

Si se deja un asterisco, quiere decir "cada" minuto, hora, día de mes, mes o
día de la semana. Por ejemplo:

* * * * * /bin/ejecutar/script.sh

Ejecuta este script:

Cada minuto
De cada hora
De cada día del mes
De cada mes
De cada día de la semana

Otro ejemplo:

30 2 * * 1 /bin/ejecutar/script.sh

Ejecutar este script:

En el minuto 30
De las 2 de la noche
De cada día del mes
De cada mes
Sólo si es Lunes

En resumen, todos los lunes a las 2:30 horas se ejecutará el script.

====================
Intervalos de tiempo
====================

Ejecutar un script de lunes a viernes a las 2:30 horas:

30 2 * * 1-5 /bin/ejecutar/script.sh

Ejecutar un script de lunes a viernes cada 10 minutos desde las 2:00 horas
durante una hora:

0,10,20,30,40,50 2 * * 1-5 /bin/ejecutar/script.sh

Esto quizá puede ser largo. La sintaxis de crontab permite lo siguiente.
Imaginemos que queremos ejecutarlo cada 5 minutos:

*/5 2 * * 1-5 /bin/ejecutar/script.sh

===============================================================
Ejemplo real de ejecución de script en Linux Debian con crontab
===============================================================

1. Haz el script ejecutable

Primero, asegúrate de que tu script tenga permisos de ejecución. Abre una
terminal, navega hasta el directorio donde guardaste el script y ejecuta el
siguiente comando:

$ chmod +x tu_script_de_respaldo.sh

Reemplaza tu_script_de_respaldo.sh con el nombre real de tu script.

2. Edita la tabla cron

Para agregar una tarea a cron, necesitas editar tu "crontab" personal. Hazlo con
este comando:

$ crontab -e

Si es la primera vez que usas crontab -e, es posible que te pida elegir un
editor de texto. Te recomiendo nano si no estás familiarizado con vi o vim.

3. Agrega la entrada cron

Una vez que se abra el editor, agrega una nueva línea al final del archivo. La
sintaxis de cron sigue un formato específico:

minuto hora día_del_mes mes día_de_la_semana comando_a_ejecutar

Aquí tienes algunos ejemplos para tu script:

Para ejecutar el script todos los días a las 3:00 AM:

0 3 * * * /ruta/completa/a/tu_script_de_respaldo.sh

Asegúrate de reemplazar /ruta/completa/a/tu_script_de_respaldo.sh con la ruta
absoluta donde guardaste tu script (por ejemplo,
/home/tu_usuario/scripts/respaldo_db.sh).

Para ejecutar el script de lunes a viernes a las 11:00 PM:

0 23 * * 1-5 /ruta/completa/a/tu_script_de_respaldo.sh

Para ejecutar el script el primer día de cada mes a la medianoche (00:00):

0 0 1 * * /ruta/completa/a/tu_script_de_respaldo.sh

Consejo: Si quieres que la salida del script (los mensajes de éxito o error) se
registren, puedes redirigirla a un archivo de log. Por ejemplo:

0 3 * * * /ruta/completa/a/tu_script_de_respaldo.sh >> /var/log/respaldo_db.log 2>&1

Esto enviará tanto la salida estándar como los errores al archivo
/var/log/respaldo_db.log.

4. Guarda y sal del editor

Si usas nano: Presiona Ctrl + O para guardar, luego Enter, y finalmente
Ctrl + X para salir.

5. Verificación (Opcional)

Puedes verificar si tu tarea cron se ha agregado correctamente ejecutando de
nuevo:

$ crontab -l

Esto listará todas las tareas cron programadas para tu usuario.

¡Y listo! Cron se encargará de ejecutar tu script de respaldo de PostgreSQL a
la hora programada. Recuerda que la ruta del script debe ser la ruta absoluta.

# Ver logs del cron

$ sudo grep CRON /var/log/syslog

Fuente
======

Gemini IA

===================
Palabras reservadas
===================

Muchas veces tenemos palabras reservadas para facilitar el uso de programas o
lenguajes de programación. Cron no podía ser menos, así que tenemos algunas que
suelen ser las más comunes. Ya cada uno que lo configure conforme a sus
necesidades. Aquí van:

@reboot: se ejecuta una única vez al inicio.
@yearly/@annually: ejecutar cada año.
@monthly: ejecutar una vez al mes.
@weekly: una vez a la semana.
@daily/@midnight: una vez al día.
@hourly: cada hora.

Por ejemplo, para ejecutar el script cada hora:

@hourly /bin/ejecutar/script.sh

==============================
Ejemplo de script para pruebas
==============================

#!/bin/bash
# Abrir un fichero específico con el editor gedit
gedit /home/user/try.txt

=======
Fuentes
=======

-https://www.redeszone.net/2017/01/09/utilizar-cron-crontab-linux-programar-tareas/
-https://geekytheory.com/programar-tareas-en-linux-usando-crontab

===========================================
Transparencia de la barra superior en gnome
===========================================

Clonamos el proyecto con este comando:

$ git clone https://github.com/rockon999/dynamic-panel-transparency.git

Lo anterior nos descargará la extensión en nuestra carpeta personal.

Ahora vamos a nuestra carpeta personal y accedemos a la carpeta
"dynamic-panel-transparency", copiamos la carpeta
"dynamic-panel-transparency@rockon999.github.io" en
/home/user/.local/share/gnome-shell/extensions, si la carpeta "extensions" no
está, la creamos.

El siguiente paso es reiniciar el shell, lo que podemos hacer con Alt+F2
introduciendo la tecla "r" sin las comillas y presionando Intro o reiniciamos el
sistema operativo.

A continuación abrimos Retoques de GNOME. Si no lo tenemos instalado, instalamos
el paquete gnome-tweak.

Luego vamos a "Extensiones" y activamos "Dynamic panel transparency" Y eso sería
todo, solo quedaría configurarlo.

=======
Fuentes
=======

-https://ubunlog.com/asi-puedes-recuperar-la-transparencia-dinamica-de-la-barra-superior-en-ubuntu-19-04/

==========================================
Crear o añadir memoria swap en un servidor
==========================================

1) Comprobar el sistema de información Swap

$ sudo swapon -s

ó

$ cat /proc/swaps

Si tras ejecutar lo anterior solo aparece en pantalla las cabeceras de una
tabla, significará que actualmente no tenemos espacio swap habilitado.

Filename				Type		Size	Used	Priority

Otra forma de ver si tenemos disponible memoria swap en nuestro sistema es
mediante el comando «free». Este comando se encarga de mostrar el uso de los
diferentes tipos de memoria del sistema.

$ free -m

El resultado que aparecería por pantalla sería algo parecido a lo que os
mostramos a continuación:

             total       used       free     shared    buffers     cached
Mem:          3953        154       3799          0          8         83
-/+ buffers/cache:         62       3890
Swap:            0          0          0

Si en el apartado «Swap» aparece el valor 0, esto quiere decir que no tenemos
espacio disponible para este fin.

2) Revisar el espacio disponible en la partición del disco duro

Para asignar espacio para el intercambio se suele utilizar una partición
independiente. Sin embargo, no siempre es posible cambiar el esquema de
particionado utilizado en un servidor. Lo que se puede hacer en estos casos es
crear un archivo de intercambio de forma sencilla, que resida en una de las
particiones ya existentes. Antes de hacer esto, es muy importante que sepamos el
estado de uso de las distintas particiones para ver donde sería más factible
crearlo. Podemos conseguir esta información mediante la instrucción:

$ df -h

Por pantalla tenemos que ver algo parecido a lo siguiente:

Filesystem      Size  Used Avail Use% Mounted on
/dev/vda         59G  1.3G   55G   3% /
none            4.0K     0  4.0K   0% /sys/fs/cgroup
udev            2.0G   12K  2.0G   1% /dev
tmpfs           396M  312K  396M   1% /run
none            5.0M     0  5.0M   0% /run/lock
none            2.0G     0  2.0G   0% /run/shm
none            100M     0  100M   0% /run/user

Como podemos ver en el resultado anterior, nuestro disco duro tiene un tamaño de
55 GB disponibles, lo que se traduce en un gran espacio para trabajar. Ya que
sabemos el espacio disponible, ya podemos determinar el tamaño que destinaremos
a la memoria swap. En este punto existen opiniones diversas, pero nosotros os
recomendamos asignar un espacio que sea al menos igual o el doble de la RAM; por
supuesto, esto también dependerá del espacio disponible que tengamos. En nuestro
caso, dedicaremos 4 GB a este fin.

3) Crear un archivo swap

Una vez que sabemos el espacio que tenemos disponible, vamos a proceder a crear
un fichero swap en nuestro sistema de archivos. Para ello vamos a crear uno de
nombre «swapfile» en nuestro directorio root. A este archivo tenemos que
asignarle el espacio que queremos que tenga. Para ello lo podemos hacer de dos
formas diferentes.

==================
Método tradicional
==================

Primero de todo, cabe decir que el método tradicional es la opción más lenta.
El sistema que se utiliza en este caso es el comando «dd», una herramienta que
es capaz de escribir de una ubicación a otra. Para conseguir un tamaño de 4 GB,
tenemos que ejecutar la siguiente instrucción:

$ sudo dd if=/dev/zero of=/swapfile bs=1G count=4

Con esto, lo que hacemos es asignar un bloque de tamaño de 1 GB y un contador
con el valor 4, que serán las veces que se debería ejecutar. De esta forma
conseguiríamos los 4 GB de espacio mediante el uso de ceros como contenido. Os
recomendamos que tengáis mucho cuidado a la hora de utilizarlo, ya que si
ponemos mal algún tipo de información, podríamos corromper el sistema. Tampoco
os preocupéis si veis que tarda mucho tiempo en generarse, se trata de un
fichero muy grande, así que es normal que tarde.

=============
Método rápido
=============

La forma más rápida de conseguir esto es utilizando el programa «fallocate».
Este comando crea un fichero del tamaño indicado de forma inmediata. Para crear
un archivo hay que ejecutar lo siguiente:

$ sudo fallocate -l 4G /swapfile

El archivo se crea inmediatamente y lo podemos comprobar ejecutando la siguiente
instrucción:

$ ls -lh /swapfile

Como salida deberíamos ver algo parecido a lo siguiente:

-rw-r--r-- 1 root root 4.0G Jul 03 17:15 /swapfile

4) Habilitar el archivo swap

Aunque ya hemos creado nuestro archivo, el sistema no sabe que queremos
utilizarlo como partición de intercambio. Así que ahora toca darle formato y
activarlo. Para ello debemos ajustar los permisos en nuestro archivo, para que
solo el usuario root pueda leerlo, porque dejar que cualquiera pudiera acceder a
él supondría un problema de seguridad importante.

Para cambiar los permisos debemos ejecutar:

$ sudo chmod 600 /swapfile

Lo siguiente que haremos será indicar al sistema que ese fichero se usará como
memoria swap. Para ello ejecutaremos lo siguiente:

$ sudo mkswap /swapfile

Por pantalla tenemos que ver algo parecido a esto:

Setting up swapspace version 1, size = 4194300 KiB
no label, UUID=e2f1e9cf-c0a9-4ed4-b8ab-714b8a7d6944

Nuestro archivo está listo para ser utilizado como espacio swap, así que vamos a
activarlo.

$ sudo swapon /swapfile

Ahora podemos verificar si nuestro sistema nos informa de que tenemos un espacio
creado de tipo swap.

$ sudo swapon -s

Por pantalla deberíamos ver algo así:

Filename                Type        Size    Used    Priority
/swapfile               file        4194300 0       -1

Si utilizamos la herramienta «free», nos debería aparecer que la memoria swap
tiene espacio disponible, en lugar del valor 0 que aparecía antes.

$ free -m

La salida sería la siguiente:

             total       used       free     shared    buffers     cached
Mem:          3953        101       3851          0          5         30
-/+ buffers/cache:         66       3887
Swap:         4095          0       4095

5) Hacer permanente el archivo de intercambio

Aunque hayamos creado nuestro archivo de intercambio, cada vez que reiniciemos
la máquina el sistema no lo habilitará de forma automática. Para que esto ocurra
tenemos que modificar el archivo «fstab». Para ello lo editaremos con
privilegios root con nuestro editor de preferencia.

$ sudo nano /etc/fstab

En la parte inferior del archivo tenemos que añadir una línea que será la
encargada de indicar al sistema que utilice el archivo creado de forma
automática.

/swapfile   none    swap    sw    0   0

Cuando hayas añadido esa línea, puedes guardar y salir.

6) Afinar la configuración de nuestra memoria swap

Para finalizar, es bueno que realicemos algunas acciones para mejorar el
rendimiento del sistema de intercambio. El parámetro «swappiness» configura la
frecuencia con la que su sistema intercambia datos de memoria RAM con el espacio
de intercambio. El «swappinness» es un valor que va de 0 a 100. Cuando el valor
esté cerca de 0, no se intercambiará datos en el disco a menos que sea
absolutamente necesario. Si por el contrario, el valor está más cerca de 100, se
llevarán a cabo un mayor número de intercambios para dejar más espacio libre en
la RAM.

Si queremos ver el valor actual de «swappiness», lo podemos hacer ejecutando la
siguiente instrucción:

cat /proc/sys/vm/swappiness

Para asignar un valor de 10 a este parámetro, podemos ejecutar:

sudo sysctl vm.swappiness=10

El valor se mantendrá así hasta el próximo reinicio de la máquina. Si queremos
que sea permanente, podemos añadir la siguiente línea al final de nuestro
/etc/sysctl.conf.

vm.swappiness=10

Cuando termines, guarda y cierra el archivo. Como véis, crear un archivo para
utilizarlo como memoria swap en Ubuntu no es nada complicado. El beneficio para
el rendimiento de nuestro sistema puede ser considerable. Recuerda realizar
siempre copias de seguridad antes y, si dudas, pregunta o delega en
profesionales de administración de sistemas.

=======
Fuentes
=======

-https://www.stackscale.com/es/blog/anadir-memoria-swap-servidor-ubuntu/

=================================================================
Cambiar el fondo de la pantalla o wallpaperde login en gnome gdm3
=================================================================

Cada vez que inicies sesión o bloquees y desbloquee tu escritorio, serás
recibido con una pantalla de color gris. Es el fondo de GDM
(GNOME Display Manager) por defecto.

Para cambiar el fondo debemos editar el archivo

/usr/share/gnome-shell/theme/gnome-classic.css

Antes de modificar este archivo, haz una copia de seguridad del mismo. Así que,
podemos restaurarla si algo sale mal.

Ahora, edita el archivo gnome-classic.css:

# nano /usr/share/gnome-shell/theme/gnome-classic.css

Encuentra las siguientes líneas bajo la directiva llamada "lockDialogGroup" en
el archivo:

#lockDialogGroup {
  background: #2e3436 url(resource:///org/gnome/shell/theme/noise-texture.png);
  background-repeat: repeat;
}

y lo cambiamos a

/* Nuevo fondo para pantalla del login */
#lockDialogGroup {
  background: #2e3436 url(file:///home/user/Imágenes/mi_nuevo_fondo.jpg);
  background-repeat: no-repeat;
  background-size: cover;
  background-position: center;
}

Nota que hay que poner la ruta completa a la nueva imágen.

Guardamos, refrescamos el escritorio con Alt + F2 y escriba r y presione enter
esto para gnome3.

y listo, ya deberíamos ver nuestra nueva imagen como fondo de login.

=======
Fuentes
=======

-https://www.linuxenespañol.com/tutoriales/como-cambiar-fond-pantalla-inicio-sesion-gdm-ubuntu/

====================================
Editar el tema por defecto en Debian
====================================

En este ejemplo, mi Debian tiene el gnome-classic por defecto, y el tema
Adwaita-dark configurado por defecto y la hoja de estilos del tema está en:

/usr/share/themes/Adwaita-dark/gtk-3.0/gtk.css

Sin embargo dentro de ese archivo encontramos una referencia a otro archivo:

@import url("resource:///org/gtk/libgtk/theme/Adwaita/gtk-contained-dark.css");

Nosotros vamos a escribir otra hoja de estilos para sobre escribir los estilos
del tema por defecto.

Nos vamos a /home/my-user/.config/gtk-3.0 y vamos a crear gtk.css

Dentro vamos a agregar el siguiente código que cambiara los colores de la
cabecera del explorador de archivos nautilus. Copiamos, pegamos, guardamos.

/* REMOVE "-dark" IF USING LIGHT THEME */
@import url("resource:///org/gtk/libgtk/theme/Adwaita/gtk-contained-dark.css");

/* Fonde de la mayoría de aplicaciones de gnome 
.background { color: #eeeeec; background-color: #000000; } */

/* THIS ONE CHANGES TITLEBAR COLOR */
headerbar.titlebar,
headerbar.titlebar:active {
    background:#000000;
}

/* THIS CHANGES NAUTILUS SEARCH BAR */
.horizontal.path-bar-box,
row:selected:backdrop {
    background:#3F51B5;
    border-color:#3F51B5;
}

Ahora recargamos el escritorio con Alt + f2 + r + enter y si abrimos nautilus
podremos ver los cambios en los colores.

Fuentes
=======

-https://unix.stackexchange.com/questions/175385/where-may-i-find-a-reference-scheme-for-gnome-3-theming-e-g-adwaita

=============
Programa curl
=============

Instalar curl

# apt install curl

Verifica la versión de Curl

$ curl --version

Sintaxis básica del comando Curl

$ curl [OPTIONS] [URL]

El uso más simple de Curl es mostrar el contenido de una página. El siguiente
ejemplo mostrará la página de inicio de testdomain.com.

$ curl testdomain.com

La salida sería:

<html><head><title>testdomain.com</title></head><body><h1>testdomain.com</h1><p>
Coming soon.</p></body></html>

Opciones de archivo de comandos de Curl
=======================================

Los comandos Curl pueden descargar archivos desde una ubicación remota. Puedes
hacerlo de dos maneras diferentes:

-O guardará el archivo en el directorio de trabajo actual con el mismo nombre de archivo que el remoto.

-o permite especificar un nombre de archivo o ubicación diferente.

A continuación se muestra un ejemplo:

Guardar testfile.tar.gz.

$ curl -O http://testdomain.com/testfile.tar.gz

Guardar el archivo como newtestfile.tar.gz.

$ curl -o newtestfile.tar.gz http://testdomain.com/testfile.tar.gz

Reanudar descarga

$ curl -C - http://testdomain.com/testfile.tar.gz

Descargar varios archivos a la vez

$ curl -O http://testdomain.com/testfile.tar.gz -O http://mydomain.com/myfile.tar.gz

Si quieres descargar múltiples archivos de múltiples URLs, inclúyelos todos en
un archivo. Los comandos Curl se pueden combinar con xargs para descargar las
diferentes URLs.

Por ejemplo, si tenemos un archivo allUrls.txt que contiene una lista de todas
las URLs que se descargarán, el siguiente ejemplo se puede usar para descargar
todos los archivos.

$ xargs -n 1 curl -O < allUrls.txt

Comandos Curl para Http
=======================

Curl también se puede usar cuando hay un servidor proxy. Si estás detrás de un
servidor proxy que escucha en el puerto 8090 en sampleproxy.com, descarga los
archivos como se muestra a continuación:

$ curl -x sampleproxy.com:8090 -U username:password -O http:// testdomain.com/testfile.tar.gz

En el ejemplo anterior, puedes omitir -U username:password si el proxy no
requiere un método de autenticación.

Una solicitud HTTP típica siempre contendrá un encabezado. El encabezado HTTP
envía información adicional sobre el servidor web remoto junto con la solicitud
real. Si bien a través de las herramientas de desarrollador de un navegador
puedes verificar la información del encabezado, puedes verificarla utilizando un
comando curl.

Recuperar o consultar la información del encabezado de un sitio web.

$ curl -I www.testdomain.com

Hacer una solicitud GET

$ curl http://mydomain.com

Hacer una solicitud POST. El sitio web o url al cual se hace la solicitud
debería estar preparado para dar respuestas, de lo contrario dara error el
comando.

Aquí text=Hello es el parámetro de solicitud POST. Este comportamiento sería
similar a los formularios HTML.

$ curl -data "text=Hello" https://myDomain.com/firstPage.php

Otro ejemplo curl post real

$ curl -X POST https://petroapp-price.petro.gob.ve/price/PTR -H 'Content-Type: application/json' -d' {"coins":["BTC","DASH","LTC","ETH"]}'

Respuesta

{"status":200,"success":true,"data":{"BTC":{"BTC":185.10780816,"PTR":0.00540226}}}

-----

Descargar un archivo con curl

$ curl https://misitio/downloads/1 --output archivo.zip

curl: Es una herramienta de línea de comandos que permite hacer solicitudes HTTP
(entre otros protocolos). Se usa para transferir datos desde o hacia un
servidor.

https://misitio/downloads/1: Es la URL desde la cual curl está solicitando el
recurso. En este caso, parece que apunta a un archivo en un sitio web que
quieres descargar.

--output archivo.zip: Este parámetro le dice a curl que guarde el contenido
descargado en un archivo llamado archivo.zip. Si no incluyeras este parámetro,
el contenido de la descarga se mostraría directamente en la terminal.

=======
Fuentes
=======

-https://www.hostinger.es/tutoriales/comando-curl/

===========
gnome-paint
===========

Programa parecido al paint de windows, muy facil de usar

# apt install gnome-paint

================
¿Qué és el SMTP?
================

El SMTP (Simple Mail Transfer Protocol o Protocolo para Transferencia Simple de
Correo) es un protocolo de comunicación que permite el envío de correos
electrónicos en internet.

Este protocolo se asocia normalmente con otros como POP3 o IMAP, siendo SMTP
utilizado para el correo de salida y POP3 o IMAP utilizado para el correo
entrante.

El protocolo para transferencia simple de correo (en inglés Simple Mail Transfer
Protocol o SMTP) es un protocolo de red utilizado para el intercambio de
mensajes de correo electrónico entre computadoras u otros dispositivos (PDA,
teléfonos móviles, impresoras, etc). Definido inicialmente en agosto de 1982 por
el RFC 821 (para la transferencia) y el RFC 822 (para el mensaje). Son
estándares oficiales de Internet que fueron reemplazados respectivamente por el
RFC 2821 y el RFC 2822, que a su vez lo fueron por el RFC 5321 y el RFC 5322.1​

El funcionamiento de este protocolo se da en línea, de manera que opera en los
servicios de correo electrónico. Sin embargo, este protocolo posee algunas
limitaciones en cuanto a la recepción de mensajes en el servidor de destino
(cola de mensajes recibidos). Como alternativa a esta limitación se asocia
normalmente a este protocolo con otros, como el POP o IMAP, otorgando a SMTP la
tarea específica de enviar correo, y recibirlos empleando los otros protocolos
antes mencionados (POP O IMAP).

=======
Fuentes
=======

-https://es.wikipedia.org/wiki/Protocolo_para_transferencia_simple_de_correo

============================
Poner el audacity en español
============================

1) Editar el archivo /home/user/.audacity-data/audacity.cfg Buscamos la variable
"language" que debe estar vacía y pones "es"

language=es

Guardamos y abrimos audacity de nuevo.

2) Si en el audacity.cfg no está la variable "language" simplemete pega estas
líneas al final del archivo.

[locale]
language=es

Guardas y listo, abres audacity para comprobar

=======
Fuentes
=======

-https://salmorejogeek.com/2018/04/16/en-linux-como-poner-audacity-en-espanol-cuando-ni-siquiera-viene-en-preferencias/

====================
Instalar Tor browser
====================

1) Descargar el paquete desde https://www.torproject.org/es/

2) Descomprimir el paquete tor-browser-linux64-10.0.2_es-ES.tar.xz

3) Entrar en la carpeta tor-browser_es-ES

4) Ejecutar el siguiente comando:

$ ./start-tor-browser.desktop

5) Esto nos abre el navegador en una nueva ventana y ya está listo para usarse.

==================================================================
Mejorar el rendimiento de un sistema operativo de escritorio Linux
==================================================================

Para aprovechar mejor la memoria de nuestro equipo les recomiendo realicen lo
siguiente.

1) Abre un terminal y ejecuten el siguiente comando:

$ sudo nano /etc/sysctl.conf

2) Cuando se abra el editor de texto nano vayanse al final del archivo y peguen
el siguiente código:

vm.swappiness = 10
vm.vfs_cache_pressure = 50
vm.watermark_scale_factor = 200
vm.dirty_ratio = 3

3) Una vez pegado el código ya pueden guardar los cambios, cerrar el fichero,
para aplicar los cambios sin reiniciar usamos el siguiente comando:

$ sudo sysctl -p

4) Para chequear los nuevos valores ejecutar los siguientes comando:

$ cat /proc/sys/vm/swappiness

$ cat /proc/sys/vm/vfs_cache_pressure

$ cat /proc/sys/vm/watermark_scale_factor

$ cat /proc/sys/vm/dirty_ratio

Fuentes
=======

-https://geekland.eu/mejorar-el-rendimiento-de-un-sistema-operativo-de-escritorio-linux/

/home/user/.config/gtk-3.0

======================
Instalar Opera browser
======================

$ sudo nano /etc/apt/sources.list

Añadimos al final las líneas siguientes:

# Repositorio para Opera browser
deb http://deb.opera.com/opera-stable/ stable non-free

Una vez editado y guardado el archivo, descargamos e instalamos la key para
confiar en el repositorio añadido:

$ wget -O - https://deb.opera.com/archive.key | sudo apt-key add -

Antes de instalar, actualizamos los repositorios:

$ sudo apt update

y finalmente instalamos:

$ sudo apt-get install opera-stable

===================================
Instalar Opera browser en Debian 13
===================================

$ wget -qO- https://deb.opera.com/archive.key | gpg --dearmor | sudo tee /usr/share/keyrings/opera-archive-keyring.gpg >/dev/null

$ echo "deb [arch=amd64 signed-by=/usr/share/keyrings/opera-archive-keyring.gpg] https://deb.opera.com/opera-stable/ stable non-free" | sudo tee /etc/apt/sources.list.d/opera.list

Antes de instalar, actualizamos los repositorios:

$ sudo apt update

y finalmente instalamos:

$ sudo apt-get install opera-stable

Actualizar Opera
================

1- Se debe tener habilitado esto en los repos:

# Repositorio para Opera browser
deb http://deb.opera.com/opera-stable/ stable non-free

2- Luego actualizar la lista de paquetes:

$ sudo apt update

$ sudo apt install --only-upgrade opera-stable

===================
Free-vpn para Opera
===================

https://www.opera.com/es-419/features/free-vpn

===============
¿Qué es un DNS?
===============

Los servidores DNS (Sistema de Nombres de Dominio) se encargan de traducir las
direcciones web en direcciones IP. Por ejemplo, cuando navegas por google.com,
tú ves esa dirección, pero el navegador necesita otra forma para saber a qué
servidor necesita conectarse para acceder a esos contenidos.

Un DNS es básicamente, un traductor. Es más fácil para el usuario escribir una
dirección web que recordar la dirección IP de cada una de estas webs.

Fuentes
=======

-https://www.xatakandroid.com/tutoriales/dns-android-que-como-cambiarlo-tu-movil

==========================
Modificar o agregar un DNS
==========================

Se debe editar este archivo:

$ sudo nano /etc/resolv.conf

Los de google son:

8.8.8.8
8.8.4.4

Pero para saltar restricciones para algunas páginas bloqueadas se puede usar

1.1.1.1

Esta configuración al parecer se resetea cada vez que se reinician las
conexiones de red, por lo que se debe hacer un ajuste a nivel de configuración
de la red del sistema.

Configuración manual y definitiva
=================================

https://1.1.1.1/es/

==========================================
Firmar electrónicamente con PortableSigner
==========================================

Es un programa de firma (con certificados X.509) para archivos PDF. Es
independiente de la plataforma ya que se puede ejecutar GNU/Linux, Windows y
Mac OS X.

Se puede descargar desde: http://portablesigner.sourceforge.net/

Una vez descargado y descomprimido se obtienen los siguientes archivos:

PortableSigner.jar
linux-install.sh
linux
lib

Para ejecutarlo y levantar la interfaz del sistema se debe instalar el paquete
de java disponible:

$ sudo aptitude install default-jre

Luego si ejecutamos el archivo principal:

$ java -jar PortableSigner.jar

Una vez abierto le se deben cargar los siguientes documentos:

-Primero el archivo pdf a firmar.
-Segundo (El sistema coloca el nombre del archivo firmado)
-Tercero el archivo .p12
-Cuarto la frase de paso o contraseña del archivo .p12

Para firmar se ejecuta.

$ java -jar ruta-ejecutable -n -t ruta-documento-firmar -o ruta-almacenar-documento-firmardo -s ruta-del-certificado -p frase-de-paso

$ java -jar PortableSigner.jar -n -t descarga.pdf -o descargar-sign.pdf -s miarchivo.p12 -p "micontraseñ@"

Ejemplo de la salida del comando:

$ java -jar PortableSigner.jar
Gtk-Message: 16:18:21.542: Failed to load module "canberra-gtk-module"
Position V:0.0 L:0.0 R:0.0
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.itextpdf.text.pdf.MappedRandomAccess
File$1 (file:/home/user/PortableSigner/lib/itextpdf-5.1.3.jar) to method
java.nio.DirectByteBuffer.cleaner()
WARNING: Please consider reporting this to the maintainers of com.itextpdf.text
.pdf.MappedRandomAccessFile$1
WARNING: Use --illegal-access=warn to enable warnings of further illegal
reflective access operations
WARNING: All illegal access operations will be denied in a future release

======
pdfsig
======

Portable Document Format (PDF) digital signatures tool.

Es una herramienta de firmas digitales en formato de documento portátil (PDF).

pdfsig verifica las firmas digitales en un documento PDF. También muestra la
identidad de cada firmante (campo commonName y nombre distinguido completo del
certificado del firmante), la hora y la fecha de la firma, el algoritmo hash
utilizado para firmar, el tipo de firma como se indica en el PDF y los rangos
firmados. con una declaración si el documento total está firmado. También puede
firmar documentos PDF.

Instalación:

$ sudo apt install poppler-utils

Para verificar la firma de un archivo se ejecuta el siguiente comando:

$ pdfsig mi-archivo-firmado-sign.pdf

Ejemplo de la salida del comando:

$ pdfsig doc-sign.pdf
Digital Signature Info of: mi-archivo-firmado-sign.pdf
Signature #1:
  - Signer Certificate Common Name: CARLOS PEREZ
  - Signer full Distinguished Name: E=cperez@mail.com,CN=CARLOS PEREZ,
  OU=SEGURIDAD,O=CENDITEL,L=Caracas,ST=Caracas,C=VE
  - Signing Time: Jan 23 2024 16:20:21
  - Signing Hash Algorithm: SHA1
  - Signature Type: adbe.pkcs7.sha1
  - Signed Ranges: [0 - 223305], [225887 - 231064]
  - Total document signed
  - Signature Validation: Signature is Valid.
  - Certificate Validation: Certificate issuer isn't Trusted.

======================================================================
Pŕactica del Curso en línea del uso de Murachí para firmar y verificar
documentos PDF
======================================================================

Este tutorial no lo he probado aún pero debería funcionar.

PORTABLESIGNER es una aplicación de firmar (con certificado X.509) para archivos
PDF desarrollado en lenguaje JAVA. En esta sección realizaremos la firma
electrónica de documento PDF usando la aplicación PORTABLESIGNER y un
certificado digital en formato PKCS#12. Para desarrollar esta tarea se requiere
disponer del certificado electrónico en formato PKCS#12.

Para realizar esta actividad es necesario que realizamos los siguientes pasos:

Instalar el servidor APACHE2

Descargar el zip de la aplicación PORTABLESIGNER

Instalar OPENJDK (JAVA .6 or 1.7)

Instalar PHP7

Crear un formulario HTML que permita obtener del sistema de archivo de tu
computador un archivo PDF, un archivo correspondiente al certificado digital en
formato PKCS#12.

Crear los scripts necesarios que permitan realizar el proceso de firma
electrónica de usando la aplicación PORTABLESIGNER Y para ello, es
importante seguir las siguientes instrucciones:

1. Crear el ambiente de prueba para realizar el ejercicio

Se procede a instalar los paquetes APACHE2, JAVA y PHP

$ sudo aptitude install openjdk-8-jre apache2 php7.3
Descargar en el servidor Apache la aplicación PORTABLESIGNER y moverlo al servidor WEB APACHE

$ wget https://sourceforge.net/projects/portablesigner/files/portablesigner/2.0-Release/PortableSigner-Generic-2.0.38c0573.zip

Se crea el directorio del ambiente de trabajo

$ sudo mkdir /var/www/html/murachi/

$ sudo mv PortableSigner-Generic-2.0.38c0573.zip /var/www/html/murachi/.

Del comando anterior se descarga la aplicación en el archivo PortableSigner-Generic-2.0.38c0573.zip. Para descomprimir el archivo zip debe tener instalado en su computadora el paquete Unzip. De no tener el paquete Unzip instalado se procede a instalar con el comando

$ sudo aptitude install unzip

Luego se procede a descomprimir el archivo PortableSigner-Generic-2.0.38c0573.zip en el servidor web Apache con el comando

$ cd /var/www/html/murachi/

$ sudo unzip PortableSigner-Generic-2.0.38c0573.zip

Al descomprimir debe poseer los directorios lib/, linux/ y el archivo ejecutable PortableSigner.jar

2. Crear la pagina básica y el script necesarios para realizar la firmar electrónica usando la aplicación PORTABLESIGNER

La aplicación PORTABLESIGNER se ejecuta por consola y para la misma se requiere tener:

El archivo PDF a firmar
El certificado electrónico en formato PKCS#12 con su contraseña o frase de paso (generado en la sección Contenido 1).
El objetivo de este ejercicio es invocar un script en PHP desde un formulario HTML que ejecute por comando la aplicación PORTABLESIGNER.

En primer lugar, realizaremos el formulario que permita enviar el archivo PDF a firmar y cargar el certificado electrónico en formato PKCS#12 junto a la contraseña o frase de paso del certificado. Para este ejercicio se creará el formulario en un archivo con el nombre de index.php

Características del formulario HTML

Control: Botón de envío (Submit button)

Atributos: Función en php que gestione los parámetros del formulario (Action)

Código del formulario index.php

<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>Firma electrónica</title>
</head>
<body>

<h1> Firmando un archivo PDF con PortableSigner </h1>
<form action="run_script.php" method="POST" enctype="multipart/form-data">
  <fieldset>
    <legend>PDF</legend>
    <label for="pdf">Seleccione su PDF</label>
    <input id="pdf" type="file" name="pdf" accept=".pdf" required tabindex="1">
  </fieldset>
  <fieldset>
    <legend>Certificado</legend>
    <label for="pkcs12">Seleccione su certificado PKCS12 (.p12)</label>
    <input id="pkcs12" type="file" name="pkcs12" accept=".p12" required tabindex="2">
  </fieldset>
  <fieldset>
    <legend>Clave</legend>
    <label for="password">Clave del certificado</label>
    <input id="password" type="password" name="password" required tabindex="3" />
  </fieldset>
  <p>
    <input name="submit" type="submit" value="Upload Files">
  </p>
</form>
</body>
</html>

En la action del formulario invoca a la función run_script.php. Este script en
PHP debe gestionar los archivos enviados en el formulario y gestionar el proceso
de firmar electrónica ejecutando por consola la aplicación PortableSigner.jar

Pasos a realizar en el script run_script.php:

-Manejo del nombre y ruta del archivo a firmar Ruta del certificado PKCS#12
-Ruta del archivo firmado
-Ejecutar por consola el proceso de firma usando la aplicación PORTABLESIGNER
-Eliminar tanto el archivo a firmar como el certificado PKCS#12 enviado por el
formulario

Código del script run_script

<?php

/**
* ValidateFiles
* valida de archivos subidos
* @param temp (ruta del archivo temporal)
* @param route (ruta relativa del archivo subido)
* @return bool
*
* @author Angelo Osorio (@engelpain)
* @licence CENDITEL 2.0
*/

function ValidateFiles($temp, $route) {
    move_uploaded_file($temp, $route) or die("Error al intentar subir el archivo." . $route);
}

// Datetime
$datetime = date_timestamp_get(date_create()); // nombre que tendrán los archivos temporales cargados

// Frase de paso del p12
$passphase = $_POST["password"]; // Contraseña o frase de paso cifrada

// PDF
$route_pdf = './tmp/' . $datetime . '.pdf'; // ruta donde se alojará el archivo firmado
$pdf = $_FILES['pdf']['tmp_name']; // ruta temporal del archivo a firmar subido

// PKCS12
$route_pkcs12 = './tmp/' . $datetime . '.p12'; // Ruta donde se alojará el archivo PKCS#12
$pkcs12 = $_FILES['pkcs12']['tmp_name']; // ruta temporal del archivo PKCS#12 subido
print_r(ValidateFiles($pdf, $route_pdf));
print_r(ValidateFiles($pkcs12, $route_pkcs12));

// Ejecución del script que conecta con el API de PortableSigner
$callPortable = "java -jar ./PortableSigner.jar -n";
$run_shell = shell_exec("$callPortable -t $route_pdf -o ./tmp/$datetime-signed.pdf -s $route_pkcs12 -p $passphase");
$run = ($run_shell) ? false : true;

if ($run) {
//Eliminación del archivo a firmar y del archivo PKCS12
    echo '<a href="./tmp/'.$datetime.'-signed.pdf"> Download PDF signed</a>';
    // Se borran los archivos de tmp
    unlink($route_pdf) or die("No se pudo eliminar el pdf");
    unlink($route_pkcs12) or die("No se pudo eliminar el p12");
} else {
    echo "PortableSigner no se ejecutó correctamente.";
}

Como podemos observar en el código del script run_script.php se almacenan los
archivos gestionados para el proceso de firma en un directorio con el nombre de
tmp/, en este sentido procedemos a crear dicho directorio dentro de la carpeta
murachi creada anteriormente y le asignamos los permiso necesarios para que
pueda ser utilizado.

$ mkdir tmp

$ sudo chown -R www-data:www-data /var/www/html/murachi/*

$ sudo chmod 777 /var/www/html/murachi/*

Hasta este momento se debe tener en el servidor de Apache dentro de la carpeta
murachi el archivo index.php, run_script.php, el ejecutable PortableSigner.jar y
el directorio tmp/. Verifique que sea así y que se encuentra en la ruta
indicada.

Por último, se ejecuta en el navegador /localhost/murachi/index.php, se carga el
archivo PDF a firmar, el certificado en formato PKCS#12 junto con su contraseña
o frase paso y se procede a hacer clic en el botón enviar y el resultado sera un
enlace (Download PDF signed) para descargar el archivo firmado.

Para verificar la firma electrónica del archivo firmado en esta sección puede
ingresar al portal de MURACHÍ (https://murachi.cenditel.gob.ve/) sección
Verificar (viñeta Verificar) y enviar el archivo firmado.

===============================
Abrir nautilus desde la consola
===============================

$ /usr/bin/nautilus

ó

Alt + f2 y tipear y luego enter:

/usr/bin/nautilus

============
Patch (Unix)
============

Patch es un comando de Unix que actualiza ficheros de texto de acuerdo a las
instrucciones contenidas en un archivo separado, llamado archivo de parche. Este
archivo (denominado patch) es un archivo de texto que consiste en una lista de
las diferencias entre ficheros y se produce mediante la ejecución del comando
diff comparando con el fichero original y actualizándolo con los argumentos de
diff.

El programa original fue escrito por Larry Wall (creador del lenguaje de
programación Perl) en mayo de 1985. Una nueva versión del programa es parte del
proyecto GNU y es mantenido por la FSF.

Contexto de uso
===============

El comando se utiliza con frecuencia para la actualización del código fuente a
una versión más reciente. Debido a esto es utilizado frecuentemente en sistemas
de control de código fuente como CVS. El programa no solo es capaz de añadir
texto como puede intuirse, también es capaz de eliminarlo.

Ejemplo de uso
==============

1- Creación del fichero:

Creamos el fichero a.txt, agregar contenido, hacer una copia de a.txt que se
llamará b.txt y hacerle modificaciones:

2- Comparar las diferencias con git diff, se requiere tener instalado el paquete
git:

$ git diff a.txt b.txt

3- Crear archivo que contiene la mezcla de ambos archivo, lo cual incluye las
modificaciones:

$ diff -u a.txt b.txt > mods.diff

Esto nos crea el archivo mods.diff el cual podemos revisar y ver su contenido
para ver como funciona.

4- Aplicación del parche, con el siguiente comando vamos a aplicar creado,
esto quiere decir que b.txt ahora a.txt se actualizara con las modificaciones de
b.txt:

$ patch < mods.diff

El resultado es que ahora a.txt y b.txt son iguales.

====================================
Aplicar parche de múltiples archivos
====================================

En este ejemplo necesitamos aplicar los cambios de b.txt en a.txt y de d.txt en
c.txt

Primero, necesitas crear un archivo que contenga las diferencias entre a.txt y
b.txt, así como entre c.txt y d.txt.

Luego, puedes combinar ambos conjuntos de diferencias en un solo archivo mods.diff.

Aquí tienes los pasos detallados:

Genera las diferencias entre a.txt y b.txt, y entre c.txt y d.txt:

$ diff -u a.txt b.txt > diffs_ab.diff

$ diff -u c.txt d.txt > diffs_cd.diff

Combina ambos archivos de diferencias en uno solo, mods.diff:

$ cat diffs_ab.diff diffs_cd.diff > mods.diff

Ahora, mods.diff contendrá las diferencias entre a.txt y b.txt, así como entre
c.txt y d.txt, en un solo archivo y aplicar el parche con:

$ patch < mods.diff

====================================================================
Aplicar parche de múltiples archivos que están dentro de directorios
====================================================================

En este ejemplo vamos a aplicar el parche de modificaciones sobre 2 archivos:
ReportController.php y UserController.php que están dentro de directorios

└── project
    ├── reports
    │   └── ReportController.php
    └── users
        └── UserController.php

1- En la carpeta raíz deberemos tener a project/ ReportControllerMod.php y
UserControllerMod.php que son los archivos modificados y el proyecto con los
archivos originales.

2- Ahora hacemos que la carpet project sea un repo de git local:

project$ git init

3- Luego hacer un commit:

project$ git add .

project$ git commit -m "Initial commit"

Con esto el commit inicial tiene la versión sin moficicar.

4- Ahora hacemos las modificaciones en los archivos ReportController.php y
UserController.php y hacemos un nuevo commit con esas modificaciones.

Debemos tener 2 commit, algo como esto:

project$ git log
commit 851b8e64b3462f46fefd96dd3db2ad05276624bf (HEAD -> master)
Author: Timmy Hardwell <thardwell@mail.com>
Date:   Fri May 3 21:00:46 2024 -0400

    Modificando archivos

commit 5e61aa093a2b40fe34a1d5e389ad997794986b7d
Author: Timmy Hardwell <thardwell@mail.com>
Date:   Fri May 3 20:57:19 2024 -0400

    Initial commit

5- Ahora vamos a usar la funcionalidad format-patch de git para ver las
diferencias entre el primer commit y el final del log,
5e61aa093a2b40fe34a1d5e389ad997794986b7d es el hash del primero commit

project$ git format-patch --stdout 5e61aa093a2b40fe34a1d5e389ad997794986b7d | less

La salida del comando anterior son las diferencias, solo para examinarlas.

6- Ahora vamos a generar un archivo .diff con las modificaciones y lo guardamos
en la carpeta raíz

project$ git format-patch --stdout 5e61aa093a2b40fe34a1d5e389ad997794986b7d > /home/user/mods.diff

El archivo mods.diff contentra algo como esto:

From 851b8e64b3462f46fefd96dd3db2ad05276624bf Mon Sep 17 00:00:00 2001
From: Timmy Hardwell <thardwell@mail.com>
Date: Fri, 3 May 2024 21:00:46 -0400
Subject: [PATCH] Modificando archivos

---
 reports/ReportController.php | 3 ++-
 users/UserController.php     | 3 ++-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/reports/ReportController.php b/reports/ReportController.php
index d988ef9..2cb8d50 100644
--- a/reports/ReportController.php
+++ b/reports/ReportController.php
@@ -1 +1,2 @@
-test report controller
\ No newline at end of file
+test report controller
+new line in report controller
\ No newline at end of file
diff --git a/users/UserController.php b/users/UserController.php
index d7883c0..76418b5 100644
--- a/users/UserController.php
+++ b/users/UserController.php
@@ -1 +1,2 @@
-test user controller
\ No newline at end of file
+test user controller
+new line in user controller
\ No newline at end of file
-- 
2.39.2

7- Ahora estando dentro de la carpeta project vamos a ejecutar un comando 
para aplicar el parche mods.diff que está en la carpeta raíz:

project$ patch -p1 < ../mods.diff

Esto habrá aplicado las modificaciones sobre los archivos correspondientes

Nota: No se necesita tener git para aplicar los parches y no importa si no
está versionada con git la carpeta donde se aplicaran las modificaciones pero 
en esta guía si se necesita git para generar el archivo con las modificaciones.

Fuentes
=======

ChatGPT
Ing. Dhionel Díaz

================================================================
Monitorear temperatura del CPU y otros componentes de la máquina
================================================================

$ sudo apt install lm-sensors

$ sudo sensors-detect

Luego darle yes a todo

$ sensors

Esto muestra algo como esto:

HP_smm-virtual-0
Adapter: Virtual device
Processor Fan: 2876 RPM
CPU:            +56.0°C
Ambient:        +33.0°C
SODIMM:         +43.0°C
GPU:            +47.0°C

nouveau-pci-0100
Adapter: PCI adapter
GPU core:         N/A  (min =  +0.85 V, max =  +1.03 V)
temp1:            N/A  (high = +95.0°C, hyst =  +3.0°C)
                       (crit = +105.0°C, hyst =  +5.0°C)

                       (emerg = +135.0°C, hyst =  +5.0°C)
acpitz-acpi-0
Adapter: ACPI interface
temp1:        +25.0°C  (crit = +107.0°C)

coretemp-isa-0000
Adapter: ISA adapter
Package id 0:  +58.0°C  (high = +86.0°C, crit = +100.0°C)
Core 0:        +58.0°C  (high = +86.0°C, crit = +100.0°C)
Core 1:        +54.0°C  (high = +86.0°C, crit = +100.0°C)

BAT0-acpi-0
Adapter: ACPI interface
in0:          12.34 V  
curr1:         2.74 A 

Donde notamos que nos dice la temperatura actual en grados centigrados, además
de que nos indica cual valor sería lato y cual sería crítico.

Para el procesador no de bería pasar de los 70°C, en este ejemplo está en 58°C
cada núcleo.

===========================
Mbps (Megabits por segundo)
===========================

Los megabits por segundo se refieren a la velocidad a la que se transmite 1
Megabit (Mb) en un segundo. 1 Mb se refiere a 1000^2 bits o 1.000 Kb. El uso del
prefijo "Mega-" para mostrar cantidades de un millón de Mbps es una medida común
de las velocidades de transmisión de datos actuales. Un bit es la unidad más
pequeña de información en un sistema digital que pertenece a un valor binario.

Hay una diferencia entre Mbps y MBps, ya que la letra "b" más pequeña denotaría
bits, mientras que la "B" mayúscula se utilizaría al referirse a un cluster de
datos más grande, bytes. Un solo byte es un grupo de 8 bits. Como resultado, un
megabit se referiría a 1.000.000 bits mientras que un megabyte se referiría a
8.000 bits. Los datos de Internet se indican en bytes, pero las velocidades se
miden en bits por segundo, ya que la transmisión de datos se realiza de a 1 bit
cada vez.

La tecnología moderna transfiere datos a velocidades medidas en Mbps. Mientras
que los sistemas altamente desarrollados pueden proporcionar velocidades aún más
rápidas medidas en Gigabits por segundo, con 1Gb equivalente a 1.000Mb, las
tasas más comunes en todo el mundo siguen estando al nivel de los Mbps. La
tecnología anterior funcionaba a velocidades tan bajas como 56Kbps.
Afortunadamente, los crecientes desarrollos en la industria de la tecnología han
llevado a velocidades más rápidas. 1 Mbps equivale a 1.000 Kbps o 1.000.000 bps.
1 Gbps es igual a 1.000.000.000 Kbps o 1.000 millones de bps. La mayoría de las
velocidades de datos se registran en Mbps.

=======================================================
Usar la ñ y las vocales con acénto en teclado en inglés
=======================================================

Agregar en la configuración de idioma o región el Inglés Internacional
con teclas muertas, luego:

ñ = Alt + n

Ñ = Alt + Shit + n

á é í ó ú = Alt + vocal.

==========================
Instalar Wine en Debian 12
==========================

Comprobar arquitecturas instaladas:

1- Verifique la arquitectura de 64 bits.

El siguiente comando debería responder con "amd64".

$ dpkg --print-architecture

2- Vea si la arquitectura de 32 bits ya está instalada.

El siguiente comando debería responder con "i386":

$ dpkg --print-foreign-architectures

Si no muestra "i386", ejecute lo siguiente:

$ sudo dpkg --add-architecture i386

Vuelva a verificar con:

$ dpkg --print-foreign-architectures

3- Descargue y agregue la clave del repositorio WineHQ.

$ sudo mkdir -pm755 /etc/apt/keyrings

$ sudo wget -O /etc/apt/keyrings/winehq-archive.key https://dl.winehq.org/wine-builds/winehq.key

Agrege el repositorio de Wine:

$ sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/debian/dists/bookworm/winehq-bookworm.sources

4- Actualice la lista de paquetes

$ sudo apt update

5- Instalar Wine:

El siguiente comando instala Wine Stable. Para instalar Wine Development o Wine
Staging, reemplace winehq-stable por winehq-devel o winehq-staging

Después de una actualización importante de Wine (de Wine 6 a Wine 7, por
ejemplo), es posible que Wine Stable no esté disponible temporalmente, pero Wine
Development y Wine Staging aún se pueden instalar.

$ sudo apt-get install apt-transport-https

$ sudo apt install --install-recommends winehq-stable

Verificar la instalación:

$ wine --version

7- Si los comandos anteriores fallan instale wine de la siguiente manera:

$ sudo apt-get install apt-transport-https

$ sudo apt-get install wine

Verificar la instalación:

$ wine --version

Otra forma
==========

$ sudo apt-get install apt-transport-https

$ sudo dpkg --add-architecture i386

$ wget -nc https://dl.winehq.org/wine-builds/Release.key

$ sudo apt-key add Release.key

Add this on /etc/apt/sources.list save changes and update repos:
deb https://dl.winehq.org/wine-builds/debian/ bookworm main

$ sudo apt-get update

$ sudo apt-get install wine

$ wine --version

Configurar Wine
===============

Para abrir el panel de configuración de Wine, abra una ventana de Terminal y
ejecute winecfg. Si se ofrece instalar mono o gecko, acepte la oferta.

$ wine winecfg

Cuando se le solicite, configure su versión preferida de Windows. Es posible que
se prefiera Windows 10 para la mayoría de las aplicaciones.

Pruebas sencillas
=================

Sólo por diversión o para ver a Wine en acción...

Mostrar un reloj simple:

$ wine clock

-----

Ejecute el navegador web integrado de Wine:

Si se ofrece instalar gecko, acepte la oferta.

$ wine iexplore

-----

Abrir el explorador de archivos.

$ wine explorer

Fuentes
=======

https://wine.htmlvalidator.com/install-wine-on-debian-12.html

https://www.softzone.es/linux/tutoriales/instalar-configurar-wine/

================
Desinstalar wine
================

$ sudo apt-get --purge remove wine wine64 libwine fonts-wine

$ cd $HOME

$ rm -r .wine

$ rm .config/menus/applications-merged/wine*

$ rm -r .local/share/applications/wine

$ rm .local/share/desktop-directories/wine*

$ rm .local/share/icons/????_*.xpm

Estos comandos eliminan archivos almacenados en el disco duro que pueden
bloquear la desinstalación de Wine. Es muy posible que reciba algunas
advertencias sobre rm: remove write-protected regular file aquí. Estos se pueden
hacer cumplir colectivamente mediante el uso de la f opción, es decir rm -f y
rm -rf en lugar de lo anterior.

Después de eliminar los archivos, ejecute el comando:

$ sudo apt-get remove --purge wine

Haga lo siguiente para corregir cualquier error de instalación.

$ sudo apt-get update

$ sudo apt-get autoclean

$ sudo apt-get clean

$ sudo apt-get autoremove

=========================================
Desinstalar programas instalados con wine
=========================================

Wine se instala con una utilidad de desinstalación. similar a agregar/quitar
programas en Windows. debería funcionar con la mayoría de los programas, pero
posiblemente no con algunos instaladores.

$ wine uninstaller

====================================
Instalar Counter-Strike en Debian 11
====================================

$ sudo apt-get install apt-transport-https

$ sudo dpkg --add-architecture i386

$ wget -nc https://dl.winehq.org/wine-builds/Release.key

$ sudo apt-key add Release.key

Add this on /etc/apt/sources.list save changes and update repos:
deb https://dl.winehq.org/wine-builds/debian/ jessie main

$ sudo apt-get update

$ sudo apt-get install wine

Instalar el juego:

$ wine cs.exe

Instalar Winetricks:

$ sudo apt install winetricks

$ winetricks corefonts vcrun6 vb6run

Ejecutar el juego, hay que ir a:

/home/user/.wine/dosdevices/c:/Games/Counter-Strike 1.6

y luego

$ wine Counter-Strike\ 1.6.exe

ó

$ wine /home/user/.wine/dosdevices/c:/Program Files (x86)/Counter-Strike 1.6

Todo depende de donde se haya instalado el juego.

================================
Instalar Zoom en Debian 10/11/12
================================

1) Descargue el archivo instalador DEB desde el Centro de descargas.

https://zoom.us/download?os=linux

2) Luego instalar las siguientes dependencias del SO:

$ sudo apt install gdebi libxcb-xtest0 libxcb-cursor0

3) Instalar el paquete descargado:

# dpkg -i zoom_amd64.deb

Listo!

Si da este error
================

dpkg: problemas de dependencias impiden la configuración de zoom:
 zoom depende de libgl1-mesa-glx; sin embargo:
  El paquete `libgl1-mesa-glx' no está instalado.
 zoom depende de libegl1-mesa; sin embargo:
  El paquete `libegl1-mesa' no está instalado.

Instale lo siguiente:

$ sudo apt-get install libxcb-xtest0

Luego de nuevo:

# dpkg -i zoom_amd64.deb

Si da este error
================

dpkg -i zoom_amd64.deb
dpkg: atención: `ldconfig' no se ha encontrado en el PATH o no es ejecutable
dpkg: atención: `start-stop-daemon' no se ha encontrado en el PATH o no es ejecutable
dpkg: error: no se ha encontrado 2 en el PATH o no es ejecutable
NOTA: El PATH de root debería incluir habitualmente /usr/local/sbin, /usr/sbin y /sbin.

Ejecute:

# export PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin

$ sudo apt-get install --reinstall debianutils libc-bin dpkg

$ sudo apt-get install -f  # Para corregir dependencias rotas si se requiere.

Luego de nuevo:

# dpkg -i zoom_amd64.deb

Preparando para desempaquetar zoom_amd64.deb ...
Desempaquetando zoom (X.X.X.XXXX) ...

Listo!

Fuente
======

DeepSeek

===========================================
Ejecutar comandos en segundo plano en Linux
===========================================

En algunas ocasiones puede ser necesario ejecutar un script en segundo plano; ya
sea porque tarde mucho en finalizar o porque el programa tiene que ejecutarse de
forma indefinida y al mismo tiempo se quieren analizar sus salidas/salidas en
tiempo real, o cuando, en el caso de conexiones remotas, por el motivo que sea,
se pueda producir una desconexión.

1 posibilidad es usar &

===========
& + bg + fg
===========

Si añadimos un ampersand (&) al final de un comando o de un script que queramos
ejecutar, este se ejecutará en segundo plano.

$ ./my-shell-script.sh &
[1] 10233

Si ejecutamos un comando de la forma habitual (en primer plano o foreground) y,
después de pasado un cierto tiempo, nos damos cuenta que hubiera sido mejor
ejecutarlo en segundo plano o background, lo podemos hacer sin necesidad de
tener que matar el proceso y volver a ejecutarlo de nuevo con el ampersand.
Esto se hace presionando “CTRL+Z” para suspender la ejecución del comando
actual, y después invocando el comando bg.

$ ./my-shell-script.sh
^Z
[2]+  Detenido                my-shell-script.sh

$ bg
[2]+ my-shell-script.sh &

Este proceso que acaba de pasar al segundo plano, también se puede volver al
primer plano con el comando fg.

$ fg 2
my-shell-script.sh

Fuente
======

https://medium.com/@calmarianet/3-formas-de-ejecutar-comandos-en-segundo-plano-en-linux-9dedb779ca7d

===============================
Colorear el prompt del terminal
===============================

Metemos esto en la consola y nos pinta el user y el nombre de la máquina:

$ PS1='${debian_chroot:+($debian_chroot)}\[\033[01;33m\]\u\[\033[01;35m\]@\[\033[01;33m\]\h\[\033[00;33m\]:\[\033[01;34m\]\w\[\033[00m\]$ '

ó esto:

$ PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u\[\033[01;34m\]@\[\033[01;33m\]\h\[\033[00;33m\]:\[\033[01;34m\]\w\[\033[00m\]$ '

Ver el link la fuente para ver los demás colores.

Si lo metemos en el .bashrc ya colorea siempre la consola.

Otras pruebas
=============

Prompt por defecto

$ PS1="\u@\h:\W\$ "

Ahora, nuestro prompt quedará tal que así:

:~$

-----

#Prompt con caracteres adicionales
$ PS1="[\u@\h:\W]\$> "

Ahora, nuestro prompt quedará tal que así:

[usuario@hostname:~]$>

-----

Modificación sencilla de nombre de usuario y host:

$ PS1="Hola@bienvenido> "

Ahora, nuestro prompt quedará tal que así:

Hola@bienvenido>

-----

Cambiar el color de fondo al nombre del host, el código a utilizar sería este:

$ PS1="\u@\[\e[31;46m\]\h\[\e[m\] "

Fuentes
=======

-https://ubuntuperonista.blogspot.com/2014/01/como-cambio-los-colores-del-prompt-en.html
-https://www.zeppelinux.es/modificar-el-prompt-en-una-shell-bash/
-https://ubunlog.com/prompt-ejemplos-personalizar-terminal/

=======================================
Mover y redimensionar ventanas en Gnome
=======================================

Mueva una ventana arrastrándola desde la barra de título o manteniendo pulsada
la tecla Súper o Tecla ventana y arrastrando en cualquier parte de la ventana.

Fuente
======

https://help.ubuntu.com/stable/ubuntu-help/shell-windows-states.html.es

====================================================================
Programas recomendados para el un sistema operativo recién instalado
====================================================================

terminator
vim
crear alias en el .bashrc
Colorear el prompt del terminal
sudo (Configurarlo)
aptitude (Probar)
ssh
git (Configurarlo, Probarlo)
vlc player
apache (Probar)
postgresql (Probar)
Virtual Box (Opcional)
rsync
xclip
meld
alacarte
audacity
gimp
Inkscape
gnome-paint (No sirve en Debian 13, se puede instalar kolourpaint con span).
progress
pavucontrol
vscode o sublime
firefox de la página oficial y crear lanzador al ejecutable
Google Chrome
Opera Browser

// Calculadora para Linux
qalculate-gtk

// Software para que el fondo de escritorio cambie cada 5min.
Variety

Crear script Run Desktop

====================================================
Apagar el ordenador después de un tiempo determinado
====================================================

Abrimos una terminal. Una vez abierta la terminal ejecutamos el siguiente
comando:

$ sudo shutdown -h +30

El significado de cada uno los términos del comando son los siguientes:

sudo: Porque el programa shutdown precisa permisos de superusuario para
ejecutarse.

shutdown: Es el programa que permite programar el apagado del ordenador.

-h: Indica la acción a realizar una vez pasado un tiempo determinado. En este
caso la acción es la acción halt (-h). Por lo tanto una vez pasado el tiempo que
queramos el ordenador se apagará.

+30: Indicamos el tiempo en minutos que queremos que tarde en apagarse el
ordenador.

El comando "shutdown" se encarga de apagar el sistema de manera segura,
asegurándose de que todos los procesos se cierren correctamente antes de apagar
el sistema. Por lo tanto, no debes preocuparte por un apagado brusco o pérdida
de datos.

Además, si por alguna razón necesitas cancelar el apagado programado, puedes
hacerlo usando el siguiente comando en la terminal:

$ sudo shutdown -c

Esto cancelará el apagado programado y mantendrá el sistema encendido.

Fuente
======

https://geekland.eu/programar-el-apagado-del-ordenador/

ChatGPT

Posible missing firmware /lib/firmware/rtl_nic/rtlXXXX

Indica que el kernel de Linux no pudo encontrar el archivo de firmware necesario
para que un dispositivo de red funcione correctamente.

Para solucionar este problema, debes instalar el firmware correspondiente. En
este caso, el firmware que falta es para el controlador de red RTLXXX.

Sigue estos pasos para instalar el firmware:

Abre una terminal en Debian.

Ingresa el siguiente comando para instalar el paquete "firmware-realtek":

$ sudo apt-get install firmware-realtek

Reinicia tu sistema.

Fuente
======

ChatGPT

=====
NGROK
=====

NGROK es una herramienta de uso gratuito que nos permite exponer nuestro entorno
local a la web, es decir, podemos "publicar" nuestro trabajo en local para que
el resto del mundo lo pueda ver sin la necesidad de subir la aplicación a un
servidor.

1- Creamos una cuenta e iniciamos sesión en https://ngrok.com

2- Descargamos el script desde https://dashboard.ngrok.com/get-started/setup
nos quedara algo como esto ngrok-v3-stable-linux-amd64.tgz

3- Descomprimimos el archivo, nos debe quedar una carpeta de nombre
ngrok-v3-stable-linux-amd64 y dentro debe haber un script llamado ngrok

4- Conecta tu cuenta

Ejecutar este comando agregará su authtoken al archivo de configuración
predeterminado ngrok.yml.

Esto le otorgará acceso a más funciones y tiempos de sesión más prolongados.

Los túneles en ejecución aparecerán en la página de puntos finales del tablero.

El token es proporcionado desde la web.

$ ngrok config add-authtoken XXXXXX

ó

$ ./ngrok config add-authtoken XXXXXX

4. Copiamos el script ngrok obtenido dentro de /var/www/html

5. Ejecutamos el script desde /var/ww/html con:

/var/www/html$ ./ngrok http 80

Esto te levanta un servicio:

ngrok                                                                                                                                         (Ctrl+C to quit)
                                                                                                                                                              
Announcing ngrok-rs: The ngrok agent as a Rust crate: https://ngrok.com/rust                                                                                  
                                                                                                                                                              
Session Status                online                                                                                                                          
Account                       usuario-de-mi-cuenta@mail.com (Plan: Free)                                                                                          
Version                       3.2.2                                                                                                                           
Region                        United States (us)                                                                                                              
Latency                       -                                                                                                                               
Web Interface                 http://127.0.0.1:4040                                                                                                           
Forwarding                    https://a71f-XXXXX.ngrok.io -> http://localhost:80                                                                      
                                                                                                                                                              
Connections                   ttl     opn     rt1     rt5     p50     p90                                                                                     
                              0       0       0.00    0.00    0.00    0.00

Si copias esta dirección en la web, podrás ver el contenido de /var/www/html
desde cualquier parte.

Esto es ideal para mostrar proyectos, hacer pruebas, etc.

Conectarse por ssh usando ngrok
===============================

--- En el servidor ---

1- Instalar openssh-server

$ sudo apt install openssh-server

2- Ejecutar el servicio de openssh-server

$ sudo service ssh start

3- Ejecutar ngrok con tcp y el puerto 22

$ ./ngrok tcp 22

# ngrok will start like:
# ngrok by @inconshreveable                                     (Ctrl+C to quit)
#                                                                                                
# Session Status                online                                                            
# Account                       User Name (Plan: Free)                                      
# Version                       2.3.27                                                            
# Region                        United States (us)                                                
# Web Interface                 http://127.0.0.1:4040                                             
# Forwarding                    tcp://0.tcp.ngrok.io:16965 -> localhost:22
#                            /\ url and port number you'll use on ssh connection

--- En el cliente ---

Si el usuario de la maquina es decir el servidor es pcontreras entonces:

$ ssh pcontreras@0.tcp.ngrok.io -p 16965

Te pedirá la contrasena del usuario pcontreras del servidor, la introduces y
listo! ya estás en el server mediante SSH.

==============================================================
Correr aplicación Laravel usando ngrok para verla por internet
==============================================================

1- Inicia tu servidor local de Laravel ejecutando el comando adecuado, como php
artisan serve en la raíz de tu proyecto Laravel, esto seguro servira la app
en una dirección como esta: http://127.0.0.1:8000

2- Abre una nueva terminal o línea de comandos y ejecuta el comando ngrok,
especificando el puerto en el que se está ejecutando tu servidor Laravel. Por
ejemplo, si tu servidor se está ejecutando en el puerto 8000, utiliza el
siguiente comando:

$ ./ngrok http 8000

Ngrok generará una URL pública que puedes compartir con la persona a la que
deseas mostrar tu aplicación.

Copia la URL generada por ngrok y compártela con la persona a la que deseas
mostrar tu aplicación. Cuando esa persona acceda a la URL en su navegador web,
el tráfico se redirigirá a tu servidor local y podrán ver y utilizar tu
aplicación Laravel en tiempo real.

Recuerda que ngrok genera una URL pública temporal que puede cambiar cada vez
que lo ejecutas.

Fuentes
=======

https://dashboard.ngrok.com/get-started/setup

https://www.youtube.com/watch?v=NqCYquO3byk

https://gist.github.com/philippeoz/e33632f11c64149a00393465fee2cff5

https://www.endtoend.ai/tutorial/ngrok-ssh-forwarding/

ChatGPT

Teamviewer
==========

1- Descargamos el .deb desde https://www.teamviewer.com/es-mx/descarga/linux/ o
directamente con:

$ wget -c https://download.teamviewer.com/download/linux/teamviewer_amd64.deb

2- Realizamos la instalación con:

# dpkg -i teamviewer_amd64.deb

3- Ejecutar teamviewer:

$ teamviewer

4- Esto te abrira el cliente de teamviewer en el cual veras un id y una
contraseña, en la segunda máquina a la cual te quieres conectar, también debes
realizar toda la instalación igual, abrir el cliente de teamviewer y ya, desde
cualquiera de los dos clientes, debes introducir el id y la contraseña de la
máquina a la cual te quieres conectar.

================
¿Qué es pfSense?
================

PfSense es un programa de código abierto que le permite a un usuario tener un
firewall de alto nivel en su ordenador. PfSense permite establecer cortafuegos
desde máquinas virtuales, las cuales pueden descargarse desde su página oficial.
No obstante, también se venden dispositivos físicos (appliances), que traen el
sistema incorporado y listo para funcionar.

PfSense es un cortafuegos que se ubica entre internet y nuestros dispositivos
con el fin de detectar actividades sospechosas y bloquearlas de inmediato. Esto
nos puede poner a salvo de la mayoría de amenazas externas (aunque también
pueden existir fuentes de amenaza internas). Por esta razón, se trata de un
software o hardware bastante útil para las compañías o, incluso, para uso
personal.

Existen diferentes tipos de firewalls y, por supuesto, también diferentes
formatos. PfSense puede clasificarse dentro del tipo de firewall UTM, cuyas
siglas significan unified threat management, que se traduce como gestión
unificada de amenazas. Esto quiere decir que pfSense contiene un conjunto de
funciones avanzadas que van más allá de la simple regulación del tráfico de red
basado en normas.

Al ser un software 100% libre, su código fuente puede hallarse en un repositorio
de GitHub. Por este motivo, la aplicación también puede personalizarse según las
necesidades del equipo de ciberseguridad. Aprender qué es pfSense, cómo
implementarlo y cómo se desarrolló es esencial para contar con un firewall de
alto nivel, totalmente gratuito, protegiendo tu red.

Fuente
======

https://keepcoding.io/blog/que-es-pfsense/

================
¿Qué es PROXMOX?
================

PROXMOX VE “Virtual Environment” es una potente plataforma de virtualización de
nivel empresarial 100% libre y sin límites en su uso.

PROXMOX VE ofrece beneficios similares a los productos para virtualización como
VMware vSphere, Windows Hyper-V, Citrix XenServer, entre otros.

​Siendo PROXMOX libre sin costo, lo puede instalar en cualquier cantidad de
“Servidores físicos”, sin límite en uso de Procesadores y Sockets, Puentes de
comunicación, o integración de NAS o SAN ya sea a través de Fibra Canal, iSCSI
Over Ethernet o NFS.

Principales características de PROXMOX
======================================

Administrador Web HTML5, PROXMOX proporciona un interfaz Web para configurar los
servidores físicos, cluster, máquinas virtuales, políticas de backups,
restauración de backups, snapshots. No es necesario instalar aplicaciones
clientes en su máquina para administrar y siendo HTML5 le permite conectarse y
gestionar el entorno virtualizado desde su Smartphone Android, Iphone, tablet's,
entre otros.

​Virtualización para la mayoría de Sistemas Operativos, en sus versiones
32/64bits: Linux en todas sus versiones, Microsoft Windows 10 / 2016 / 2012 / 7
/ 8/ 2003 / xp, Solaris, AIX, entre otros.

​KVM (Máquina virtual basada en el núcleo) es una solución para implementar
virtualización sobre Linux. Puede funcionar en hardware x86/x86_64 y es
necesario que el microprocesador tenga soporte de virtualización Intel "VT" y en
AMD "SVM".​

​Container-based Virtualization (LXC), es una alternativa para ejecutar máquina
"Linux" en espacios separados. A diferencia de la virtualización este funciona
como un módulo agregado al servidor físico y hace uso directo del hardware
(también conocido como Paravirtualización).

Backup & Restore de "Máquinas Virtuales". En Proxmox el efectuar estas tareas es
muy sencillo y se administra a través de su interfaz Web. Puede efectuar un
backup de forma inmediata o dejarlo programado. La restauración es simple, solo
debe de seleccionar el backup a restaurar y listo.

Snapshot Live. le permite hacer copias instantáneas de "Máquinas Virtuales"
incluyendo el contenido de la RAM, su configuración y el estado de los discos
virtuales. Usted puede retroceder en tiempo la "Maquina Virtual" restaurando
spanshot's.

​"Migración en caliente". En la gráfica izquierda se muestra un pequeño cluster
formado por 3 nodos y poblado con “Máquinas virtuales”. Con fondo rojo se
muestra un nodo con sobrecarga. La administración de los nodos es centralizada a
través de un interfaz Web, permitiéndole movilizar “Máquinas virtuales” entre
cada “Servidor Físico (NODO)” sin tener que apagar la “Máquina Virtual”.​

"Cluster Alta disponibilidad". Esta característica le permite definir reglas de
“Alta disponibilidad” en el cluster, por ejemplo: Si uno de los “Servidores
Físicos (NODO)” esta sobrecargado, este transfiere automáticamente a otro
“Servidor Físico (NODO)” con menos carga la “Máquina Virtual”. Este ejemplo es
una regla de "balanceo de carga entre nodos".

Administración centralizada. En un "Cluster Proxmox" se debe definir una de los
Nodos como "Orquestador" con el objetivo de centralizar el trabajo, sin embargo
cada nodo cuenta con su propio administrador Web.

Cluster no SPOF (Single Point Of Failure). Cada nodo "Servidor físico Proxmox"
cuenta con su propio interfaz Web permitiendo acceso a la administración de las
"Máquinas Virtuales". Si el nodo "Orquestador" llega a fallar, cada nodo tiene
replicado la información del "Orquestador" y desde cualquiera de los nodos puede
tomar control del cluster.

Puentes de red. Proxmox administra las tarjetas físicas a través de "Bridges"
que comparte a las "Máquinas Virtuales". Es muy sencillo asociar 1 o varias
tarjetas a un "Bridge" haciendo un balanceo automático del tráfico de datos.

NAS & SAN. Es muy fácil el uso de NAS o SAN ya sea a través de Fibra Canal,
iSCSI Over Ethernet o NFS. Proxmox no le limita.

Autenticación. Puede configurar la autenticación de acceso al área de
"Administración a los Nodos" a través de cuentas propias con Proxmox o
utilizando LDAP/Active Directory.

Firewall. Proxmox VE Firewall proporciona una manera fácil de proteger su
infraestructura en un entorno virtualizado. Puede definir reglas de firewall
para todas las máquinas virtuales o definir reglas precisas a una máquina
virtual.

¿Cómo funciona Proxmox?
=======================

Proxmox, le permite instalar en múltiples equipos y los únicos requisitos que le
pide es tener un "Procesador que cuente con VT o SVM" y que la máquina esté
vacía. El implanta Debian como sistema operativo y configura KVM para trabajar
con el recurso físico.

Cada máquina con Proxmox se convierte en un NODO y puede trabajar de forma
independiente o puede estar agrupado en un Cluster. El beneficio de definir un
Cluster es tener la administración centralizada, poder mover máquinas entre cada
nodo, activar "Alta Disponibilidad" y aprovechar todo el recurso de los equipos
físicos para la virtualización.

Para hacer uso de "Alta Disponibilidad" y "Mover Máquinas Virtuales sin
apagarlas" es necesario definir un "dispositivo de almacenamiento de tipo NAS o
SAN" por ejemplo OpenMediaVault o FreeNAS. También puede utilizar ECM, NetAPP,
DELL Equallogic, entre otros.

¿Que nos permite el Administración Web PROXMOX?
===============================================

Agregar "Máquinas Virtuales" y gestionarlas. Por ejemplo, puede apagar,
reiniciar, agregar hardware virtual, entre otros.

Mover máquinas entre cada nodo o activar "Alta Disponibilidad".

Conectarse directamente al interfaz gráfico o consola de la "Máquina Virtual" a
través de una conexión segura VNC "HTML5 WebSockets and Canvas -- NoVNC".

Programar Backups, restaurar backups o generar Snapshot.

Ver de forma gráfica la información de las "Máquinas Virtuales" como el tráfico
de red, consumo de procesador, consumo de memoria, entre otros.

Subir medias en formato ISO para instalar sistemas operativos en las "Máquinas
Virtuales".

Cambiar la configuración de los nodos.

Definir reglas en "Proxmox Firewall VE" para todas las "Máquinas Virtuales" o
para una es especial.

El Administrador Web PROXMOX es HTML5 por lo cual le será posible conectarse y
trabajar desde su Smartphone Android, Iphone, tablet's entre otros.

Fuente
======

http://911-ubuntu.weebly.com/proxmox_como_funciona/conoce-como-funciona-proxmox-y-como-usarlo

==============
Instalar Brave
==============

Brave es un navegador web de código abierto basado en Chromium, creado por la
compañía Brave Software en el año 2016, fundada por el cofundador del Proyecto
Mozilla y creador de JavaScript, Brendan Eich.​ A partir de 2019, Brave ha sido
lanzado para Windows, macOS, Linux, Android e iOS.

Instalación con apt
===================

$ sudo apt install curl

$ sudo curl -fsSLo /usr/share/keyrings/brave-browser-archive-keyring.gpg https://brave-browser-apt-release.s3.brave.com/brave-browser-archive-keyring.gpg

$ echo "deb [signed-by=/usr/share/keyrings/brave-browser-archive-keyring.gpg] https://brave-browser-apt-release.s3.brave.com/ stable main"|sudo tee /etc/apt/sources.list.d/brave-browser-release.list

$ sudo apt update

$ sudo apt install brave-browser

Instalación con Snap
====================

$ sudo snap install brave

Fuente
======

https://snapcraft.io/brave

=======================
Instalar Microsoft Edge
=======================

Nota: Probado en GNU/Linux Debian 11

1- Descargar el paquete .deb desde el sitio web de Microsoft https://www.microsoft.com/en-us/edge

2- Instalar el paquete .deb descargado:

# dpkg -i microsoft-edge-stable_114.0.1823.79-1_amd64.deb

3- Abrir el navegador:

$ microsoft-edge

==========
echo $PATH
==========

En Linux Debian, el comando echo $PATH muestra el valor de la variable de
entorno PATH. Esta variable es una de las más importantes en sistemas Unix y
Linux, y es utilizada por el sistema operativo para buscar ejecutables y
programas en el sistema de archivos.

La variable PATH contiene una lista de directorios separados por dos puntos (:),
y cada uno de estos directorios es escaneado por el sistema para encontrar
ejecutables cuando se ejecuta un comando en la terminal. Cuando escribes un
comando en la terminal, el sistema busca en cada uno de los directorios
especificados en PATH para encontrar el ejecutable asociado con ese comando.

Por ejemplo, si ejecutas echo $PATH en la terminal, podrías obtener una salida
similar a esta:

/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/
local/games:/snap/bin

Esta salida muestra los directorios que el sistema busca para encontrar los
ejecutables. Si ejecutas un comando que no está ubicado en uno de estos
directorios, obtendrás un error del tipo "comando no encontrado".

Es importante tener la variable PATH configurada correctamente para que puedas
acceder a los comandos y programas instalados en tu sistema sin tener que
escribir la ruta completa hasta su ubicación. Si necesitas agregar un nuevo
directorio al PATH, puedes hacerlo modificando el archivo de inicio de tu shell
(como .bashrc, .bash_profile, o .profile, dependiendo de la shell que uses).

Editar la variable de entorno $PATH
===================================

Para editar la variable de entorno $PATH en Linux Debian, puedes modificar
algunos archivos de inicio de sesión específicos según la shell que estés
utilizando (por ejemplo, Bash, Zsh, etc.). Aquí te menciono los archivos más
comunes donde puedes agregar o modificar la variable $PATH:

Bash: Si estás utilizando la shell Bash (que es la predeterminada en muchas
distribuciones de Linux, incluyendo Debian), puedes editar el archivo ~/.bashrc
o ~/.bash_profile.

Abre una terminal y utiliza un editor de texto, como nano o vim, para editar el
archivo. Por ejemplo:

$ nano .bashrc

Agrega la línea que define la variable $PATH con los directorios que deseas
incluir. Por ejemplo:

export PATH="/ruta/a/tu/directorio:$PATH"

ó la que he usado:

export PATH="$PATH:/ruta/a/tu/directorio"

Guarda los cambios y cierra el editor.

Después de editar el archivo ~/.bashrc, cierra y vuelve a abrir la terminal para
que los cambios surtan efecto. También puedes ejecutar el siguiente comando para
cargar la configuración sin reiniciar la terminal:

$ source .bashrc

Fuente
======

ChatGPT

==========================
Sistemas de archivos Linux
==========================

/bin Binarios de comandos esenciales
/boot Archivos del cargador de arranque del sistema
/dev Archivos de dispositivo
/etc Archivos de configuración de todo el sistema específicos del host
/home Directorio de inicio del usuario
/lib Módulos de biblioteca compartida
/media Archivo multimedia como CD-ROM o USB
/mnt Sistemas de archivos montados temporalmente
/opt Paquetes de software de aplicaciones complementarias
/proc Sistema de archivos generado automáticamente
/root Directorio de inicio para el usuario root
/run Datos del programa en tiempo de ejecución
/sbin Binarios del sistema
/srv Datos específicos del sitio servidos por este sistema
/sys Directorio virtual que proporciona información sobre el sistema
/tmp Archivos temporales
/usr Archivos de usuario de sólo lectura
/var Archivo que se espera que cambie continuamente

Fuente
======

https://twitter.com/DanielBlancoSWE/status/1695042679103537459?t=
EYqa8G5rY4wePOjBPdc80g&s=19

==================================================================
Forzado un Yes para que un comando no pregunte la confirmación Y/N
==================================================================

Ejemplo:

$ sudo aptitude install default-jre --assume-yes

==================
El paquete OpenSSL
==================

Es una biblioteca de software de código abierto que implementa los protocolos
SSL (Secure Sockets Layer) y TLS (Transport Layer Security), que son esenciales
para la seguridad en las comunicaciones en línea. OpenSSL proporciona funciones
criptográficas y de seguridad que son utilizadas por una amplia variedad de
aplicaciones y servicios en sistemas Linux y otros sistemas operativos.

Las principales funciones de OpenSSL incluyen:

-Cifrado y Descifrado: OpenSSL ofrece algoritmos criptográficos para cifrar y
descifrar datos, asegurando la confidencialidad de la información transmitida.

-Generación de Certificados SSL/TLS: Facilita la creación y gestión de
certificados digitales que son esenciales para establecer conexiones seguras a
través de HTTPS.

Firmas Digitales: OpenSSL permite la generación y verificación de firmas
digitales, lo que garantiza la autenticidad e integridad de los datos.

-Funciones Criptográficas Generales: Incluye una variedad de funciones
criptográficas, como funciones hash y generación de números aleatorios.

-Implementación de SSL/TLS: Proporciona la implementación de los protocolos
SSL/TLS, que son fundamentales para la seguridad de las comunicaciones en
Internet.

En sistemas Debian y muchas otras distribuciones de Linux, OpenSSL es una
dependencia común para diversas aplicaciones y servicios que requieren funciones
criptográficas. Por lo tanto, se instala por defecto para garantizar que estas
aplicaciones puedan utilizar sus capacidades de seguridad de manera adecuada.

Fuente
======

ChatGPT

================================================================
Crear un Punto de Restauración en GNU/Linux - Backup del sistema
================================================================

Los que vienen desde Microsoft Windows saben que una forma de recuperar el buen
funcionamiento del sistema, es aplicando un punto de restauración. Un punto de
restauración devuelve nuestro sistema a un estado anterior en el que funcionaba
bien, algo así como devolverlo en el tiempo (un backup). En Linux también
disponemos una solución similar, pero no viene de forma predeterminada, nos toca
instalarla. Entonces veamos como crear un punto de restauración en Linux, o
backup en Ubuntu.

Aunque en Linux no es preciso hablar de «punto de restauración», sino de
«instantánea» o «snapshot». Entonces, para realizar un snapshot de nuestro
sistema, instalamos un paquete de software llamado TimeShift.

1- Instalarlo:

$ sudo apt install timeshift

2- Navgar hasta Apliaciones > Herramientas del sistema > Timeshift

3- En la primera pantalla seleccionamos el método con le vamos a realizar la
instantánea, RSYNC es la opción por defecto y recomendada, dejamos esa
eleccionada > Siguiente.

4- Seleccionamos la ubicación donde el software guardará las instantáneas >
Siguiente.

5- Definimos la periodicidad de las instantáneas, este paso se pude omitir
y se puede crear una snapshot en el momento en que se requiera > Siguiente.

6- En la siguiente pantalla definimos los directorios que vamos o no vamos a
incluir en las instantáneas, si incluímos todo significa que las instantáneas
respaldaran todo el sistema en el estado en que se encuentren > Siguiente.

7- Ahora se presenta un resumen de la configuración que hicimos, haga clic en
Finalizar para completar la configuración inicial.

8- Creación de instantáneas del sistema, haga clic en "Crear" para comenzar el
proceso de creación de la instantánea.

9- Una vez que la instantánea de su sistema se haya creado correctamente,
veremos en la instantánea creada en la lista.

10- Restaurar desde instantáneas:

Ahora que tiene la instantánea que protege su sistema, aquí le mostramos cómo
restaurarlas:
  - Abra Timeshift.
  - Seleccione la instantánea que desea restaurar de la lista.
  - Haga clic en "Restaurar" y confirme su acción.
  - Timeshift comenzará el proceso de restauración, esto puede llevar algún
      tiempo dependiendo del tamaño de la instantánea.

11- Elija el dispositivo de destino, por lo general es mejor las opciones por
defecto, haga clic en Siguiente.

12- Confirma las acciones haciendo click en Siguiente, comenzará a restaurar el
sistema desde la instantánea y lo reiniciará después de la restauración.

13- Luego de reiniciar el sistema deberá estar en la versión en que se creó la
instantánea.

Conclusión
==========

Timeshift es una herramienta invaluable para cualquiera que use Debian 12 y
quiera garantizar la estabilidad y seguridad de su sistema. Con su interfaz
fácil de usar y sus potentes capacidades de instantáneas, está equipado para
abordar problemas imprevistos con confianza.

Fuentes
=======

https://espaciotecnologico.co/crear-un-punto-de-restauracion-en-linux/
https://www.linuxbuzz.com/how-to-install-use-timeshift-on-debian/

=======================================================================
Hacer que el grub reconozca otros SO instalados como Windows por ejmplo
=======================================================================

1- Hay que instalar el paquete os-prober que es una utilidad para detectar otros
sistemas operativos en un conjunto de unidades, por lo general en Debian
GNU/Linux Debian, este paquete viene instalado por defecto.

Instalamos el paquete os-prober

$ sudo apt-get install os-prober

2- Luego editamos el archivo grub a través del editor nano de la siguiente
manera:

$ sudo nano /etc/default/grub

Debajo de la línea GRUB_CMDLINE_LINUX="" escribimos lo siguiente:

GRUB_DISABLE_OS_PROBER=false

3- Guardamos con Ctrl + O, luego presionamos la combinación de teclas luego
Ctrl + X para salir de la edición del archivo

4- Y por último actualizamos nuestro grub de arranque de la siguiente manera:

$ sudo update-grub

===============================================================
Error: ENOSPC: System limit for number of file watchers reached
===============================================================

Error: ENOSPC: System limit for number of file watchers reached, watch ''
    at FSWatcher.<computed> (node:internal/fs/watchers:247:19)
    at Object.watch (node:fs:2473:36)
    at createFsWatchInstance (file:///dist/node/chunks/dep-9A4-l-43.js:46210:17)

Este error indica que se ha alcanzado el límite del sistema para el número de
observadores de archivos (file watchers). En sistemas basados en Linux, macOS y
otros sistemas Unix, hay un límite en la cantidad de archivos que pueden ser
observados por el sistema de archivos en tiempo real para detectar cambios.

Para solucionar este problema, puedes intentar aumentar el límite de
observadores de archivos en tu sistema operativo. Aquí tienes algunos pasos para
hacerlo:

Ejecuta el siguiente comando para verificar el límite actual de observadores de
archivos:

$ cat /proc/sys/fs/inotify/max_user_watches

Si el número devuelto es bajo, puedes aumentarlo temporalmente ejecutando:

$ sudo sysctl fs.inotify.max_user_watches=524288

o puedes aumentarlo permanentemente agregando esta línea al final de tu archivo
/etc/sysctl.conf:

fs.inotify.max_user_watches=524288

Reinicia tu sistema o ejecuta sudo sysctl -p para aplicar los cambios.

Una vez que hayas aumentado el límite de observadores de archivos, vuelve a
intentar ejecutar tu aplicación y deberías evitar el error ENOSPC.

Fuente
======

ChatGPT

===================================
Finalizar la sesión actual de gnome
===================================

$ gnome-session-quit

Opciones

The following options are supported:

--logout
  Solicite al usuario que confirme el cierre de sesión.  Este es el
  comportamiento predeterminado.

--power-off
  Solicite al usuario que confirme el apagado del sistema.

--reboot
  Solicite al usuario que confirme el reinicio del sistema.

--force
  Ignore cualquier inhibidor.

--no-prompt
  Finalizar la sesión sin interacción del usuario.  Esto sólo funciona con
  --logout.

Fuente
======

https://manpages.ubuntu.com/manpages/focal/man1/gnome-session-quit.1.html


¿Que es Serialización en programación?
======================================

La serialización en programación es el proceso de convertir un objeto en una
secuencia de bytes u otro formato de datos que se pueda almacenar o transmitir.
Esto permite que los datos puedan ser guardados en un archivo, enviados a través
de una red o almacenados en una base de datos y posteriormente deserializados
para recuperar el objeto original.

Algunos formatos comunes de serialización incluyen JSON y XML.

Aquí hay un ejemplo simple en Python usando JSON:

--- Serialización ---

import json

# Un objeto en Python
data = {
  'name': 'John',
  'age': 30,
  'city': 'New York'
}

# Convertir el objeto a una cadena JSON
json_data = json.dumps(data)
print(json_data)

# Deserialización

# Convertir la cadena JSON de nuevo a un objeto de Python
data_back = json.loads(json_data)
print(data_back)

Fuente
======

ChatGPT

============================
LVM (Logical Volume Manager)
============================

En Linux es una tecnología que permite gestionar el almacenamiento de manera más
flexible y dinámica. Con LVM, puedes crear volúmenes lógicos que pueden
expandirse y contraerse fácilmente, independientemente del tamaño físico de los
discos subyacentes. Esto facilita tareas como la creación de particiones
grandes, la gestión de espacio libre entre discos y la realización de copias de
seguridad mientras el sistema está en funcionamiento.

Definiciones

PV: Volúmenes Físicos (Physical Volumes). Esto significa el disco duro,
particiones de discos duros, RAID o LUNs de un SAN que forman "Volúmenes
físicos" (o PVs).

VG: Grupos de Volúmenes (Volume Groups). Esto es una colección de uno o más
Volúmenes Físicos.

LV: Volúmenes Lógicos (Logical Volumes). Los LVs están dentro de un Grupo de
Volúmenes y conforman, en efecto, una partición virtual.

PE: Extensiones Físicas (Physical Extents). Para manipular los verdaderos datos,
se divide en bloques de datos llamados Extensiones Físicas.

LE: Extensiones Lógicas (Logical Extents). Similar a las Extensiones Físicas,
pero a nivel de Volumen Lógico. Las extensiones físicas son a los volúmenes
lógicos tal como las Extensiones Lógicas son a los Volúmenes Lógicos. El tamaño
de los bloques es el mismo para cada Volumen Lógico (LV) del mismo Grupo de
Volúmenes (VG).

LVM cifrado
===========

Al formatear un volumen LVM, se puede elegir entre LVM cifrado o LVM sin cifrar.
Para proteger la confidencialidad de tus valiosos datos, por caso en el suceso
de una pérdida o robo de tu computador o almacenamiento, tales como un volumen,
un disco de estado sólido, o un disco duro; al formatear un volumen LVM se
sugiere que consideres formatearlo usando la opción LVM cifrado (encrypted LVM).

Nota: Ni Grub ni LiLo son compatibles con LVM, así que el /boot debería quedar
fuera del disco de almacenamienteo gestionado por LVM.

Ventajas de usar LVM en Debian
==============================

Redimensionamiento Dinámico: Puedes redimensionar volúmenes lógicos (aumentar o
reducir su tamaño) sin afectar a los datos existentes o requerir un reinicio.

Administración Flexible: Puedes añadir más discos o particiones físicas al grupo
de volúmenes y luego expandir volúmenes lógicos existentes o crear nuevos.

Snapshots: LVM permite crear snapshots de volúmenes lógicos, lo que es útil para
realizar copias de seguridad sin interrumpir el funcionamiento del sistema.

Migración de Discos: Puedes mover datos entre diferentes discos físicos dentro de
un grupo de volúmenes sin interrupciones.

Proceso de utilización de LVM durante la instalación de Debian
==============================================================

Seleccionar "Guiado – utilizar disco entero con LVM": Durante la instalación,
Debian ofrece una opción para utilizar LVM automáticamente. Esto configurará LVM
sobre el disco seleccionado.

Creación de Volúmenes Físicos y Grupos de Volúmenes: El instalador de Debian
convierte las particiones seleccionadas en volúmenes físicos y las agrupa en un
volumen de grupo.

Creación de Volúmenes Lógicos: A partir del grupo de volúmenes, el instalador
crea volúmenes lógicos para las diferentes particiones que necesitas, como
/ (raíz), /home y swap.

Asignación de Sistemas de Archivos: Finalmente, se asignan sistemas de archivos
a los volúmenes lógicos creados, permitiendo que el sistema operativo y los
datos sean almacenados en ellos.

Consideraciones
===============

Complejidad: LVM añade una capa de complejidad sobre el particionado
tradicional. Aunque ofrece muchas ventajas, puede ser más complicado de
administrar para usuarios menos experimentados.

Rendimiento: En la mayoría de los casos, el impacto en el rendimiento es mínimo,
pero en entornos con alta carga de E/S, LVM podría tener un ligero impacto.

Fuentes
=======

-ChatGPT
-https://wiki.debian.org/es/LVM

==========================
Minimizar ventana en Gnome
==========================

super + h

Fuente
======

https://hijosdeinit.gitlab.io/howto_botones_maximizar_minimizar_Debian_10_buster/

====================================
Dirección MAC (Media Access Control)
====================================

Una dirección MAC (Media Access Control) es un identificador único asignado a
cada interfaz de red de un dispositivo. Esta dirección es utilizada para la
comunicación dentro de una red local y es esencialmente la "dirección física"
del dispositivo en la red.

Características de la Dirección MAC:

Formato: La dirección MAC se representa generalmente en notación hexadecimal y
consta de 48 bits, divididos en seis grupos de dos dígitos separados por dos
puntos o guiones. Por ejemplo:

00:1A:2B:3C:4D:5E

Unicidad: Cada dispositivo de red tiene una dirección MAC única. Esta dirección
es asignada por el fabricante del dispositivo y es, en teoría, única en todo el
mundo.

Inmutabilidad: La dirección MAC está grabada en el hardware de la tarjeta de red
(NIC) del dispositivo y no cambia, a menos que se realice un spoofing o cambio
deliberado mediante software.

¿Cómo se usa la Dirección MAC?

Identificación: En una red local (LAN), los dispositivos se identifican y se
comunican entre sí usando sus direcciones MAC.

Seguridad: Algunas redes utilizan filtros de dirección MAC para permitir o
denegar el acceso a la red a dispositivos específicos.

Comunicación: La dirección MAC es utilizada por el protocolo Ethernet para
asegurar que los paquetes de datos lleguen a la interfaz de red correcta en la
red local.

Ver la Dirección MAC en un Dispositivo:

Para ver la dirección MAC de tu dispositivo, puedes usar comandos específicos
dependiendo del sistema operativo:

$ ip link show

Ejemplo:

3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:1a:2b:3c:4d:5e brd ff:ff:ff:ff:ff:ff
En este ejemplo, 00:1a:2b:3c:4d:5e es la dirección MAC de la interfaz wlan0.

Fuente
======

ChatGPT

====================================================
Instalar el cliente de correo thunderbird de mozilla
====================================================

Instalar el paquete thunderbird y sus traducciones al español.

$ sudo apt install thunderbird thunderbird-l10n-es-es

==============
Virtualización
==============

La virtualización permite ejecutar varios sistemas operativos (SO) o
aplicaciones simultáneamente en un único hardware físico. Se crea una capa de
abstracción entre el hardware y el software, conformada por máquinas virtuales
(VM) que actúan como ordenadores independientes, lo que permite activar una
versión virtual (en lugar de física) de un recurso, como un servidor, una
unidad de almacenamiento, una red, o incluso un sistema operativo completo.

Elementos de la virtualización
==============================

Hipervisor: El software que gestiona la virtualización, actúa como intermediario
entre el hardware y las VM.

Máquina Virtual: Es un entorno que replica el comportamiento de un oprdenador
físico. Puede ejecutar un SO y aplicaciones como si fuera un sistema
independiente.

Anfitrión (host): Es el hardware físico donde se ejecutan las VM.

Huesped (Guest): El sistema operativo o aplicación que se ejecuta dentro de una
VM.

Beneficios de la virtualización
===============================

Ahorro de recursos: Permite ejecutar múltiples SO y aplicaciones en un solo
servidor físico, reduciendo el consumo de energía y espacio físico.

Mejor uso del hardware: Optimiza el uso de los recursos del hardware, ya que las
VM pueden compartir el mismo hardware.

Flexibilidad y escalabilidad: Permite agregar o eliminar máquinas virtuales
fácilmente según las necesidades, sin necesidad de hardware adicional.

Mayor seguridad: Las VM pueden aislarse unas de otras, lo que aumenta la
seguridad al limitar el impacto de una falla o ataque en una VM.

Facilidad de administración: Ofrece herramientas para administrar las VM de
forma centralizada, facilitando la instalación, actualización y mantenimiento de
los sistemas.

Pruebas y desarrollo: Permiten crear y ejecutar diferentes entornos de prueba de
forma rápida y eficiente.

Tipos de Virtualización
=======================

Virtualización Completa (HVM): Procura replicar todos los componentes de un
equipo físico. Requiere que los CPU físicos tengan soporte específico para
virtualización (AMD- Vo Intel VT-x en la plataforma x86). Tiene la ventaja del
soporte a sistemas operativos que no están modificados para virtualización, con
la desventaja de un menor desempeño.

Paravirtualización (PV): Procura optimizar el desempeño de la virtualización al
incorporar modificaciones en el sistema operativo huesped que le permitan
cooperar estrechamente con el hipervisor. Se beneficia de la presencia de
soporte específico para virtualización en los CPU físicos, el cual no es un
requerimiento sin embargo.

Esquemas híbridos: HVM con controladores PV; PVHVM, donde Usa HVM con
paravirtualización de controladores e interfaces de bajo nivel; PVH, núcleo PV
completo dentro de un contenedor HVM, sin dispositivos emulados.

Herramientas de virtualización libres y de código abierto
=========================================================
KVM (Kernel-based Virtual Machine): Un hipervisor de tipo 2 (hospedado)
integrado en el kernel de Linux, ofreciendo un alto rendimiento y eficiencia.
Es popular para aplicaciones de servidor.

Xen: Hipervisor de tipo 1 (nativo o bare-metal) el cual se instala directamente
sobre el hardware físico de un servidor al que entonces controla completamente,
sin necesidad de un sistema operativo subyacente.

QEMU (Quick Emulator): Un emulador de hardware que puede proporcionar
dispositivos virtuales para diferentes arquitecturas. Es popular para pruebas y
desarrollo de software en donde se utilicen esquemas de virtualización completa.

Proxmox VE: Plataforma de virtualización de código abierto, que integra varios
componentes para ofrecer una solución completa de virtualización, no es un
virtualizador en sí mismo. Se basa en KVM para la virtualización y ofrece
herramientas adicionales para la administración de máquinas virtuales,
almacenamiento, redes y gestión de contenedores.

Arquitectura en capas
=====================
La arquitectura en capas es un patrón de diseño que organiza un sistema de
software en diferentes capas, cada una con un conjunto específico de
responsabilidades. En un despliegue de aplicación web, esto significa dividir la
lógica de funcionamiento en diferentes niveles que interactúan entre sí.

En esencia, una arquitectura en capas divide un despliegue de aplicación web en
capas susceptibles de escalamiento horizontal, donde cada una se comunica con la
inmediatamente superior e inferior.

El hospedaje de las capas puede o no estar desglosado en varios servidores. En
el caso del despliegue del sistema ERP kavac el hospedaje de las capas se puede
organizar en tres niveles:

Capa Base de datos: Es la inferior, debe estar separada en una maquina virtual y
su comunicación únicamente es con la capa aplicación.

Capa aplicación y web: Es la capa intermedia, y en este caso particular reposa
el código de aplicación con todas sus dependencias y configuraciones, así como
el servidor web Nginx donde se integran los componentes estáticos y dinámicos de
la aplicación, al tiempo que se comunica a la siguiente capa que es el proxy y
permite que los usuarios pueda acceder a la funcionalidades de la aplicación.

Сара proxy: Funciona como intermediario entre el cliente y la aplicación, es
quien se encarga de aceptar y procesar las peticiones confiables a la
aplicación. Está capa conforma una fachada del sistema en donde implementa
terminación ssl, redirecciones, protecciones, gestión de flujo entre otras
tareas.

Ventajas
========

Mayor modularidad: Las capas están débilmente acopladas, lo que significa que se
pueden modificar y actualizar de forma independiente.

Reutilización del código: Las capas se pueden incorporar a otros proyectos o
sistemas, con solo agregar las configuraciones correspondientes.

Facilidad en la detección de fallas: Se puede detectar de forma mas rápida y
eficiente en cuál capa se esta presentando una falla, cuando hay una
configuración correcta de las bitácoras (logs).

Escalabilidad: Se pueden escalar las capas de forma independiente, lo que
facilita el crecimiento del despliegue, agregar o eliminar capas. El nivel de
escalamiento horizontal puede adaptarse a la evolución de la concurrencia de uso
del sistema.

Fuente
======

Curso en Línea técnico de despliegue del sistema ERP KAVAC

=======
systemd
=======

Es un sistema de inicio y gestor de servicios ampliamente utilizado en sistemas
operativos Linux.

Razones para Configurar en systemd:

• Gestión de Servicios: systemd proporciona una gestión eficiente de servicios,
permitiendo iniciar, detener, reiniciar y monitorear servicios de manera sencilla.

• Autostart: Configurar los servicios en systemd asegura que se inicien
automáticamente al arrancar el sistema, garantizando que los workers y
websockets estén siempre activos sin intervención manual.

• Supervisión y Recuperación: systemd puede supervisar los servicios y
reiniciarlos automáticamente en caso de fallos, mejorando la estabilidad y
disponibilidad de la aplicación.

• Registro de Logs: systemd integra el registro de logs de los servicios,
facilitando la identificación y solución de problemas.

• Seguridad y Aislamiento: systemd ofrece características avanzadas de seguridad
y aislamiento, como el uso de groups y namespaces, para limitar los recursos y
el acceso de los servicios.

• Configuración Centralizada: Centraliza la configuración y gestión de todos los
servicios del sistema, simplificando la administración y el mantenimiento.

Worker
======

Workers son procesos encargados de manejar tareas en segundo plano que pueden
ser ejecutadas de manera asíncrona, sin bloquear la ejecución principal de una
aplicación. Son particularmente útiles para realizar trabajos que pueden ser
intensivos en recursos o que requieren tiempos de ejecución más prolongados,
como procesamiento de datos, envío de correos electrónicos, generación de
informes, entre otros.

Importancia de Configurar Workers en systemd:

• Fiabilidad y Disponibilidad: Configurar los workers en systemd asegura que se
reinicien automáticamente en caso de fallos, mejorando la fiabilidad y
disponibilidad del servicio.

• Gestión de Recursos: systemd permite limitar el uso de recursos (CPU, memoria)
para cada servicio, evitando que los workers consuman más de lo necesario y
afecten el rendimiento del sistema.

• Supervisión Continua: systemd monitorea constantemente los servicios,
permitiendo detectar y solucionar problemas rápidamente.

• Facilidad de Administración: Permite gestionar los workers con comandos simples
(start, stop, restart, status), facilitando su administración.

• Automatización del Inicio: Configurando los workers en systemd, se asegura que
se inicien automáticamente al arrancar el sistema, garantizando que estén
siempre operativos sin intervención manual.

En la aplicación kavac los worker se manejan como un servicio, en el que las
colas están divididas en dos, colas largas (bulk) que puede tardar entre 1
minuto y cuatro horas o más y colas cortas (default) que se ejecutan en menos de
un minuto.

Para su configuración puedes guiarte en el manual en la sección Configurar el
procesamiento de colas y notificaciones.

Websockets
==========

Websockets es una tecnología que permite la comunicación bidireccional en tiempo
real entre un cliente (como un navegador web) y un servidor. A diferencia de las
conexiones HTTP tradicionales, que son unidireccionales y requieren que el
cliente inicie cada solicitud, los websockets permiten que el servidor envíe
datos al cliente sin que el cliente los solicite explícitamente.

Configurar servicios de websockets en systemd es fundamental para asegurar que
las aplicaciones web que requieren comunicación en tiempo real sean confiables,
eficientes y fáciles de administrar. systemd proporciona herramientas poderosas
para gestionar, monitorear y asegurar estos servicios, garantizando su
disponibilidad y rendimiento óptimo en todo momento.

Características principales de WebSocket
========================================

Bidireccionalidad: Tanto el cliente como el servidor pueden enviar y recibir
datos en cualquier momento, a diferencia de HTTP, donde el cliente debe iniciar
todas las solicitudes.

Persistencia: La conexión se mantiene abierta hasta que se cierra
explícitamente, lo que lo hace ideal para aplicaciones que requieren
comunicación continua.

Bajo consumo de recursos: Al evitar la sobrecarga de abrir y cerrar conexiones
repetidamente, WebSocket es más eficiente que las solicitudes HTTP
tradicionales, especialmente para grandes volúmenes de datos en tiempo real.

Tiempo real: WebSocket es perfecto para aplicaciones que necesitan
actualizaciones instantáneas, como chats, videojuegos, paneles de control en
vivo, o aplicaciones financieras.

Compatibilidad: Está soportado por la mayoría de los navegadores modernos.

Cómo funciona WebSocket:

Establecer la conexión:

El cliente (generalmente un navegador) inicia la conexión utilizando el
protocolo HTTP con un "handshake" especial.

Si el servidor acepta, se cambia al protocolo WebSocket.

El protocolo usa la misma infraestructura que HTTP (puerto 80 para WebSocket,
443 para WebSocket seguro).

Ejemplo completo de un archivo index.html
=========================================

Este ejemplo implementa y prueba una conexión WebSocket. Este archivo permite al
cliente conectarse a un servidor WebSocket, enviar mensajes y recibir
respuestas.

Archivo completo: index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebSocket Example</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .log {
      border: 1px solid #ddd;
      padding: 10px;
      height: 200px;
      overflow-y: auto;
      background: #f9f9f9;
    }
    .log p {
      margin: 5px 0;
    }
    input, button {
      padding: 10px;
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <h1>WebSocket Client</h1>
  <div>
    <label for="messageInput">Message:</label>
    <input type="text" id="messageInput" placeholder="Type a message">
    <button id="sendButton">Send</button>
  </div>
  <h2>Logs</h2>
  <div class="log" id="log"></div>

  <script>
    // Create WebSocket connection
    const socket = new WebSocket('ws://localhost:8080'); // Replace with your server URL if needed

    // DOM elements
    const logDiv = document.getElementById('log');
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');

    // Log messages to the logDiv
    function logMessage(message, type = 'info') {
      const logEntry = document.createElement('p');
      logEntry.textContent = `${type.toUpperCase()}: ${message}`;
      if (type === 'error') logEntry.style.color = 'red';
      logDiv.appendChild(logEntry);
      logDiv.scrollTop = logDiv.scrollHeight; // Auto-scroll to the latest message
    }

    // Connection opened
    socket.addEventListener('open', () => {
      logMessage('Connected to WebSocket server.');
    });

    // Listen for messages from the server
    socket.addEventListener('message', (event) => {
      logMessage(`Received: ${event.data}`);
    });

    // Handle errors
    socket.addEventListener('error', (error) => {
      logMessage('WebSocket error', 'error');
      console.error('WebSocket error:', error);
    });

    // Handle connection close
    socket.addEventListener('close', () => {
      logMessage('WebSocket connection closed.', 'error');
    });

    // Send message to the server
    sendButton.addEventListener('click', () => {
      const message = messageInput.value;
      if (message.trim() !== '') {
        socket.send(message);
        logMessage(`Sent: ${message}`);
        messageInput.value = ''; // Clear input field
      }
    });
  </script>
</body>
</html>

Servidor WebSocket:

Antes de probar este archivo, asegúrate de tener un servidor WebSocket en
ejecución.

Aquí hay un ejemplo básico en Node.js utilizando la biblioteca ws:

-----

const WebSocket = require('ws');

const server = new WebSocket.Server({ port: 8080 });

server.on('connection', (ws) => {
  console.log('Client connected.');

  ws.on('message', (message) => {
    console.log(`Received: ${message}`);
    ws.send(`Echo: ${message}`); // Echo message back to the client
  });

  ws.on('close', () => {
    console.log('Client disconnected.');
  });
});

-----

Ejecuta el servidor:

Guarda el código del servidor en un archivo, por ejemplo, server.js.

Ejecuta el servidor usando Node.js:

Probado con node v20.11.0 y npm v10.2.4

$ npm install ws

$ node server.js

Abre el archivo index.html en tu navegador.

Escribe un mensaje en el cuadro de texto y presiona "Send".

El servidor devolverá el mensaje con un prefijo Echo:.

Observa los registros:

Los mensajes enviados y recibidos se mostrarán en el área de logs del navegador.

Fuentes
======

Curso en Línea técnico de despliegue del sistema ERP KAVAC

ChatGPT

Proxy
=====

Un Proxy es un servidor intermedio que actúa como un puente entre un cliente
(como un navegador web) y otro servidor (como un servidor web). Su función
principal es enviar y recibir solicitudes en nombre del cliente, lo que puede
ofrecer varias ventajas según cómo esté configurado.

Funciones y Usos de un Proxy:

Anonimato y Privacidad: Los proxies pueden ocultar la dirección IP del cliente,
haciendo que las solicitudes parezcan provenir del proxy en lugar del cliente.
Esto ayuda a proteger la identidad y la ubicación del usuario.

Filtrado de Contenidos: Un proxy puede bloquear el acceso a ciertos sitios web o
contenido no deseado. Esto es común en entornos corporativos o escolares, donde
se quieren imponer políticas de uso de Internet.

Mejora del Rendimiento (Caching): Los proxies pueden almacenar en caché
(cachear) respuestas de servidores web. Esto significa que si varios usuarios
solicitan el mismo contenido, el proxy puede servir la copia cacheada sin tener
que solicitarla nuevamente al servidor de origen, mejorando la velocidad de
acceso y reduciendo el ancho de banda.

Acceso a Recursos Restringidos: Algunas veces, los usuarios emplean proxies para
acceder a contenido que está bloqueado en su región geográfica. El proxy, al
estar en una ubicación diferente, puede tener acceso al contenido y luego
enviárselo al usuario.

Seguridad: Los proxies pueden actuar como un cortafuegos, analizando y filtrando
el tráfico que pasa a través de ellos para detectar amenazas potenciales.

Control de Uso de Internet: En redes corporativas, los proxies pueden usarse
para monitorear y registrar las actividades en Internet de los usuarios,
ayudando a las organizaciones a asegurarse de que se cumplan sus políticas de
uso.

Tipos de Proxies:

Proxy HTTP: Maneja solicitudes y respuestas HTTP, adecuado para navegar por la
web.

Proxy HTTPS: Similar al proxy HTTP, pero maneja tráfico HTTPS, lo que permite el
acceso seguro a sitios web.

Proxy Transparente: No requiere ninguna configuración en el cliente. El cliente
ni siquiera sabe que su tráfico está pasando por un proxy.

Proxy Inverso: En lugar de actuar como intermediario para los clientes, un proxy
inverso actúa en nombre de uno o más servidores. Es comúnmente utilizado para
distribuir cargas de tráfico, asegurar servidores, y actuar como punto de
entrada para servicios web.

En resumen, un proxy es una herramienta versátil que puede mejorar la seguridad,
privacidad, rendimiento y control en una red informática.

Fuente
======

ChatGPT

Importancia de un Proxy inverso
===============================

Utilizar un proxy inverso como Nginx en la puesta en producción de una
aplicación web que maneja datos sensibles es crucial para mejorar la seguridad,
rendimiento y escalabilidad de la aplicación. Un proxy no solo protege los
servidores backend de ataques y sobrecargas, sino que también optimiza la
entrega de contenido y facilita la administración de la infraestructura.
Implementar un proxy inverso correctamente configurado es una de las mejores
prácticas esenciales para asegurar la integridad y disponibilidad de datos en
una aplicación web.

Tomando en cuenta que el kavac es un aplicación que guarda datos confidenciales
de la institución o empresa es necesario que en el despliegue se tome en cuenta
un proxy inverso.

Nginx como servidor
===================

Nginx se utiliza como proxy inverso en la aplicación KAVAC para manejar diversas
responsabilidades críticas que optimizan la seguridad, el rendimiento y la
escalabilidad de la aplicación.

• Balanceo de Carga: Nginx distribuye las solicitudes entrantes entre varios
servidores backend de KAVAC, asegurando que ninguna máquina se sobrecargue y que
los recursos se utilicen de manera eficiente.

• Escalabilidad Horizontal: Permite añadir o quitar servidores backend
fácilmente sin interrumpir el servicio, lo que facilita la escalabilidad de la
aplicación.

• Terminación SSL/TLS: Nginx maneja la terminación de SSL/TLS, asegurando que
todo el tráfico entre los usuarios y el servidor esté encriptado y protegido
contra ataques de intermediarios.

• Oculta la Infraestructura: Al actuar como intermediario, Nginx oculta la
infraestructura del backend, haciendo más difícil para los atacantes dirigirse
a los servidores de la aplicación.

• Caché de Contenido Estático: Nginx puede almacenar en caché contenido estático
como imágenes, scripts y hojas de estilo, reduciendo la carga en los servidores
backend y mejorando los tiempos de respuesta para los usuarios.

• Compresión de Datos: Nginx puede comprimir respuestas antes de enviarlas al
cliente, lo que reduce el uso del ancho de banda y acelera la entrega de
contenido.

• Persistencia de Sesión: Asegura que las solicitudes de un mismo usuario se
dirijan al mismo servidor backend, lo cual es esencial para mantener la
consistencia en las sesiones de usuario.

• Manejo de Conexiones WebSocket: Facilita la gestión de conexiones WebSocket
para aplicaciones en tiempo real, manteniendo las conexiones abiertas y
permitiendo la comunicación bidireccional.

• Logs Centralizados: Nginx registra todas las solicitudes y respuestas,
proporcionando un único punto para monitorear el tráfico y diagnosticar problemas.

======
Fuente
======

Curso en Línea técnico de despliegue del sistema ERP KAVAC


SSL (Secure Sockets Layer) y TLS (Transport Layer Security)

Son protocolos criptográficos diseñados para proporcionar seguridad en las
comunicaciones a través de una red, como Internet. Ambos protocolos son
fundamentales para garantizar que los datos transmitidos entre un cliente
(por ejemplo, un navegador web) y un servidor (por ejemplo, un sitio web) estén
protegidos contra la interceptación y manipulación por parte de terceros.

SSL (Secure Sockets Layer)
==========================

SSL es el protocolo original desarrollado por Netscape en la década de 1990 para
asegurar las comunicaciones en la web. Fue ampliamente utilizado para proteger
las conexiones HTTPS, cifrando los datos intercambiados entre el navegador y el
servidor.

Versiones: SSL pasó por varias versiones (SSL 1.0, 2.0, 3.0). Sin embargo,
debido a varias vulnerabilidades descubiertas en SSL 2.0 y 3.0, estos protocolos
ya no se consideran seguros y han sido reemplazados por TLS.

Estado Actual: SSL ha sido oficialmente deprecado, y su uso está desaconsejado
en favor de TLS.

TLS (Transport Layer Security)
==============================

TLS es la evolución de SSL. Es un protocolo más seguro y eficiente, que se
desarrolló para abordar las vulnerabilidades de SSL. TLS proporciona
autenticación, confidencialidad y la integridad de los datos transmitidos entre
aplicaciones y servidores.

Versiones: TLS tiene varias versiones: TLS 1.0, 1.1, 1.2, y 1.3 (la versión más
reciente y segura). Cada versión sucesiva ha mejorado la seguridad y el
rendimiento.

Características Clave:

Cifrado: TLS utiliza criptografía para cifrar los datos transmitidos, asegurando
que cualquier información intercambiada entre el cliente y el servidor sea
ilegible para los atacantes.

Autenticación: TLS autentica la identidad del servidor (y opcionalmente del
cliente) mediante certificados digitales, asegurando que el cliente esté
comunicándose con el servidor correcto.

Integridad de los Datos: TLS utiliza mecanismos de hashing para asegurar que los
datos no se modifiquen durante la transmisión.

Estado Actual: TLS es el estándar actual para la seguridad en la web y otros
servicios de red. TLS 1.2 y 1.3 son las versiones más recomendadas, mientras que
TLS 1.0 y 1.1 también están siendo gradualmente eliminadas debido a sus
vulnerabilidades.

Relación entre SSL y TLS

Compatibilidad: TLS fue diseñado para ser compatible con SSL, de modo que los
sistemas que implementan TLS puedan funcionar con sistemas que usan SSL, aunque
con menor seguridad.

Terminología: A pesar de que TLS ha reemplazado a SSL, el término "SSL" todavía
se usa coloquialmente para referirse a la tecnología subyacente de cifrado y
autenticación, incluso cuando en realidad se utiliza TLS.

Importancia

HTTPS: Uno de los usos más comunes de SSL/TLS es para habilitar HTTPS, que es
HTTP sobre SSL/TLS. HTTPS asegura que la navegación web sea segura.

Seguridad en la Red: SSL/TLS se utiliza no solo en navegadores, sino también en
correos electrónicos, VPNs, VoIP, y muchas otras aplicaciones que requieren una
comunicación segura.

En resumen, SSL fue el precursor de TLS, pero debido a problemas de seguridad,
TLS es ahora el estándar recomendado para asegurar las comunicaciones en la red.

Fuente
======

ChatGPT

Convertir el archivo de video a Base64
======================================

Para convertir un archivo de video a Base64, puedes usar el comando base64.
Supongamos que tu archivo de video se llama video.mp4.

$ base64 video.mp4 > video_base64.txt

Esto guardará la cadena Base64 en un archivo llamado video_base64.txt.

2. Decodificar la cadena Base64 para obtener el video original

Para decodificar la cadena Base64 y obtener de nuevo el archivo de video, puedes
usar el siguiente comando:

$ base64 -d video_base64.txt > video_decoded.mp4

Esto generará un archivo video_decoded.mp4 que será una copia exacta del archivo
de video original.

Fuente
======

ChatGPT

================
¿Qué es la UEFI?
================

La UEFI o Interfaz de Firmware Extensible Unificada se considera el sustituto
del firmware de la BIOS. Viene con más características y funcionalidades que
están limitadas en la BIOS, y está disponible en las placas base actuales y en
los PCs modernos.

Aunque se considera un sustituto de la BIOS, la UEFI funciona de forma diferente
y tiene un concepto opuesto a la BIOS. La UEFI almacena toda la información
sobre la inicialización y el arranque en el archivo .efi, que se almacena en la
partición ESP (Partición del Sistema EFI). y en la ESP se almacenan también los
programas del gestor de arranque del sistema operativo instalado en el
ordenador.

La UEFI utiliza GPT para almacenar toda la información sobre las particiones, en
lugar de MBR.

A continuación una explicación sencilla de cómo arranca el sistema operativo en
UEFI.

UEFI > GPT/ESP > Kernel > Operating System

A continuación se muestran algunas características notables de la UEFI que no
están disponibles en la BIOS tradicional:

-Arranque más rápido

-Maneja más de 2TB de disco (lo que es un gran problema en el entorno actual)

-Soporta más de 4 particiones con tabla de particiones GUID

-Soporta el arranque seguro

-Soporta dispositivos de firmware modernos de 64 bits

-Tiene una interfaz gráfica de usuario sencilla

Fuente
======

https://howtoforge.es/activar-la-compatibilidad-con-uefi-en-la-virtualizacion-kvm/

========================
Sistema de partición EFI
========================

La partición del sistema EFI (también llamada, por sus siglas en inglés, ESP) es
una partición independiente del sistema operativo, que actúa como el lugar de
almacenamiento para los cargadores de arranque EFI, las aplicaciones y los
controladores que serán lanzados por el firmware UEFI. Es obligatoria para el
arranque UEFI.

Fuente
======

https://wiki.archlinux.org/title/EFI_system_partition_(Espa%C3%B1ol)

==============================
Instalar OpenShot Video Editor
==============================

$ sudo apt install openshot-qt

=============================================================
Convertir el ancho y el alto de una pantalla en cm a pulgadas
=============================================================

X = Ancho en pulgadas
Y = Alto en pulgadas

X = Xcm / 2.54cm
Y = Ycm / 2.54cm

1- Elevar ambos al cuadrado

X = X²
Y = Y²

2- Sumamos los resultados de los cuadrados:

X + Y

3- Aplicar la raíz cuadrada a ese número para obtener la diagonal

Z = Raiz de suma de X + Y

R = √z

-----

Ejemplo:

X = 52cm / 2,54cm
Y = 29.5cm / 2,54cm

Resultado

X = 20,47
Y = 11,61

Elevamos ambos al cuadrado

X = 419,0209
Y = 134,7921

Sumamos los resultados de los cuadrados

X+Y = 553,813

Sacar la raíz del resultado

R = √553,813

R = 23,53" pulgadas

Fuente
======

ChatGPT

-----

Calculadora del Tamaño del Monitor en Pulgadas

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calcular Tamaño de Monitor</title>
</head>
<body>
    <h1>Calculadora del Tamaño del Monitor en Pulgadas</h1>
    <form id="monitorForm">
        <label for="widthCm">Ancho (cm):</label>
        <input type="text" id="widthCm" name="widthCm" required><br><br>
        <label for="heightCm">Alto (cm):</label>
        <input type="text" id="heightCm" name="heightCm" required><br><br>
        <button type="submit">Calcular</button>
    </form>
    <p id="result"></p>

    <script>
        document.getElementById('monitorForm').addEventListener('submit', function(event) {
            event.preventDefault();

            // Obtener los valores ingresados por el usuario y reemplazar comas por puntos
            let widthCm = document.getElementById('widthCm').value.replace(',', '.');
            let heightCm = document.getElementById('heightCm').value.replace(',', '.');

            // Convertir los valores a números de punto flotante
            widthCm = parseFloat(widthCm);
            heightCm = parseFloat(heightCm);

            // Verificar si los valores son números válidos
            if (isNaN(widthCm) || isNaN(heightCm)) {
                document.getElementById('result').textContent = "Por favor, ingrese valores numéricos válidos.";
                return;
            }

            // Convertir las dimensiones de cm a pulgadas
            const widthInches = widthCm / 2.54;
            const heightInches = heightCm / 2.54;

            // Elevar ambos valores al cuadrado
            const widthSquared = Math.pow(widthInches, 2);
            const heightSquared = Math.pow(heightInches, 2);

            // Sumar los resultados de los cuadrados
            const sumOfSquares = widthSquared + heightSquared;

            // Aplicar la raíz cuadrada a la suma de los cuadrados
            const diagonalInches = Math.sqrt(sumOfSquares);

            // Mostrar el resultado al usuario
            document.getElementById('result').textContent = `El tamaño del monitor es: ${diagonalInches.toFixed(2)} pulgadas`;
        });
    </script>
</body>
</html>

====================================================
Dividir un archivo en partes y luego unir las partes
====================================================

1. Usa el comando split para dividir el archivo .mp4 en partes más pequeñas:

$ split -b 100M archivo_grande.mp4 parte_

-b 100M: Indica el tamaño de cada parte (en este caso, 100 MB). Puedes ajustar
el tamaño a lo que necesites.

archivo_grande.mp4: Es el archivo de video que quieres dividir.

parte_: Prefijo para los archivos generados. El resultado serán archivos con
nombres como parte_aa, parte_ab, etc.

2. Unir las partes de nuevo:

Una vez que las partes hayan sido transferidas o almacenadas, puedes
recombinarlas usando el comando cat:

$ cat parte_* > video_reconstruido.mp4

Esto unirá todas las partes y generará el archivo original.

3. Verificación (opcional):

Puedes verificar que el archivo reconstruido es idéntico al original usando el
comando md5sum antes y después de dividir:

Obtener el hash del archivo original:

$ md5sum archivo_grande.mp4

Obtener el hash del archivo reconstruido:

$ md5sum video_reconstruido.mp4

Si los hashes coinciden, el archivo fue reconstruido correctamente.

Este método es simple y te permite dividir y unir archivos sin perder calidad en
el video.

Nota:

El método de dividir y unir archivos con split y cat funciona para cualquier
tipo de archivo, incluyendo documentos como un archivo .odt (o cualquier otro
formato, como .pdf, .zip, etc.).

Fuente
======

ChatGPT

===========================================
Cortar un video MP4/MKV en dos o más partes
===========================================

Es posible cortar un video MP4 en dos partes en Linux Debian y obtener dos
archivos MP4 funcionales. Puedes hacerlo utilizando la herramienta ffmpeg, que
es una utilidad de línea de comandos muy potente para manipular videos y audios.

Pasos para cortar un video MP4 en dos partes:

Instalar ffmpeg (si no lo tienes instalado):

$ sudo apt update

$ sudo apt install ffmpeg

Cortar el video:

Supongamos que tienes un video llamado video.mp4 y quieres cortarlo en dos
partes en el minuto 5 (300 segundos).

Primera parte (desde el inicio hasta el minuto 5):

$ ffmpeg -i video.mp4 -t 300 -c copy parte1.mp4

Aquí, -t 300 indica que quieres cortar los primeros 300 segundos (5 minutos) del
video. -c copy se utiliza para copiar los streams de video y audio sin
re-codificarlos, lo que hace que el proceso sea rápido y sin pérdida de calidad.

Segunda parte (desde el minuto 5 hasta el final):

$ ffmpeg -i video.mp4 -ss 300 -c copy parte2.mp4

Aquí, -ss 300 indica que quieres empezar a cortar desde el segundo 300
(5 minutos) hasta el final del video.

Explicación de los parámetros:

-i video.mp4: Especifica el archivo de entrada.

-t 300: Corta el video hasta el segundo 300.

-ss 300: Empieza a cortar desde el segundo 300.

-c copy: Copia los streams de video y audio sin re-codificarlos.

Ejemplo completo:

Si tienes un video de 10 minutos (600 segundos) y quieres cortarlo en dos
partes de 5 minutos cada una:

ffmpeg -i video.mp4 -t 300 -c copy parte1.mp4

ffmpeg -i video.mp4 -ss 300 -c copy parte2.mp4

Esto te dejará con dos archivos MP4 funcionales: parte1.mp4 (los primeros 5
minutos) y parte2.mp4 (los últimos 5 minutos).

Nota: Si el video no tiene puntos clave (keyframes) en el punto de corte, es
posible que ffmpeg tenga que re-codificar el video para hacer el corte exacto.
En ese caso, puedes omitir -c copy y dejar que ffmpeg re-codifique el video,
aunque esto tomará más tiempo y puede resultar en una ligera pérdida de calidad.

$ ffmpeg -i video.mp4 -t 300 parte1.mp4

$ ffmpeg -i video.mp4 -ss 300 parte2.mp4

Con estos comandos, ffmpeg re-codificará el video, asegurando que el corte sea
exacto en el punto especificado.

Unir los videos cortados
========================

Es posible unir parte1.mp4 y parte2.mp4 para recrear el video original. Para
hacerlo, puedes usar ffmpeg nuevamente. Sin embargo, debes asegurarte de que
ambos archivos tengan las mismas características (misma resolución, codec, tasa
de bits, etc.), ya que de lo contrario ffmpeg podría necesitar re-codificar el
video.

Método 1: Usar ffmpeg con un archivo de lista

Este método es simple y no requiere re-codificación si los archivos son
compatibles.

Crea un archivo de texto (por ejemplo, lista.txt) que contenga las rutas de los
archivos que deseas unir. El archivo debe tener el siguiente formato:

file 'parte1.mp4'
file 'parte2.mp4'

Usa ffmpeg para unir los archivos:

$ ffmpeg -f concat -safe 0 -i lista.txt -c copy video_unido.mp4

-f concat: Especifica que estás usando el método de concatenación.

-safe 0: Permite el uso de rutas relativas o absolutas en el archivo de lista.

-i lista.txt: Especifica el archivo de lista que creaste.

-c copy: Copia los streams de video y audio sin re-codificarlos.

El archivo resultante será video_unido.mp4, que es la unión de parte1.mp4 y
parte2.mp4.

Método 2: Usar ffmpeg sin archivo de lista

Si prefieres no crear un archivo de lista, puedes usar el siguiente comando:

$ ffmpeg -i "concat:parte1.mp4|parte2.mp4" -c copy video_unido.mp4

concat:parte1.mp4|parte2.mp4: Especifica los archivos a concatenar.

-c copy: Copia los streams sin re-codificarlos.

Fuente
======

Deepseek

=============================
Convertir un video MP4 a WebM
=============================

1. FFmpeg (Opción profesional)

$ ffmpeg -i entrada.mp4 -c:v libvpx-vp9 -crf 30 -b:v 0 -c:a libopus -f webm salida.webm

Explicación de parámetros:

-c:v libvpx-vp9: Usa el códec VP9 (equivalente a WebP para video).

-crf 30: Calidad (0=mejor, 63=peor; 30 es buen equilibrio).

-b:v 0: Bitrate variable para optimizar tamaño.

-c:a libopus: Códec de audio eficiente (como Opus en WebM).

Si usas el video en una página web, añade también un fallback en MP4 para Safari:

<video controls>
  <source src="video.webm" type="video/webm">
  <source src="video.mp4" type="video/mp4">
</video>

Fuente
======

Deepseek

=============================================
Fuentes tipográficas en Debian y en GNU Linux
=============================================

Algunos tipos de fuentes existentes
===================================

En Linux podemos instalar varios tipos de fuentes. Los tipos de fuentes más
habituales que encontraremos son los siguientes:

Fuentes TrueType (ttf): Son las más habituales y se pueden utilizar en Linux, en
Windows y en Mac OS. Las reconocerán fácilmente porque cuando las descarguen
verán tienen el formato ttf.

Este tipo de de formato de fuente fue originariamente creado por Apple, y a
posteriori Microsoft adquirió una licencia de uso. Esto ha hecho que en la
actualidad las fuentes ttf sean ampliamente usadas en Microsoft Windows.

Fuentes PostScript tipo 1 (pbf + pfm): Las fuentes Postscript fueron
desarrolladas por Adobe para utilizarse en impresoras PostScipt.

Al igual que las TrueType y las OpenType, son escalables a prácticamente
cualquier tamaño y se utilizan mayoritariamente para realizar impresiones de
alta calidad, como por ejemplo revistas y libros, por ser fuentes detalladas,
suaves y de alta calidad. Por lo tanto este tipo de fuentes es ampliamente usada
por los diseñadores gráficos.

Cada fuente se almacena en 2 archivos. El primero de ellos es con la extensión
.pfb y el segundo con la extensión .pfm.

Fuentes OpenType (otf): Formato de tipografía basado en las fuentes TrueType.

Las fuentes OpenType han sido creadas por Microsoft y Adobe de forma conjunta
para reemplazar los formatos TrueType y PostScript.

Este tipo de fuentes son una evolución del formato de fuentes TrueType y
Postscript, y las reconocerán fácilmente porque cuando las descarguen verán que
tienen el formato otf.

Procedimientos para instalar fuentes en Linux
=============================================

Los distintos métodos que podemos usar en GNU/Linux para instalar fuentes se
detallan a continuación.

Instalar fuentes de los repositorios de nuestra distribución

En los repositorios de nuestra distribución tenemos muchos paquetes que si los
instalamos nos ofrecerán fuentes tipográficas adicionales.

La totalidad de paquetes relacionados con fuentes tipográficas de Debian se
pueden consultar en los siguientes enlaces:

Debian Estable
https://packages.debian.org/stable/fonts/

Debian Testing
https://packages.debian.org/testing/fonts/

Debian Sid
https://packages.debian.org/sid/fonts/

Algunos de los paquetes presentes en una distribución Linux que considero útiles
instalar son los siguientes:

Instalar las fuentes de Microsoft
=================================

En el caso que queramos o tengamos necesidad de instalar algunas de las fuentes
de Microsoft, tan solo tenemos que abrir una terminal y ejecutar el siguiente comando:

$ sudo apt-get install ttf-mscorefonts-installer

Una vez instalado el paquete ttf-mscorefonts-installer pasaremos a disponer de
las siguientes fuentes:

Andale Mono, Arial Black, Arial, Comic Sans MS, Courier New, Georgia, Impact,
Times New Roman, Trebuchet, Verdana, Webdings.

La totalidad de fuentes mencionadas son fuentes privativas que se hallan en el
repositorio Contrib de Debian.

Para disponer de variantes libres de las tipografías Times, Arial y Courier, etc
pueden instalar el paquete fonts-liberation ejecutando el siguiente comando en
la terminal:

$ sudo apt-get install fonts-liberation

Luego de instalar nuevas fuentes se debe recargar la lista de fuentes ejecutando
el siguiente comando en la terminal:

$ sudo fc-cache -f -v

Sacar un listado de la totalidad de fuentes instaladas en nuestro equipo
========================================================================

En el caso que precisen sacar un listado de la totalidad de fuentes instaladas,
pueden ejecutar el siguiente comando en la terminal:

$ fc-list

Si lo que quieren es obtener un fichero de texto con la totalidad de fuentes
instaladas pueden ejecutar el siguiente comando en la terminal:

$ fc-list >fuentes_instaladas.txt

Directorio de instalación
=========================

/usr/share/fonts

Fuente
======

https://geekland.eu/instalar-fuentes-en-debian-linux/

========================================
Instalar una fuente manualmente en Linux
========================================

1. Instalar la fuente para todos los usuarios

$ sudo cp tu_fuente.ttf /usr/share/fonts/truetype/

(Si el directorio truetype no existe, puedes crearlo con

$ sudo mkdir -p /usr/share/fonts/truetype

2- Actualiza la caché de fuentes:

$ sudo fc-cache -fv

3- Verifica la instalación:

$ fc-list | grep "Nombre-de-tu-fuente"

Notas adicionales:

-Si no ves la fuente en algunas aplicaciones (como LibreOffice), reinícialas.

-Las fuentes se pueden instalar en varios formatos (.ttf, .otf, .woff, etc.),
pero .ttf y .otf son los más comunes en Linux.

-Si prefieres una interfaz gráfica, algunas distribuciones permiten instalar
fuentes haciendo doble clic en el archivo .ttf y seleccionando "Instalar".

Fuente
======

DeepSeek

============================================================
Reducir el tamaño o bajar el peso de un archivo de video mp4
============================================================

Linux es posible reducir el tamaño de un archivo .mp4 usando herramientas como
FFmpeg. Esta herramienta es muy potente y permite comprimir archivos de video
ajustando la calidad, la resolución, o la tasa de bits.

Ejemplo de uso de FFmpeg para reducir el tamaño de un archivo .mp4:

Instala FFmpeg (si aún no lo tienes):

$ sudo apt-get install ffmpeg

Comprime el archivo .mp4:

$ ffmpeg -i input.mp4 -vcodec libx264 -crf 23 output.mp4

input.mp4: tu archivo original.

-vcodec libx264: especifica el códec de video.

-crf 23: ajusta la calidad. Puedes cambiar este valor; 23 es una buena opción
para compresión estándar. Valores más bajos aumentan la calidad (y el tamaño),
mientras que valores más altos disminuyen la calidad (y el tamaño).

output.mp4: el nombre del archivo comprimido.

Reducción avanzada de archivos MP4 con FFmpeg
=============================================

FFmpeg ofrece múltiples parámetros para optimizar la compresión de videos. Más
allá del CRF (Constant Rate Factor), estos controles permiten ajustar el balance
entre calidad y tamaño:

El parámetro -preset determina la relación entre velocidad de codificación y
eficiencia de compresión. Los valores disponibles son: ultrafast, superfast,
veryfast, faster, fast, medium (predeterminado), slow, slower y veryslow.

Por ejemplo, -preset slower generará archivos más pequeños pero tardará más
tiempo en procesar. La sintaxis sería:

$ ffmpeg -i input.mp4 -vcodec libx264 -crf 23 -preset slower output.mp4.

Para reducir la resolución, puedes combinar el filtro scale con el códec. Por
ejemplo, para convertir a 720p:

$ ffmpeg -i input.mp4 -vf "scale=-1:720" -vcodec libx264 -crf 23 output.mp4

El valor -1 mantiene la relación de aspecto automáticamente. Si necesitas
cambiar el framerate para ahorrar espacio, usa -r 30 para establecer 30 fps.

La compresión de audio también influye en el tamaño final. El parámetro -acodec
aac -b:a 128k configura el códec de audio AAC con bitrate de 128 kbps. Para
videos sin audio, añade -an. Si buscas máxima compresión, considera usar el
códec H.265 (libx265) en lugar de H.264, aunque requiere más potencia de
procesamiento: ffmpeg -i input.mp4 -vcodec libx265 -crf 28 output.mp4 (nota que
el CRF escala diferente en x265).

Fuente
======

ChatGPT

======================================================
Reducir el tamaño de un archivo de wav o pasarlo a mp3
======================================================

Instala FFmpeg (si aún no lo tienes):

$ sudo apt-get install ffmpeg

1. Convertir .wav a un formato comprimido (como MP3):

MP3 es mucho más compacto y adecuado para reducir el tamaño.

$ ffmpeg -i input.wav -acodec libmp3lame -b:a 128k output.mp3

-acodec libmp3lame: Utiliza el códec de audio MP3.

-b:a 128k: Configura la tasa de bits de audio a 128 kbps. Puedes reducir este
valor a 96k o 64k para archivos más pequeños, pero con menor calidad.

2. Reducir la calidad del archivo WAV:

Si necesitas mantener el archivo en formato WAV pero más ligero, puedes reducir
su calidad:

$ ffmpeg -i input.wav -ar 22050 -ac 1 -b:a 128k output.wav

-ar 22050: Reduce la frecuencia de muestreo a 22.05 kHz (en lugar de los
habituales 44.1 kHz).

-ac 1: Cambia el audio a mono (1 canal en lugar de estéreo).

-b:a 128k: Configura la tasa de bits de audio.

3. Convertir a un formato moderno (como AAC):

AAC es más eficiente que MP3 y mantiene mejor calidad con tasas de bits más
bajas.

$ ffmpeg -i input.wav -acodec aac -b:a 128k output.aac

-acodec aac: Utiliza el códec AAC.

-b:a 128k: Configura la tasa de bits. Puedes bajar hasta 96k para mayor
compresión.

4. Comprimir usando Opus (muy eficiente):

Opus es ideal para máxima compresión con buena calidad:

$ ffmpeg -i input.wav -acodec libopus -b:a 96k output.opus

libopus: Usa el códec Opus.

-b:a 96k: Configura la tasa de bits a 96 kbps.

Fuente
======

ChatGPT

================================================
cloudflared para compartir URL local en internet
================================================

1- Instalar cloudflared desde acá: https://github.com/cloudflare/cloudflared/releases

2- Ahora, por ejemplo queremos compartir la url local http://127.0.0.1:5500 con
el mundo, ejecutamos:

$ cloudflared tunnel --url http://127.0.0.1:5500

Esta salida corresponde a la ejecución del comando cloudflared tunnel para crear
un túnel rápido (Quick Tunnel) con Cloudflare, sin necesidad de una cuenta
registrada en Cloudflare.

Se utiliza --url para exponer localmente a http://127.0.0.1:5500. Cloudflare
crea un enlace temporal accesible públicamente:

2024-11-22T14:58:44Z INF +--------------------------------------------------------------------------------------------+
2024-11-22T14:58:44Z INF |  Your quick Tunnel has been created! Visit it at (it may take some time to be reachable):  |
2024-11-22T14:58:44Z INF |  https://vs-fingers-outside-mel.trycloudflare.com                                          |
2024-11-22T14:58:44Z INF +--------------------------------------------------------------------------------------------+

Mensajes informativos:

Cloudflare avisa que este túnel es experimental y sin garantías de tiempo de
actividad, ya que es una función limitada para probar.

Si necesitas un uso en producción, sugiere configurar un túnel nombrado con una
cuenta Cloudflare.

Configuración detectada:

Se menciona que no hay un archivo de configuración (config.yml o config.yaml),
pero esto no impide el funcionamiento del túnel.

El túnel se creó correctamente y está disponible en https://vs-fingers-outside-mel.trycloudflare.com. Sin embargo:

Fuentes
=======

https://www.instagram.com/reel/DBBtDGTiXAF/?igsh=MWRiazV4dHdlNDJ3ag%3D%3D

ChatGPT

==============================
Clúster en Informática General
==============================

Un clúster informático es un conjunto de computadoras o nodos que se agrupan
para funcionar como si fueran un único sistema. Estos se utilizan para:

Alto rendimiento (HPC - High Performance Computing): Resolver problemas
computacionales intensivos mediante la distribución de tareas entre múltiples
nodos.

Alta disponibilidad (HA - High Availability): Garantizar la continuidad del
servicio incluso si uno o más nodos fallan.

Balanceo de carga: Distribuir la carga de trabajo entre varios servidores para
optimizar recursos y mejorar tiempos de respuesta.

Ejemplo práctico: Un clúster de servidores web podría repartir las solicitudes
de los usuarios entre varios servidores para manejar un alto volumen de tráfico.

Fuente
=======

ChatGPT

============================================
¿En un teclado que significa teclas muertas?
============================================

En un teclado, las "teclas muertas" se refieren a teclas que no generan un
carácter por sí solas cuando se presionan, sino que modifican el carácter
generado por la tecla siguiente que se presiona. Esto se utiliza comúnmente
para escribir caracteres acentuados o especiales. Por ejemplo, en algunos
teclados:

La tecla ´ (acento agudo) es una tecla muerta. Si la presionas y luego presionas
la tecla e, el resultado es é.

La tecla ^ (acento circunflejo) es una tecla muerta. Si la presionas y luego
presionas la tecla a, el resultado es â.

Las teclas muertas son útiles para escribir en idiomas que requieren muchos
acentos o marcas diacríticas.

Fuente
======

GitHub Copilot

================================
¿Como documentar bien el código?
================================

Usaremos un formato de comentarios utilizado para documentar código,
específicamente en JSDoc (para JavaScript) o PHPDoc (para PHP). Este estilo de
documentación es común en lenguajes como JavaScript, PHP, TypeScript, y otros,
donde los comentarios se utilizan para describir funciones, métodos, clases y
otros elementos del código.

Características del formato:

Etiquetas estándar:

@class: Describe la clase a la que pertenece el método.

@method: Describe el método o función.

@brief: Descripción resumida, proporciona una explicación corta y directa de lo
que hace el elemento (función, método, clase, etc.).

@param: Describe los parámetros de entrada de la función.

@return: Describe el valor de retorno de la función.

@author: Indica el autor del código.

@license: Especifica la licencia bajo la cual se distribuye el código.

Estructura clara:

-El comentario comienza con una descripción general del método.

-Luego se detallan los parámetros, el valor de retorno y otra información
relevante.

Uso en herramientas de desarrollo:

Este formato es compatible con IDEs (Entornos de Desarrollo Integrados) como
VSCode, PHPStorm, WebStorm, entre otros, que pueden leer estos comentarios y
proporcionar autocompletado, sugerencias y documentación emergente.

Código sin documentar:

class UserController extends Controller
{
    protected function create(array $data)
    {
        $password = $this->generateHash();

        DB::transaction(function () use ($data, $password) {
            $user = User::create([
                'name' => $data['names'],
                'email' => $data['email'],
                'password' => Hash::make($password),
                'role' => $data['role']
            ]);

            $user->profile()->create([
                'names' => $data['names'],
                'surnames' => $data['surnames'],
            ]);

            $user->notify(new UserRegistered($password));
        });
    }
}

Código documentado:

/**
 * @class    UserController
 *
 * @brief    Controlador que gestiona la creación y registro de usuarios en el
 * sistema.
 *
 * @author Ing. Linus Torvalds <ltorvalds@linux.org>
 *
 * Este controlador se encarga de manejar la lógica relacionada con la creación
 * de usuarios, incluyendo la generación de contraseñas, la creación de perfiles
 * asociados y la notificación al usuario registrado.
 *
 * @license <a href='http://derechoinformatico.cenditel.gob.ve/licencia-de-software/'>
 *              LICENCIA DE SOFTWARE CENDITEL
 *          </a>
 */
class UserController extends Controller
{
    /**
     * @method    create
     *
     * @brief    Crea un nuevo usuario en el sistema.
     *
     * Este método genera una contraseña aleatoria, crea un usuario en la base
     * de datos, asocia un perfil al usuario y notifica al usuario su registro
     * mediante un correo electrónico. todas las operaciones se realizan dentro
     * de una transacción para garantizar la integridad de los datos.
     *
     * @param    array $data Arreglo con los datos del usuario a registrar, debe
     * contener:
     * -names: Nombres del usuario.
     * -surnames: Apellidos del usuario.
     * -email: Correo electrónico del usuario.
     * -role: Rol del usuario en el sistema.
     *
     * @return    void
     *
     * @author Ing. Linus Torvalds <ltorvalds@linux.org>
     */
    protected function create(array $data)
    {
        // Genera una contraseña aleatoria segura.
        $password = $this->generateHash();

        // Transacción con la BD para garantizar integridad de las operaciones.
        DB::transaction(function () use ($data, $password) {
            // Crea un nuevo usuario en la base de datos.
            $user = User::create([
                'name' => $data['names'],
                'email' => $data['email'],
                'password' => Hash::make($password),
                'role' => $data['role']
            ]);

            // Crea un perfil asociado al usuario.
            $user->profile()->create([
                'names' => $data['names'],
                'surnames' => $data['surnames'],
            ]);

            // Notifica al usuario su registro mediante un correo electrónico
            // y envía la contraseña en el correo.
            $user->notify(new UserRegistered($password));
        });
    }
}

Beneficios de la documentación:

-Claridad: Cualquier desarrollador que lea el código podrá entender rápidamente
qué hace el método y cómo funciona.

-Mantenibilidad: Facilita la actualización y corrección del código en el futuro.

-Colaboración: Ayuda a los miembros del equipo a trabajar de manera más
eficiente, ya que todos entienden el propósito y funcionamiento del código.

Fuentes
=======

Deepseek

https://jsdoc.app/

======================
Calculadora para Linux
======================

$ sudo apt install qalculate-gtk

Fuente
======

https://proyectopinguino.blogspot.com/2008/09/calculadoras-para-linux.html

============================================================================
Enviar un archivo de manera segura por correo usando cifrado por ejemplo una
base de datos
============================================================================

1. Comprimir y cifrar el archivo con GPG (GNU Privacy Guard)

GPG es una herramienta de cifrado ampliamente utilizada y confiable. Puedes
cifrar el archivo .sql con una contraseña o usando una clave pública del
destinatario.

Pasos:

1- Instalar GPG (si no lo tienes instalado):

$ sudo apt update

$ sudo apt install gnupg

Cifrar el archivo con una contraseña:

$ gpg -c archivo.sql

Esto generará un archivo cifrado llamado archivo.sql.gpg.

Te pedirá una contraseña para cifrar el archivo. Asegúrate de compartirla con el
destinatario de forma segura (por ejemplo, por otro medio como un mensaje de
texto o una llamada).

Enviar el archivo cifrado:

Adjunta el archivo archivo.sql.gpg en el correo.

Descifrar en el destino:

El destinatario puede descifrar el archivo con:

$ gpg -d archivo.sql.gpg > archivo.sql

Se le pedirá la contraseña que usaste para cifrar.

Nota: Si se hace la prueba localmente para descifrar es posible que no pida la
contraseña ya que puede que la contraseña ya está agregada localmente por eso se
debe probar en otra pc.

Fuente
======

Deepseek

===========================================
Instalar y usar el paquete OpenVPN en Linux
===========================================

1. Instalación:

$ sudo apt update

$ sudo apt install openvpn

2. Configuración:

Para usar OpenVPN como cliente, necesitarás un archivo de configuración (.ovpn)
proporcionado por el servidor VPN al que deseas conectarte. Este archivo
contiene la información necesaria para establecer la conexión, como la dirección
del servidor, los certificados y las claves.

Generalmente, recibirás este archivo de tu proveedor de VPN. Guárdalo en una
ubicación accesible en tu sistema, por ejemplo, en la carpeta
/etc/openvpn/client/ o en tu directorio personal.

3. Conexión:

Una vez que tengas el archivo de configuración, puedes conectarte al servidor
VPN utilizando el siguiente comando en la terminal:

$ sudo openvpn --config /ruta/al/archivo.ovpn

Reemplaza /ruta/al/archivo.ovpn con la ubicación real de tu archivo de
configuración.

Es posible que se te solicite tu nombre de usuario y contraseña si el servidor
VPN lo requiere y no están incrustados en el archivo de configuración.

4. Desconexión:

Para desconectarte de la VPN, simplemente cierra la ventana de la terminal donde
se está ejecutando el comando openvpn. También puedes presionar Ctrl + C en la
terminal.

Otras consideraciones:

-Interfaz gráfica: Algunas distribuciones de Linux ofrecen interfaces gráficas
para gestionar conexiones OpenVPN a través del Network Manager. Puedes buscar en
la configuración de red de tu sistema la opción para importar archivos .ovpn o
configurar una conexión VPN de tipo OpenVPN.

-Servicio OpenVPN: OpenVPN también se puede configurar para ejecutarse como un
servicio en segundo plano, lo que permite que la conexión se establezca
automáticamente al inicio del sistema. La configuración para esto es más
avanzada y generalmente se utiliza para configurar un servidor VPN.

-Permisos: Asegúrate de tener los permisos necesarios para leer el archivo de
configuración y ejecutar el comando openvpn con sudo si es necesario.

Recuerda que la configuración específica puede variar dependiendo de tu
proveedor de VPN y tus necesidades particulares. Siempre es recomendable seguir
las instrucciones proporcionadas por tu proveedor de VPN.

Ejemplo de una conexión exitosa:

$ sudo openvpn --config /etc/openvpn/client/my-config.ovpn
2025-04-04 11:14:57 OpenVPN 2.6.3 x86_64-pc-linux-gnu [SSL (OpenSSL)] [LZO] [LZ4] [EPOLL] [PKCS11] [MH/PKTINFO] [AEAD] [DCO]
2025-04-04 11:14:57 library versions: OpenSSL 3.0.15 3 Sep 2024, LZO 2.10
2025-04-04 11:14:57 DCO version: N/A
Enter Auth Username: aosorio
Enter Auth Password: **************
2025-04-04 11:15:02 TCP/UDP: Preserving recently used remote address: [AF_INET]190.188.22.5:25143
2025-04-04 11:15:02 UDPv4 link local: (not bound)
2025-04-04 11:15:02 UDPv4 link remote: [AF_INET]190.188.22.5:25143
2025-04-04 11:15:02 WARNING: this configuration may cache passwords in memory -- use the auth-nocache option to prevent this
2025-04-04 11:15:02 [OpenVPN] Peer Connection Initiated with [AF_INET]190.199.22.5:52143
2025-04-04 11:15:03 Options error: Unrecognized option or missing or extra parameter(s) in [PUSH-OPTIONS]:2: block-outside-dns (2.6.3)
2025-04-04 11:15:03 Options error: Unrecognized option or missing or extra parameter(s) in [PUSH-OPTIONS]:3: register-dns (2.6.3)
2025-04-04 11:15:03 TUN/TAP device tun0 opened
2025-04-04 11:15:03 net_iface_mtu_set: mtu 1500 for tun0
2025-04-04 11:15:03 net_iface_up: set tun0 up
2025-04-04 11:15:03 net_addr_v4_add: 10.110.110.238/24 dev tun0
2025-04-04 11:15:03 Initialization Sequence Completed

Fuente
======

Gemini IA

Pasar las credenciales directamente en el archivo de configuración
==================================================================

En un archivo de configuración .ovpn de OpenVPN, puedes incluir las credenciales
(usuario y contraseña) directamente en el archivo o referenciar un archivo
externo que las contenga. Aquí están las opciones disponibles:

1. Variables/opciones para autenticación de usuario y contraseña en el .ovpn:

a) auth-user-pass

Es la directiva principal para indicar cómo se proporcionarán las credenciales:

-Solicitar interactivamente:
 
auth-user-pass

(OpenVPN pedirá el usuario y contraseña por consola al iniciar la conexión).

-Leer desde un archivo de texto:

auth-user-pass /ruta/al/archivo.txt

El archivo debe tener:

usuario
contraseña

(Primera línea: usuario, segunda línea: contraseña).

b) auth-nocache

Evita que las credenciales se guarden en memoria (recomendado para mayor seguridad):

auth-nocache

Ejemplo:

client
dev tun
proto udp
remote servidor.openvpn.com 1194
resolv-retry infinite
nobind
persist-key
persist-tun
auth-user-pass /etc/openvpn/credenciales.txt  # Archivo externo con credenciales
auth-nocache
remote-cert-tls server
cipher AES-256-CBC
verb 3

3. Recomendaciones de seguridad:

Nunca incluyas username y password directamente en el .ovpn.

Usa auth-user-pass con un archivo externo y restringe permisos:

$ chmod 600 /etc/openvpn/credenciales.txt

Si necesitas máxima seguridad, usa certificados SSL + autenticación de
usuario/contraseña.

Comentarios en un archivo .ovpn

En un archivo de configuración .ovpn (que sigue la sintaxis estándar de OpenVPN)
los comentarios se indican con el símbolo # (almohadilla o numeral) al inicio
de la línea. Todo lo que esté después de # en esa línea será ignorado por
OpenVPN.

Ejemplos de comentarios:

# Esto es un comentario en una línea
client # Esto también es un comentario (pero solo la parte después del #)
dev tun
proto udp

# Configuración del servidor remoto:
remote vpn.example.com 1194

Fuente
======

Deepseek

===========================
El archivo /etc/resolv.conf
===========================

El archivo /etc/resolv.conf en Linux es un archivo de configuración fundamental
que controla cómo el sistema resuelve los nombres de dominio (DNS).

¿Qué contiene y para qué sirve?

Propósito principal: Define los servidores DNS (Domain Name System) que el
sistema usará para traducir nombres de dominio (ej. google.com) a direcciones
IP (ej. 142.250.190.78).

Contenido típico (ejemplo):

nameserver 8.8.8.8
nameserver 8.8.4.4
search example.com
options timeout:2 attempts:3

nameserver: Dirección IP del servidor DNS (puede haber múltiples, se consultan en orden).

Ejemplo: 8.8.8.8 (DNS público de Google).

search: Dominio predeterminado para búsquedas cortas (ej. si pones servidor,
intentará servidor.example.com).

options: Parámetros de comportamiento:

timeout: Tiempo de espera (en segundos) antes de intentar el siguiente DNS.

attempts: Número de reintentos.

¿Cómo se modifica?

Edición manual (temporal, se pierde al reiniciar):

$ sudo nano /etc/resolv.conf

En muchas distribuciones modernas, este archivo es generado automáticamente por
servicios como systemd-resolved, NetworkManager o dhclient.

Cambio permanente (depende de tu distro):

En sistemas con NetworkManager:

$ nmcli connection modify <nombre-conexión> ipv4.dns "8.8.8.8 8.8.4.4"

$ nmcli connection up <nombre-conexión>

En sistemas con systemd-resolved:

Edita /etc/systemd/resolved.conf y luego:

$ sudo systemctl restart systemd-resolved

Verificar DNS actual:

$ cat /etc/resolv.conf

Casos especiales

Si el archivo es un enlace simbólico:

En distribuciones como Ubuntu, /etc/resolv.conf puede ser un enlace a /run/systemd/resolve/stub-resolv.conf. Usa:

$ ls -l /etc/resolv.conf  # Para ver su origen real.

Protegido contra ediciones:

Si el archivo tiene el atributo immutable (ej. en Alpine Linux):

$ lsattr /etc/resolv.conf  # Ver atributos

$ sudo chattr -i /etc/resolv.conf  # Deshabilitar protección antes de editar

Comandos útiles relacionados

Probar resolución DNS:

$ nslookup google.com

$ dig google.com

Ver DNS activos:

$ systemd-resolve --status  # Para systemd-resolved

¿Por qué es importante?

Si resolv.conf está mal configurado, el sistema no podrá acceder a internet por
nombres de dominio (solo por IPs directas). Ejemplo de error común:

$ ping google.com

$ ping: google.com: Name or service not known

Fuente
======

Deepseek

================================
Configurar ip estática en Debian
================================

Para configurar una IP estática en Debian, puedes editar el archivo
/etc/network/interfaces y añadir la configuración de la interfaz de red.
Primero, identifica el nombre de tu interfaz de red (por ejemplo, eth0, enp0s3,
o wlan0). Luego, edita el archivo /etc/network/interfaces como administrador
(usando sudo nano /etc/network/interfaces o similar) y agrega la información de
la IP estática, máscara de subred, gateway, y DNS.

Pasos detallados:

1. Identificar la interfaz de red: Abre la terminal y utiliza el comando:

$ ip a

Esto permite ver las interfaces de red disponibles. Elige la que deseas
configurar.

2. Hacer una copia de seguridad: Antes de editar el archivo, es recomendable
hacer una copia de seguridad del archivo original. Por ejemplo:

$ sudo cp /etc/network/interfaces /etc/network/interfaces.bak.

3. Editar el archivo /etc/network/interfaces: Abre el archivo con un editor de
texto como administrador:

$ sudo nano /etc/network/interfaces.

4. Configurar la interfaz (ejemplo): Si no existe una configuración para la
interfaz, agregala. Por ejemplo, si tu interfaz es enp0s3:

auto enp0s3
iface enp0s3 inet static
    address 192.168.1.100 # Tu IP estática
    netmask 255.255.255.0 # Máscara de subred
    gateway 192.168.1.1 # Puerta de enlace (gateway)
    dns-nameservers 8.8.8.8 8.8.8.8 # Servidores DNS

Si ya existe una configuración, cambia los valores para DHCP a los valores
estáticos.

Guardar y reiniciar la red (o reiniciar el servidor): Guarda el archivo
(usando Ctrl+X en nano, luego Y para confirmar) y reinicia el servicio de red.
Puedes hacerlo con

$ sudo systemctl restart networking

Opcionalmente, puedes reiniciar el servidor para asegurar que la configuración
se aplique correctamente.

Fuente
======

Gemini IA

=============================================
¿Cómo saber la mac física de mi pc en debian?
=============================================

En Debian (y en la mayoría de las distribuciones Linux), puedes saber la
dirección MAC física de tu PC usando algunos comandos en la terminal.

1. Usando el comando ip:

Este es el comando moderno y preferido en sistemas Linux. Abre una terminal y escribe:

$ ip a

o, si quieres ver solo las direcciones MAC:

$ ip link show

Busca las interfaces de red (generalmente eth0 o enpXs0 para Ethernet cableada,
wlan0 o similar para Wi-Fi). La dirección MAC estará listada junto a
"link/ether". Por ejemplo:

2: enp0s31f6: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:1a:2b:3c:4d:5e brd ff:ff:ff:ff:ff:ff

En este ejemplo, 00:1a:2b:3c:4d:5e sería la dirección MAC de la interfaz enp0s31f6.

2. Usando el comando ifconfig:

Aunque ifconfig está siendo reemplazado por ip, todavía es muy común y funciona en muchas instalaciones de Debian.

3. Leyendo directamente desde el sistema de archivos (útil si quieres ver la dirección MAC "verdadera" incluso si ha sido cambiada temporalmente):

Las direcciones MAC físicas se almacenan en el sistema de archivos bajo /sys/class/net/. Puedes ver las interfaces disponibles con:
Bash

$ ls /sys/class/net/

Luego, para ver la dirección MAC de una interfaz específica (por ejemplo,
enp4s0):

$ cat /sys/class/net/enp4s0/address

Esto mostrará solo la dirección MAC de esa interfaz.

Fuente
======

Gemini

============================================================
Renombrar de manera masiva los nombre de archivos con rename
============================================================

El comando rename es una herramienta poderosa en Linux para renombrar múltiples
archivos de manera rápida y eficiente usando expresiones regulares. Es ideal
cuando necesitas cambiar patrones de nombres en lotes.

Instalarlo si no está instalado:

$ sudo apt install rename

Sintaxis básica
===============

$ rename [opciones] 's/patrón-a-reemplazar/nuevo-patrón/' archivos

s/: Indica una sustitución (como en sed).

patrón-a-reemplazar: Texto o regex a buscar.

nuevo-patrón: Texto que lo reemplazará.

Ejemplo sencillo
================

Objetivo: Cambiar la extensión .txt a .md en varios archivos.

Paso 1: Crear archivos de prueba

$ touch archivo1.txt archivo2.txt archivo3.txt

Paso 2: Ejecutar el renombrado (real)

$ rename 's/\.txt/\.md/' *.txt

Otro ejemplo:

Tengo archivos PDF con este nombre ****-clc-07-25-Estudiante.pdf donde ****
representan números únicos, necesito cambiar el nombre de todos los archivos de
****-clc-07-25-Estudiante.pdf a ****-clc-06-25-Estudiante.pdf osea cambiar el 07
por 06, el comando sería:

$ rename 's/clc-07-25/clc-06-25/' *.pdf

Fuente
======

DeepSeek

=======
TCPDump
=======

TCPDump es una herramienta de línea de comandos que permite capturar y analizar
tráfico de red en tiempo real. Funciona escuchando paquetes que pasan por una
interfaz de red y los muestra o guarda en un archivo para su posterior análisis.

Es ampliamente utilizado por administradores de sistemas y profesionales de
seguridad para:

-Diagnóstico de problemas de red.

-Detección de tráfico malicioso.

-Análisis de protocolos (HTTP, DNS, SSH, etc.).

-Auditoría de seguridad.

2. Instalación en Debian Linux

TCPDump suele estar instalado por defecto en muchas distribuciones, pero si no
lo está, se puede instalar con:

$ sudo apt update && sudo apt install tcpdump

-----

Verificar instalación:

$ tcpdump --version

-----

3. Uso básico de TCPDump

A. Capturar tráfico en una interfaz específica

sudo tcpdump -i eth0

-i eth0 Escucha en la interfaz eth0 (puede ser wlan0 para Wi-Fi).

B. Capturar solo un número limitado de paquetes

$ sudo tcpdump -i eth0 -c 10

-c 10 Captura solo 10 paquetes y luego se detiene.

-----

Capturar solo 10 paquetes y luego se detiene pero de una ip específica.

$ sudo tcpdump src 192.168.1.110 -c 10

3. Filtros avanzados

TCPDump permite filtrar por:

IP de origen/destino:

$ sudo tcpdump src 192.168.1.100  # Tráfico desde 192.168.1.100

$ sudo tcpdump dst 8.8.8.8        # Tráfico hacia Google DNS

Puerto específico (HTTP, SSH, DNS, etc.):

$ sudo tcpdump port 80            # Captura tráfico HTTP

$ sudo tcpdump port 22            # Captura tráfico SSH

Protocolos (ICMP, TCP, UDP, etc.):

$ sudo tcpdump icmp               # Solo paquetes ICMP (ping)

$ sudo tcpdump tcp                # Solo tráfico TCP

Combinar filtros (ej: HTTP desde una IP específica):

$ sudo tcpdump "src 192.168.1.100 and port 80"

5. Ejemplos prácticos

Ver todo el tráfico HTTP (puerto 80):

$ sudo tcpdump -i eth0 port 80 -A

(-A muestra el contenido en ASCII).

-----

Capturar tráfico DNS (puerto 53):

$ sudo tcpdump -i eth0 port 53

-----

Detectar conexiones SSH entrantes:

$ sudo tcpdump -i eth0 dst port 22

4. Alternativas a TCPDump

Wireshark (GUI para análisis avanzado).

TShark (versión CLI de Wireshark).

ngrep (filtrado de tráfico con expresiones regulares).

Conclusión
==========

TCPDump es una herramienta poderosa y esencial para el análisis de red en Linux.
Con los filtros adecuados, puedes diagnosticar problemas, monitorear tráfico y
mejorar la seguridad de tu sistema.

Fuente
======

DeepSeek

===========
LibreOffice
===========

Cambiar el tema
===============

Aquí te explico cómo hacerlo paso a paso:

1- Abre cualquier aplicación de LibreOffice (Writer, Calc, etc.).

2- Ve al menú superior y selecciona Herramientas > Opciones.

3- En la ventana de opciones que se abre, busca y haz clic en LibreOffice en el
panel de la izquierda.

4- Luego, selecciona Apariencia > Opciones y escoge el tema luego Aplicar y
Aceptar.

Fuente
======

DeepSeek

-----

Poner el libreoffice en español.

# apt-get install libreoffice-l10n-es

-----

Poner el libreoffice en español de venezuela.

# apt-get install libreoffice-l10n-ve

Instalar extensiones en LibreOffice
===================================

# apt-get install myspell-es

Este es el diccionario de español para usar con el corrector ortográfico
myspell, que actualmente se usa en OpenOffice.org y el corrector ortográfico de
mozilla. Al parecer con esto basta pero a mi no me funciono esa mierda, de todas
maneras se debe comprobar primero a ver si funcionó, si no funciono, entonces
hacer lo siguiente:

Hay que bajarse un .oxt, investigarlo, luego desde el LibreOffice

Herramientas > Gestor de extensiones > Buscar el .oxt descargado

En este caso lo he probado con spanish-dictionary.oxt que es la extensión para
que funcione la correción de errores.

=====================
PulseAudio y PipeWire
=====================

Son servidores de sonido en Linux. Su función principal es actuar como un
intermediario o "middleware" entre las aplicaciones y el hardware de sonido de
tu computadora. Esto permite que varias aplicaciones reproduzcan audio al mismo
tiempo, mezclen diferentes fuentes de sonido y controlen el volumen
individualmente para cada una.

PulseAudio:

PulseAudio fue el servidor de sonido estándar en la mayoría de las
distribuciones de Linux durante muchos años. Fue un gran avance en comparación
con sistemas anteriores, ya que introdujo funcionalidades importantes como:

-Mezcla de audio: Permite que múltiples aplicaciones (como tu reproductor de
música, un navegador web y un juego) emitan sonido simultáneamente a través de
la misma tarjeta de sonido.

-Control por aplicación: Te permite ajustar el volumen de cada aplicación de
forma independiente.

-Streaming de red: Ofrece la capacidad de transmitir audio a otras computadoras
en la red.

-Control dinámico: Permite cambiar el dispositivo de salida de audio sobre la
marcha, por ejemplo, de los altavoces a unos auriculares Bluetooth, sin tener
que reiniciar las aplicaciones.

A pesar de sus beneficios, PulseAudio tenía algunas limitaciones, especialmente
en entornos de audio profesional donde se requiere baja latencia (retraso).
También tenía algunos problemas conocidos con el alto uso de CPU y la gestión de
dispositivos Bluetooth.

PipeWire:

PipeWire es un servidor de sonido más moderno y ha reemplazado a PulseAudio en
muchas distribuciones de Linux recientes, Fue diseñado para resolver las
deficiencias de PulseAudio y de otro servidor de sonido profesional llamado
JACK, que se usa para producción musical.

Las principales ventajas de PipeWire son:

-Baja latencia: Proporciona un rendimiento mucho mejor para aplicaciones de
audio profesional, lo que lo hace ideal para músicos y productores.

-Manejo unificado: Reemplaza tanto a PulseAudio como a JACK, permitiendo que las
aplicaciones de uso general y las de audio profesional funcionen juntas sin
conflictos.

-Gestión de video: A diferencia de PulseAudio, PipeWire también maneja
transmisiones de video, lo que lo hace esencial para funciones como la captura
de pantalla y el screencasting en entornos modernos como Wayland.

-Mejor soporte para Bluetooth: Resuelve muchos de los problemas de conexión y
calidad de audio que eran comunes con PulseAudio.

PipeWire es compatible con las aplicaciones diseñadas para PulseAudio, lo que
significa que puedes cambiar a PipeWire sin perder la funcionalidad de tus
aplicaciones existentes. En la práctica, actúa como una capa de compatibilidad
que "imita" a PulseAudio, lo que hace que la transición sea casi transparente
para el usuario final.

¿Cómo saber si uso pipewire o pulseaudio?
========================================

Escribe el siguiente comando y presiona Enter:

$ pactl info | grep "Server Name"

Si el resultado dice Server Name: PulseAudio (on PipeWire...), significa que
estás usando PipeWire con una capa de compatibilidad para PulseAudio. Este es el
comportamiento por defecto en Debian 12. Si el resultado es solo Server Name:
PulseAudio, entonces estás usando PulseAudio.

Revisar procesos en ejecución: También puedes verificar qué servicio se está
ejecutando en segundo plano con este comando:

$ ps -e | grep -E "pipewire|pulseaudio"

Si ves pipewire o pipewire-pulse en la lista, estás usando PipeWire. Si ves
pulseaudio, entonces ese es tu servidor de sonido. En muchos casos, verás ambos
lo que confirma que PipeWire está activo para manejar el audio de PulseAudio.

En resumen, la mayoría de los usuarios de Debian 12 usan PipeWire por defecto,
ya que se ha convertido en el servidor de sonido principal de la distribución.

Debian baja el volumen solo
===========================

Este problema generalmente ocurre en Debian 12 debido a la función de reducción
automática de volumen incorporada en el servidor de sonido, que está diseñada
para evitar la sobrecarga de sonido o para nivelar el audio de diferentes
fuentes.

Causas y Solución:

La razón más común por la que el volumen se baja solo es la configuración de un
límite de volumen o la nivelación automática de audio. Esto puede ser manejado
por PulseAudio o PipeWire, que son los sistemas de sonido más comunes en Debian.
Para evitar que el volumen se baje automáticamente, tienes que deshabilitar esta
función en la configuración.

A continuación, te muestro cómo hacerlo:

Si usas PulseAudio

$ sudo nano /etc/pulse/daemon.conf

Busca la línea que contiene enable-volume-adjust o volume-limit y coméntala
(añade un # al inicio) o cámbiale el valor a no o false. Si no encuentras una
línea similar, puedes añadir la siguiente línea al final del archivo para
asegurarte de que esta característica está deshabilitada:

enable-volume-adjust = no

Guarda el archivo y reinicia el servicio de PulseAudio para que los cambios
surtan efecto:

$ pulseaudio -k

$ pulseaudio --start

Si lo anterior no funciona, intenta reiniciar el sistema:

$ sudo systemctl restart pulseaudio

Si usas PipeWire

Debian 12 usa PipeWire por defecto, por lo que es más probable que esta sea la
causa del problema. En este caso, la solución es similar.

Abre el archivo de configuración de PipeWire para el control de volumen:

$ sudo nano /etc/pipewire/media-session.d/wireplumber.conf

Dentro de este archivo, busca la sección [module] o [settings] y desactiva
cualquier función relacionada con la nivelación de volumen, como
auto-volume-adjust o volume-limiter. A menudo, esta función está controlada por
el módulo libvolume-adjust.so o similar.

Guarda los cambios y reinicia el servicio de PipeWire:

$ sudo systemctl --user restart pipewire pipewire-pulse

Si el problema persiste, es posible que tengas que reiniciar el sistema para que
la configuración se aplique completamente.

Que pasa si no consigo la variable para configurar el volumen
=============================================================

Si la variable enable-volume-adjust o volume-limit, no está presente. Esto es
porque el archivo daemon.conf solo muestra los valores por defecto del demonio
de PulseAudio.

La sección que controla el volumen automático es 

flat-volumes, pero en tu archivo está comentada. Esto significa que el sistema
está usando la configuración por defecto, que puede estar causando que el
volumen se ajuste solo.

Solución

Abre el archivo de configuración de PulseAudio nuevamente:

$ sudo nano /etc/pulse/daemon.conf

Busca la línea que dice 

; flat-volumes = no.

Descomenta la línea (quita el ; al principio) y cambia el valor de no a yes para
ver si resuelve el problema. La línea debería quedar así:

flat-volumes = yes

Al establecer flat-volumes = yes, PulseAudio gestionará el volumen de manera más
plana, lo que podría evitar los ajustes automáticos.

Guarda el archivo y reinicia PulseAudio.

$ pulseaudio -k

$ pulseaudio --start

Si el problema persiste, es probable que la nivelación de volumen esté siendo
controlada por otro componente, como un módulo de PulseAudio o por PipeWire, que
es el servidor de sonido predeterminado en Debian 12. En ese caso, te recomiendo
seguir los pasos que te di antes para configurar PipeWire, ya que es el sistema
que probablemente esté causando el problema.

$ pulseaudio -k

bash: pulseaudio: orden no encontrada

El error "orden no encontrada" significa que el comando pulseaudio -k no está
disponible en tu sistema. Esto es un indicio de que PipeWire es el servidor de
sonido que se está ejecutando en tu Debian 12, ya que ha reemplazado a
PulseAudio como la opción predeterminada en muchas instalaciones. Para reiniciar
los servicios de audio y aplicar cambios de configuración, debes usar los
comandos de PipeWire.

Cómo reiniciar los servicios de PipeWire:

Para reiniciar los servicios de audio de PipeWire, utiliza el siguiente comando
en la terminal. Este comando reinicia tanto el servicio principal de PipeWire
como su capa de compatibilidad para PulseAudio.

$ systemctl --user restart wireplumber pipewire pipewire-pulse

-systemctl --user: Este es el gestor de servicios de systemd para el usuario.
Se utiliza para gestionar los servicios que se ejecutan a nivel de usuario, como
los de audio.

-restart: Le indica a systemctl que reinicie los servicios especificados.

-wireplumber: Es el gestor de sesiones de PipeWire que se encarga de la
configuración del audio.

-pipewire y pipewire-pulse: Son el servicio principal de PipeWire y la capa de
compatibilidad con PulseAudio, respectivamente.

Al ejecutar este comando, los cambios que hayas hecho en los archivos de
configuración de PipeWire se aplicarán sin necesidad de reiniciar todo el
sistema.

Fuente
======

Gemini IA

==============================
GParted (GNU Partition Editor)
==============================

Es un editor de particiones de disco gratuito y de código abierto. Es una
herramienta muy poderosa y popular que se utiliza para crear, eliminar,
redimensionar, mover, verificar y copiar particiones en un disco duro.

¿Para qué se usa?
=================

Básicamente, GParted te permite gestionar cómo está dividido el espacio de tu
disco duro. Algunas tareas comunes incluyen:

-Redimensionar una partición: Por ejemplo, hacer la partición de Windows más
pequeña para crear espacio y instalar Linux en una nueva partición.

-Crear una nueva partición: Dividir un disco en varias secciones para organizar
tus datos (por ejemplo, una partición para el sistema operativo y otra para tus
archivos personales).

-Formatear una partición: Cambiar el sistema de archivos (por ejemplo, de NTFS a
FAT32 o ext4).

-Eliminar o recuperar particiones.

-Alinear particiones para optimizar el rendimiento en discos SSD.

Características clave:
======================

-Gratuito y de Código Abierto: Es parte del proyecto GNU y cualquiera puede
usarlo, estudiarlo o modificarlo libremente.

-Multiplataforma: Funciona con una gran variedad de sistemas de archivos (NTFS
de Windows, ext4, btrfs de Linux, FAT32, HFS+ de macOS, y muchos más).

-Se ejecuta desde un Live USB/CD: Dado que no puedes modificar las particiones
de un sistema operativo que está en uso (como no puedes cortar una tabla en la
que estás sentado), GParted normalmente se ejecuta desde un medio externo. Esto
significa que arrancas tu computadora desde un USB o CD que contiene GParted,
permitiéndote modificar todas las particiones de tu disco.

-Se pude instalar localmente.

Instalación
===========

$ sudo apt-get install gparted

Fuente
======

DeepSeek

=================================================
Formatear un pendrive en FAT32 o NTFS con GParted
=================================================

1- Iniciamos dparted desde el menú de aplicaciones o en un terminal

$ sudo gparted

Nos solicita la contraseña en el terminal o gráficamente si lo hemos lanzado del
menú de aplicaciones.

autentificacion-gparted

Una vez en Gparted lo primero que visualizamos es la estructura de particiones
del disco duro principal del equipo

Si tenemos más dispositivos de almacenamiento (discos duros, pendrives, tarjetas
de memorias flash,…) conectados al PC podemos acceder a través del menú que se
muestra al pulsar encima de la casilla donde puede visualizarse "/dev/sda" que
está ubicada en la parte superior derecha del interfaz gráfico de Gparted.

Ahora conetamos en un puerto USB el pendrive que queremos formatear, le damos
unos segundos para que lo reconozca. Pulsamos el botón del menú principal
«Gparted» y «Refrescar dispositivos».

Comienza a buscar los dispositivos de almacenamiento conectados al PC.

Cuando termine volvemos a pinchar en «/dev/sda» y tenemos un nuevo dispositivo,
el pendrive, seleccionamos el pendrive.

Si es un pendrive que hemos estado usando para su uso habitual seguramente
tenemos una partición en fat o en ntfs ,pero también podemos encontrarnos con
varias particiones de diferentes formatos, en cualquiera de las 2 situaciones
crearemos una nueva tabla de particiones con lo que eliminaremos todas las
particiones y el contenido de las mismas. Es muy importante que seas consciente
que con lo que vamos a hacer borraremos el contenido del pendrive, así que si
tienes algo importante debes hacer una copia de seguridad previo a este paso.

Asegurate que en la parte superior derecha tengamos seleccionado el pendrive,
en este caso «/dev/sdb». Si tienes seleccionado otro disco duro es posible que
borres todo el contenido. No me hago responsable de una mala elección, por esto
os insisto en que debemos ser muy cautos.

Pinchamos en «Dispositivo» y «Crear tabla nueva de particiones».

Advertencia de GParted, si estamos seguros pinchamos en «Aplicar».

Crea tabla de particiones y vuelve a reconocer dispositivos.

Pinchamos con el botón derecho encima del espacio etiquetado como «sin asignar»
o de la linea que comienza por lo mismo, en la imagen pinchamos encima de la
linea. En el menú desplegable pinchamos en «Nueva» para crear una nueva
partición.

Simplemente cambiamos en «Sistema de archivos» la opción «ext4» que es la que
muestra por defecto por «fat32» y pinchamos en «Añadir». (Si quieres que el
formato de la nueva partición sea «ntfs» tienes que seleccionar «ntfs».)

Vemos una previsualización de como quedará el Pendrive una vez terminado el
proceso. Yo veo la partición en fat32 que es lo que he elegido, si has elegido
ntfs la verás como ntfs.

Pinchamos en «Aplicar todas las operaciones».

Confirmamos pinchando en «Aplicar».

Vemos el proceso.

Hasta que nos muestra el mensaje de finalizado y pinchamos en «Cerrar».

Nuevo reconocimiento buscando discos duros conectados al PC.

Y al terminar podemos ver como nuestro pendrive contiene una partición en
formato «fat32», si has elegido «ntfs» lo verás como «ntfs».

Llegados hasta aquí ya puedes cerrar GParted, ya tienes tu pendrive en formato
fat32 o ntfs.

Fuente
======

https://experienciasubuntu.wordpress.com/2017/03/17/formatear-pendrive-fat32-ntfs-gparted-ubuntu-16-04-y-diferentes-sabores/
