==========================================
Guía de comandos en GNU/Linux Debian by dM
==========================================

=============================================
Comandos para mostrar información del sistema
=============================================

Mostrar archivos ocultos de un directorio, esto se hace desde el explorador de
archivos nautilus de Gnome.

Crtl + h

-----

Para saber la versión de SO que tenemos.

$ cat /etc/issue.net

-----

Para saber la versión de SO que tenemos.

$ cat /etc/issue

-----

Para saber la versión de Debian que tenemos específicamente.

$ cat /etc/debian_version

-----

Para ver la información del cpu o procesador.

$ cat /proc/cpuinfo

-----

Para ver la información del cpu o procesador pero menor a la anterior.

$ lscpu

-----

Saber el número de núcleos del procesador.

$ nproc

----

Comando que nos va a dar detalles de SO.

$ lsb_release -a

-----

Muestra información del sistema.

$ uname

-----

Muestra la versión del SO instalado, Version de Kernel y arquitectura de
procesador.

$ uname -a

-----

Saber mi version de Kernel especifica, recomendada.

$ uname -mrs

-----

Ver info del sistema.

$ cat /etc/*-release

-----

Indica cuánto tiempo ha estado funcionando el sistema, muestra:

$ uptime

15:11:08 up 1 day,  5:07,  9 users,  load average: 0,65, 0,83, 0,88

Los parámetros que muestra son:

-El tiempo actual que el sistema ha estado ejecutando.
-El tiempo que lleva el sistema corriendo.
-Los usuarios que están actualmente registrados.
-Tiempo de carga del sistema durante los últimos 1, 5 y 15 minutos.

-----

Saber cuantos demonios(daemons) del sistema están en ejecución. En esta ruta se
encuentran algunos de los scripts que se ejecutan con el arrenque del SO.

$ ls -l /etc/init.d/

-----

Muestra la fecha.

$ date

-----

Asignar la fecha manualmente.

# date --set 1998-11-02

-----

Asignar la hora manualmente.

# date --set 21:08:00

-----

Muestra un calendario.

$ cal

-----

Ver informacion de los discos duros, particiones y dispositivos montados en el
sistema.

# fdisk -l

-----

Este comando muestra todos los puertos USB y los detalles acerca de los
dispositivos conectados a ellos.

$ lsusb

-----

Lista todos los componentes tipo pci (Peripheral Component Interconnec) como
las tarjetas de red, de sonido o de televisión.

$ lspci

-----

Leer el fichero meminfo que contiene datos dinámicos de la memoria, similar
a free.

$ cat /proc/meminfo

-----

Saber cuánta y qué tipo de memoria RAM tengo.

$ sudo dmidecode --type memory | less

-----

Muestra el estado de la memoria virtual.

$ vmstat

-----

Muestra el espacio disponible del disco y demas dispositivos asi como el espacio
usado.

$ df

-----

Muestra el espacio disponible del disco y demas dispositivos asi como el espacio
usado, pero en mg o gb según sea el caso.

$ df -h

-----

Muestra el espacio disponible del disco y demas dispositivos asi como el espacio
usado, pero en mg.

$ df -m

-----

Muestra los procesos del sistema en forma de arbol.

$ pstree

-----

Enumerar todas las fuentes instaladas que están disponibles en su sistema linux.

$ fc-list

-----

Saber que gestor de sesiones estoy utilizando

$ cat /etc/X11/default-display-manager

===========
Memoria ram
===========

Muestra el estado de la memoria RAM, total, usado, disponible, cached, buffers.

$ free

Mostrar los datos en mb sin más.

$ free -m

Para ver los resultados en mb o gb con letra al final.

$ free -h

Detalles, fabricante, tipo, el máximo que soporta nuestro equipo, etc.

# dmidecode --type memory

================================
Tips para la consola de comandos
================================

Repetir el ultimo comando ejecutado en consola.

!!

Para sacarlo usar AvPag en la consola.

~

Ejecucion multiple de comandos

$ comando && comando && comando

Cortar el contenido de la linea de comandos desde la posicion del cursor hasta
el principio.

Ctrl + u

Cortar el contenido de la linea de comandos desde la posicion del cursor hasta
el final.

Ctrl + k

Intercambiar de posicion las letras que estan a cada lado del cursor.

Ctrl + t

Limpiar el shell.

Ctrl + l

En el shell, cerrar sesion, salir del root, de maquinas virtuales o de sesiones
de usuarios iniciadas.

Ctrl + d

Moverse en el prompt palabra a palabra, no letra por letra.

Ctrl + flecha derecha o izquierda

Borrar la palabra que esta antes del cursor en el shell.

Ctrl + w

Parar la salida por pantalla. Si por ejemplo ejecutamos un comando que tiene una
salida inmensa, podemos hacer que trabaje en silencio.

Control + s

Permitir la salida por pantalla, inverso al comando anterior.

Control + q

Borrar palabra

Alt + d

===============
Comandos varios
===============

Muestra el manual de una comando donde como: ls, grep, aptitude etc...

$ man nombre_comando

Dentro de los manuales podemos presionar "h" para ver las opciones tenemos del
manual, ejemplo "/delete" para hacer una busqueda de la cadena "delete" dentro
del manual.

Limpiar la consola.

$ clear

Si no desea ver la página de manual completa sino sólo una descripción corta
para confirmar que es lo que está buscando, ingrese whatis programa.

$ whatis nombre_programa

Ejemplo:

$ whatis scp

scp (1)     - copia segura (programa de copia de ficheros remotos)

Apagar la maquina, se debe ser root para ejecutarlo.

$ poweroff

Reiniciar la maquina.

$ reboot

Reiniciar la maquina en Debian 10.

# systemctl reboot

-----

Detectar las resoluciones de pantalla disponibles del sistema así como los hz
correspondientes, la que tenga (*) es la que está siendo usada.

$ xrandr

-----

Obtener la resolución de la pantalla o pantallas.

$ xrandr | grep '*'

-----

Ver las dependencias de una librería o ejecutable, en este caso del ejecutable
de python.

$ ldd /xxx/python2.7

$ ldd /bin/bash

===================================
Comandos para gestionar directorios
===================================

(print work directory) Muestra la ruta en la que te encuentras.

$ pwd

Crear una carpeta.

$ mkdir nombre_carpeta

Crear una carpeta con otra carpeta dentro, encadenar la creación.

$ mkdir -p carpeta1/carpeta2

El operador '&&' sirver para continuar con la ejecucion de comadnos en el shell,
ejemplo:

Creamos una carpetaFFF y luego entramos en la carpeta creada

$ mkdir carpetaFFF && cd carpetaFFF

&& nos permite poner varias instrucciones en una sola linea del shell, otro
ejemplo:

Creamos una carpeta, entramos en ella y creamos un archivo en ese directorio en
una sola instruccion.

$ mkdir carpetaZZZ && cd carpetaZZZ && touch archivo.txt

Crear fichero con la extensión que se requiera.

$ touch nombre_fichero.xxx

Crear una carpeta que lleve por nombre la fecha, ejemplo: 20170807

$ mkdir /tmp/`date +\%Y\%m\%d`

====================================
Comandos para listar los directorios
====================================

Muestra lo que hay en la carpeta en la que te encuentras.

$ ls

-----

Muestra los archivos, fecha, permisos, etc.

$ ls -l

-----

Muestra los archivos, fecha, permisos, y el peso pero en kb,mg o gb según sea el
caso.

$ ls -lh

-----

Muestra los archivos, los ocultos tambien, fecha, permisos, etc.

$ ls -la

-----

Muestra los archivos en forma de lista.

$ ls -1

-----

Lista el contenido de un directorio en orden alfabético, usa space para paginar
si la lista es grande.

$ ls | more

-----

Listar todos los ficheros de un directorio que tengan las extension .xxx, donde
xxx puede ser: txt, html, php, css.

$ ls *.xxxetc

ejemplo: ls *.txt

-----

Listar los directorios y subdirectorios asi como ficheros de un directorio.

$ ls -R

-----

Muestra el contenido del directorio en una lista numerada.

$ ls | cat -n

-----

Contar el número de ficheros o elementos contenidos en un directorio.

$ ls name_dir | wc

-----

Ver la lista de carpetas y sub carpetas, los directorios que existen, lo primero
que muestra es el tamaño.

$ du

-----

Los mismo que arriba pero se ven los tamaños pesos en kb, mg, etc.

$ du -h

-----

Ver el tamaño total de los directorios.

$ du -sh

-----

Ver el tamaño de un directorio específico.

$ du -sh name_dir

-----

Muestra todos directorios y ficheros y el espacio que ocupan en el disco.

$ du *

-----

Leer todos los elementos y ver los tamaños en kg, mg, etc.

$ du -h *

-----

Ver los tamaños en kg, mg, etc, de un fichero específico.

$ du -h file_name.xxx

-----

Ver el tamaño de los directorios y de los archivos en megabytes, hasta 10
niveles de profundidad.

$ du -ha --max-depth=10 | sort -hr

-----

Listar los archivos de X extensión por peso sin importar si está en un
subdirectorio, en este caso los .txt por ejemplo, dara los pesos en mg y kb
ordenados de mayor a menor en la lista:

$ find . -type f -name "*.pdf" -exec du -ah {} + | sort -hr

Explicación del comando:

find . -type f -name "*.txt": busca en el directorio actual (.) todos los
archivos (-type f) con la extensión .txt (-name "*.txt").

-exec du -ah {} +: ejecuta el comando du -ah en cada uno de los archivos
encontrados. La opción {} se reemplaza con el nombre del archivo encontrado, y
el + al final indica que se deben procesar varios archivos a la vez para mejorar
el rendimiento.

| sort -hr: ordena la lista resultante por tamaño, de mayor a menor.

Este comando mostrará una lista de todos los archivos con la extensión .txt en
el directorio actual y sus subdirectorios, ordenados por tamaño en megabytes.
Puedes cambiar la extensión .txt en el comando para listar otros tipos de
archivos.

-----

Calcular el tamaño ocupado por un directorio.

# du -h -s /var/log

9,6M    /var/log

-----

Nos dira el tipo de archivo de todos los ficheros del directorio.

$ file *

=======================================
Comandos para moverse entre directorios
=======================================

Cambiar de directorio, nos lleva al home del usuario.

$ cd

-----

Acceder a un directorio que tiene espacios en el nombre.

$ cd 'nombre carpeta'

-- Si una carpeta se llama (a b c d e), para aceder a ella usamos:

Al final siempre lleva el / normal, los otros usan el invertido.

$ cd a\ b\ c\ d\ e/

-----

Retroceder un directorio.

$ cd ..

-----

Retroceder dos directorios (../) representa un directorio.

$ cd ../../

===========================
Rutas relativas y absolutas
===========================

- Una ruta o path es donde se localiza una carpeta o fichero dentro de nuestro
sistema de ficheros.

- Todos los comandos que se ejecuten sin especificar una ruta lo hará donde este
situado.

- Hay dos tipos de ruta que debemos diferenciar:

=============
Ruta absoluta
=============

Se indica toda la ruta del fichero incluyendo el directorio raíz. Por ejemplo:

/home/user/folder/file.txt

=============
Ruta relativa
=============

Se indica la ruta a partir de donde este en ese momento situado. No se incluye
el directorio raíz. Por ejemplo, si estamos en la ruta /home/user y queremos
acceder al file.txt que esta dentro de folder, seria:

folder/file.txt

=================================================================
Comandos para buscar ficheros, directorios, paquetes, historiales
=================================================================

Mostrar el historial de los comandos de la consola.

$ history

-----

Mostrar los ultimos comandos usados por el usuario

$ fc -l

-----

Busqueda especifica de una comando usado, ejemplo: aptitude, alias, grep etc.

$ history | grep xxx

-----

En los archivos ocultos del home, en este fichero se almacena el historial de
los comandos usados.

.bash_history

-----

--color para colorear la palabra a buscar, -n para listar la la linea del
caracter buscado y al final la ruta del archivo a buscar.

$ grep --color=always -n "mysql" /var/www/prueba/2/datos.php

-----

Busca la cadena de manera recursiva en la carpeta en que se encuentre situado

$ grep cadena_texto ./* -rIn

-----

Busca la cadena de manera recursiva en la carpeta en que se encuentre situado.

$ grep --color=always -n "cadena_texto" ./* -Ir

No hace falta poner =always siempre.

-----

$ grep --color -n "cadena_texto" -Ir

Aquí está el significado de cada una de las opciones utilizadas en el comando:

grep es un comando utilizado para buscar texto en archivos.

--color hace que la salida del comando se resalte en color para que sea más fácil de leer.

-n hace que se imprima el número de línea junto con la línea coincidente.

-I hace que los archivos binarios se ignoren durante la búsqueda.

-r hace que la búsqueda se realice de manera recursiva en todos los archivos y subdirectorios a partir del directorio actual.

Si se quiere buscar más de una cadena se usan las comillas dobrles:

$ grep --color -n -Ir "la casa"

Al utilizar comillas dobles, indicas que el contenido entre las comillas es una
sola cadena que debe ser buscada. En este caso, el comando buscará la cadena
"la casa" en todos los archivos del directorio actual y sus subdirectorios.

-----

Otra forma de busqueda.

$ egrep -r "Saludo" .

-----

Filtra la busqueda con el parametro que le demos ejemplo:

| grep xxx

-----

Busca las versiones de python que coincidan con el patron 2.7.

$ aptitude search python | grep 2.7

-----

Busca en los procesos del sistema las coincidencias con ruby

$ ps -e | grep ruby
-----

Para saber donde esta instalado un programa, saber el directorio

$ whereis python

$ whereis firefox

$ whereis apache2

-----

Listar todos los archivos contenidos en el directorio actual y en los sub
directorios, si estamos en /home/user nos listara todo, dependiendo de donde
este pues listara el contenido.

$ find

-----

Buscar un directorio especifico en el sistema.

$ find -name name_dir

-----

Buscar un fichero o directorio específico en el sistema.

# find / -name name_file_or_package

-----

Para mostrar el directorio del archivo que se quiera buscar, se debe saber el
nombre del archivo.

# find / -type f -name NombreArchivo.html

-----

Abrir un fichero del directorio desde el navegador.

file:///home/user/nombre_fichero.xxx

-----

Hacer una busqueda de un archivo en los directorios, se puede especificar un
nombre con su extensión o solo especificar una palabra, la busqueda se hara en
todos los archivos que contengan la palabra o nombre de archivo escrita.

$ locate nombre_del_archivo

-----

Buscar en todos los directorios los ficheros con la extension especificada.

$ locate .jpg

-----

Buscar en todos los directorios los ficheros con la extension especificada.

$ locate "*.jpg"

-----

Buscar en todos los .pdf del sistema que contengan la palabra "software" en el
nombre. Sí hace distinción entre mayúsculas, minúsculas y acéntos.

$ locate .pdf | grep software

-----

Muestra cuantos archivos contienen la palabra "hola" en el nombre.

$ sudo locate -c hola

-----

Busca todos los archivos que contienen la palabra "hola" en el nombre tanto en
mayúsculas como en minúsculas.

$ sudo locate -i hola

-----

Para guardar el resultado de la búsqueda en un archivo de texto.

$ sudo locate nombre_archivo > /home/usuario/lista.txt

-----

(/) es para hacer la busqueda desde ahi en adelante, puede ser (/home/user)

$ sudo find / -name nombre_carpeta

-----

Lista los archivos que componen el directorio introducido.

$ find /carpeta

-----

Busca la ruta donde se encuentra el comando, ejemplo: aptitude, python, etc.

$ type nombre_comando

-----

Buscar la ruta de un programa.

$ which nombre_programa

-----

Buscar en todo el sistema los ficheros cuyo nombre contengan la expresion
escrita.

$ sudo find / -name "*nombre_fichero*"

-----

Buscar en el directorio actual los ficheros cuyo nombre contengan la expresion
escrita.

$ sudo find -name "*nombre_fichero*"

-----

Buscar en todo el sistema los ficheros cuyo nombre contengan la expresion
escrita, en este caso, una extensión de fichero, donde / puede ser /home/user
etc y .xxx la extension: .jpg, .png, .txt, .py, etc.

$ sudo find / -name "*.xxx*"

-----

Busca todos los archivos que NO contienen la palabra "xxx" en el nombre, se
especifíca el directorio en el cual buscar.

$ sudo find /home/user ! -name "*xxx*"

-----

Busca todos los archivos que contienen la palabra "xxx" en el nombre tanto en
mayúsculas como en minúsculas.

$ sudo find /home/user -iname "*xxx*"

-----

Si el resultado de la búsqueda anterior te ha proporcionado una gran cantidad de
información, resulta más cómodo almacenar el resultado de la búsqueda en un
fichero de texto para revisarlo posteriormente.

$ sudo find /home/user/ -iname "*xxx*" > /home/user/lista.txt

-----

Crear un fichero (x.txt) que guardará la salida de la consola, en este caso es
una búsqueda, buscamos el fichero.c en el directorio user y guardaremos la
salida del shell en el fichero x.txt que se creará.

# sudo find / -type f -name /home/user/fichero.c>>/home/user/x.txt

===================================================
Comando para el mantenimiento de los logs de Debian
===================================================

Los logs del sistema se almacenan en /var/log/* tiene un limite maximo, se van
guardando comprimidos y luego se van borrando automáticamente.

-----

Ver el tamaño del directorio:

# du -sh /var/log

-----

Ver el tamaño de los directorios que estan adentro:

# du -h /var/log

Los siguientes comandos eliminan los logs guardados de manera segura, no afecta
el funcionamiento del sistema:

# aptitude clean && aptitude autoclean && apt-get autoremove && apt autoremove && apt purge && apt remove

# rm -f /var/log/*.old /var/log/*.gz /var/log/apt/* /var/log/auth* /var/log/daemon*

# rm -f /var/log/debug* /var/log/dmesg* /var/log/dpkg* /var/log/kern*

# rm -f /var/log/messages* /var/log/syslog* /var/log/user* /var/log/Xorg* /var/crash/*

===========================================
Lectores/Editores de texto desde la consola
===========================================

Modificar un fichero con el editor nano.

$ nano nombre_fichero

Leer el manual del editor de textos nano, muy útil, práctico y fácil de usar.

$ man nano

Mostrar contenido de un fichero, concatenate files and print on the standard
output.

$ cat nombre_fichero.xxx

Mostrar contenido de un fichero y numerar las líneas.

$ cat -b nombre_fichero.xxx

Mostrar el contenido de un archivo, lector de ficheros, mayor movilidad que cat,
con / permite buscar dentro del fichero, como vim, q para salir.

$ less nombre_fichero.xxx

El comando tail sirve para mostrar en pantalla las últimas líneas de un archivo.

$ tail nombre_fichero.xxx

-n donde X es el número de lineas que queremos ver del fichero.

$ tail -n X nombre_fichero.xxx

-n donde X es el número caracteres desde el final, que queremos ver del fichero.

$ tail -c X nombre_fichero.xxx

Se pueden especificar 1 o más ficheros a la vez, los mostrara en el orden
declarado.

$ tail fichero_1.xxx fichero_2.xxx

Muestra el estado e información de un fichero

$ stat nombre_fichero

Muestra información de un directorio

$ stat nombre_carpeta

Donde xxx es el nombre de un fichero, nos dira el tipo de fichero que es.

$ file xxx

Ejemplo: file index.html

index.html: HTML document, UTF-8 Unicode text

Permite hacer una comparacion de dos archivos para apreciar sus diferencias se
debe especificar la ruta de ambos archivos y separarlos con un espacio, si estan
en el mismo directorio no hace falta especificar las rutas completas.

$ diff /home/user/file.html /home/user/file2.html

Cambiar extension a todos los ficheros de un directorio

En el ejemplo vamos a sustituir los .txt por .xls y le decimos que se lo haga a
todos los .txt

$ rename 's/\.txt/\.xls/' *.txt

====
Less
====

less es un visualizador de archivos de texto que funciona en intérpretes de
comando.

A diferencia de otros programas similares (como more), less permite una completa
navegación por el contenido del archivo, utilizando un mínino de recursos del
sistema.

Manual de less.

$ man less

Avanzar una página

AvPag

Retroceder una página

RePag

Tecla espacio para avanzar, como page up

space

Salir

:q

Ayuda

:h

(/) Buscamos una palabra dentro del documento

:/palabra

Para ir a la siguiente coincidencia.

(n)

Para ir a la coincidencia anterior

(N)

Ir al final del texto.

:G

Ir al inicio del texto.

:g

Invocar un editor de texto para el documento, por lo general usa vi pero puede
usar nano automaticamente.

:v

Para ir a una línea específica de un fichero.

$ less +123 filename

====================================
Ver un fichero .csv desde la consola
====================================

Ordenará por columnas, etc...

$ cat file.csv | sed -e 's/,,/, ,/g' | column -s, -t | less -#5 -N -S

===================================
Comandos para monitorear el sistema
===================================

Listar los procesos de ejecución del sistema (y más cosas) en tiempo real, es
una de las herramientas más importantes para un administrador.

$ top

Si presionamos "z" nos mostrara la salida con 2 colores, para distingir mejor la
información.

"q" o "Ctrl+c" para salirse del monitor top.

Liberar memoria ram.

# sysctl -w vm.drop_caches=3

Recargar el entorno gráfico, evitando el reinicio del pc.

# gnome-shell --replace & disown

Refrescar el escritorio gnome sin reiniciar.

Alt + F2 y escriba r y presione enter, esto para gnome3

Para refrescar el desktop en xfce.

$ xfce4-panel -r && xfwm4 --replace

Si un programa es pausado con Ctrl + z, con este comando lo reanudamos.

$ fg %1

Es otro monitor del sistema, parecido a top pero con un poco mas de herramientas
, para instalarlo # apt-get install htop.

$ htop

Es otro monitor de sistema, para instalarlo # apt-get install nmon

Si quieren ver la información relacionada con el CPU presionan la tecla "c", con
la memoria "m", del kernel "k" y discos "d".

Segun vayamos usando las letras nos va mostrando lo que escogimos, muy útil y
bonito.

$ nmon

Donde xxx es el nombre de un host al cual enviaremos paquetes y comprobaremos si
hay una conexion con ese host, util para saber si estamos conectados a internet.

$ ping xxx

Ejemplo:

Si hay conexion a internet enviara paquetes que seran recibidos, de lo contrario
dara un error.

$ ping http://www.google.com

Tiempo en segundos que se va a hacer ping donde n es un entero.

$ ping -w n ip_num

Ver si hay aceleracion grafica en la maquina, muestra unos engranajes de colores
rodando, si es así, está correcta la instalacion del video.

# glxgears

Este comando sirve para revisar el log o bitácora de los eventos ocurridos en el
sistema, cuelca todos los mensajes que han ocurrido desde el arranque del
sistema.

# journalctl

Si un servicio parece que no está funcionando como debiera, el primer paso para
resolver el problema es comprobar si el servicio está ejecutándose realmente
mediante systemctl status. Si no es así y los mensajes que se muestran no son
suficientes para diagnosticar el problema se pueden comprobar los registros que
ha recogido journald relacionados con es servicio. Por ejemplo, suponiendo que
el servidor SSH no funciona:

# systemctl status ssh.service

-f , que hace que journalctl siga mostrando los nuevos mensajes a medida que se
van emitiendo (semejante a lo que ocurre con tail -f file).

# journalctl -f

===========================
Eliminar vs vaciar ficheros
===========================

Para eliminar ficheros con el fin de liberar espacio emplearemos habitualmente
el comando rm. Sin embargo, es muy habitual que no nos podamos permitir eliminar
un fichero por estar siendo utilizado en ese momento por una aplicación, lo cual
es de lo más habitual con ficheros de log en sistemas en producción que no
pueden parar. Eliminarlos directamente puede tener consecuencias nefastas, como
el bloqueo de la propia aplicación que los está utilizando, o más leves pero
también indeseables, como que se interrumpa el volcado de datos a estos ficheros
y dejen de ser útiles.

Para no alterar el funcionamiento de una aplicación y conseguir nuestro objetivo
de liberar espacio vaciaremos los ficheros en lugar de eliminarlos:

# >/var/log/syslog

=======
Fuentes
=======

-https://www.daniloaz.com/es/los-comandos-linux-mas-utiles-para-mantener-sistemas-de-ficheros/

==============================
Gestionar procesos del sistema
==============================

Cada proceso tiene un identificador (PID) proccess ID, entonces podemos matar
ese proceso con:

 Matar un proceso donde xxxx es el identificador del proceso.

$ kill xxxx

Matar un proceso donde xxxx es el identificador del proceso.

$ kill -9 xxxx

Muestra los procesos actuales del sistema y acepta varios parametros como:

$ ps

Visualiza información sobre "todos" los procesos del sistema.

$ ps -e

Visualiza información sobre "todos" los procesos del sistema con mas detalles,
así pues se puede detener un proceso con kill -9 PID_number.

$ ps -ef

Filtrar la búsqueda, en este caso, buscando el proceso que alberga el visor pdf
evince.

$ ps -ef | grep evince

Filtrar la búsqueda para ver las conexiones ssh activas, nuevamente se aclara
que podemos matar esos procesos con kill -9 xxx pasandole el PID process.

$ ps -ef | grep ssh

Saber el tiempo que lleva ejecutandose un proceso.

$ ps -p xxxx -o etime

Muestra los procesos del sistema de sistema, similar a ps -ef.

$ ps aux

Mostrar información de proceso/s específico/s.

$ ps aux | grep firefox

Muestra algunos detalles de los procesos del sistema.

$ ps -l

Muestra mas detalles de los procesos del sistema.

$ ps l

========================
Driver de wifi en laptop
========================

# apt install firmware-iwlwifi

# apt-get install firmware-b43-installer

# apt-get install firmware-linux firmware-linux-free firmware-linux-nonfree firmware-misc-nonfree firmware-realtek

=====================================
Reiniciar la interfaz de red en Linux
=====================================

Luego de algun cambio en el archivo etc/network/interfaces se debe reiniciar
el servicio networking con el siguiente comando:

$ sudo systemctl restart networking

============================================================================
Restaurar o reiniciar las conexiones de red del sistema - networking restart
============================================================================

# /etc/init.d/networking restart

# service networking restart

# invoke-rc.d networking restart

=======================
Para maquinas virtuales
=======================

Cuando se va a conectar por wireless, para que el dhcp le asigne una dirección
ip modificamos el fichero:

/etc/network/interfaces

Y quedará así:

# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

source /etc/network/interfaces.d/*

# The loopback network interface
#auto lo
#iface lo inet loopback
auto eth0
iface eth0 inet dhcp

---

Guardamos y reiniciamos las interfaces de redes con los tres comandos de arriba,
esto es para cuando una máquina virtual no agarra internet inalambrico, tambien
debe estar habilitada el adaptador de conexión inalambrica en el panel de
configuración de la maquina virtual. Dentro de la máquina virtual parecerá que
esta conectado por cable.# The loopback network interface

Cuando se instala el SO y no consigue ninguna red cableada, es posible que el
router/DHCP no le haya asignado una dirección ip, entonces modificamos el mismo
fichero para que quede así:

auto lo
iface lo inet loopback
auto eth0
iface eth0 inet dhcp

Y reiniciamos las interfaces de red, con suerte obtendremos una dirección ip de
la red.

Podemos intentar un ifup para ver si el dhcp le asigna la dirección ip sin
necesidad de reiniciar la maquina o las interfaces de red:

# ifup eth0

Luego # ip addr a ver si ya tiene ip, si no es así entonces reiniciaremos las
conexiones de red del sistema con los comandos descritos arriba.

Si lo demás no a servido, se puede editar el /etc/resolv.conf de la máquina
virtual a ver si hagarra internet, a veces el dhcp le asigna ip pero no tiene
conexión a internet, entonces:

# sudo nano /etc/resolv.conf

Agregamos las siguientes líneas:

nameserver 8.8.8.8
nameserver 8.8.4.4

Guardamos el archivo y hacemos ping a ver si ya envía paquetes a google:

Lo que vamos a hacer es enviar paquetes a los servidores de Google para
comprobar si nos responde su ip pública es 8.8.8.8

$ ping 8.8.8.8

===================================================================
Restaurar o reiniciar las conexiones de red inalambrica del sistema
===================================================================

If you really want to reset the network adapter you usually need to unload and
reload the kernel module that it uses.

If you just want to reconfigure it you can usually do:

# /etc/init.d/network-manager restart

But if you just want a new dhcp lease (that's the technical name for obtain a
new IP from the router), you just need to use:

# dhclient -v eth1

===================
Herramientas de red
===================

Permite desplegar numerosos parámetros de las interfaces de red residentes  en
el núcleo, como la dirección ip (dinámica o estática), o la máscara de red entre
otros.

# ifconfig

Para ver el estatus de las conexiones de red, este comando le mostrará su
dirección ip, el tipo de conexión que está utilizando, etc.

$ ip addr

====
nmap
====

Nmap es una poderosa herramienta de exploración de redes que te permite
descubrir hosts y servicios, así como realizar análisis de seguridad en una red.

1- Instalar Nmap:

sudo apt install nmap

2- Ejecutar Nmap:

Una vez que Nmap esté instalado, puedes comenzar a ejecutar comandos. Aquí
tienes algunos ejemplos básicos:

Escaneo de un solo host:

$ sudo nmap <dirección IP>

Reemplaza <dirección IP> por la dirección IP del host que deseas escanear.

Ejemplo:

$ sudo nmap 192.168.12.82
[sudo] password for user:
Starting Nmap 7.80 ( https://nmap.org ) at 2023-06-01 12:05 -04
Nmap scan report for 192.168.12.82
Host is up (0.0000060s latency).
Not shown: 998 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http

Nmap done: 1 IP address (1 host up) scanned in 0.13 seconds

-----

Escaneo de un rango de direcciones IP:

$ sudo nmap <rango de direcciones IP>

Reemplaza <rango de direcciones IP> por el rango que deseas escanear, por

Ejemplo:

$ sudo nmap 192.168.12.1-100

Esto te dara los detalles de los dispositivos conectados a la red en el rango
establecido, con los detalles como en el primer comando de ejemplo

-----

Escaneo de una red completa:

$ sudo nmap <dirección de red/máscara>

Reemplaza <dirección de red/máscara> por la dirección de red y la máscara de
subred que deseas escanear, por ejemplo, 192.168.0.0/24.

Ejemplo:

$ sudo nmap 192.168.12.0/24

Esto te dara los detalles de los dispositivos conectados a la red, con los
detalles como en el primer comando de ejemplo

Estos son solo ejemplos básicos, y Nmap ofrece muchas opciones y funcionalidades
avanzadas. Puedes explorar la documentación oficial de Nmap para aprender más
sobre los comandos y las opciones disponibles.

-----

Ver que puertos de la pc que estan escuchando:

$ sudo nmap -sT -O localhost

Fuente
======

ChatGPT

========
Iproute2
========

Iproute2 es un paquete de herramientas muy potentes para administrar interfaces
de red y conexiones en sistemas Linux.

Este paquete reemplaza completamente las funcionalidades presentes en ifconfig,
ya que este no viene instalado por defecto en GNU/Linux Debian 9 Stretch, ya que
a ifconfig se le considera obsoleto.

=====================================
Instalar ifconfig y route en Debian 9
=====================================

Lo primero que tenemos que hacer es abrir un terminal e instalar el paquete
“net-tools”. Si en la instalación hemos elegido hacer “sudo” para ascender a
superusuario para instalar paquetes, tecleamos:

# apt-get  install net-tools

==============================================
Comparación de comandos de entre ifconfig e IP
==============================================

Mostrar dispositivos de red y su configuración.

# ifconfig

$ ip addr show

ó

$ ip link show

Activar una interfaz de red.

$ ifconfig eth0 up

$ ip link set eth0 up

Desactivar una interfaz de red.

$ ifconfig eth0 down

$ ip link set eth0 down

Establecer una dirección IP a una interfaz.

$ ifconfig eth0 192.168.1.1

$ ip address add 192.168.1.1 dev eth0

Eliminar una dirección IP de una interfaz.

ifconfig no podrá hacer esto.

$ ip address del 192.168.1.1 dev eth0

Añadir una interfaz virtual.

$ ifconfig eth0:1 10.0.0.1/8

$ ip addr add 10.0.0.1/8 dev eth0 label eth0:1

Para configurar una tarjeta de red física, por ejemplo, con ifconfig debemos
teclear lo siguiente:

$ ifconfig eth0 192.168.0.2 netmask 255.255.255.0

$ ip addr add 192.168.0.2/24 dev eth0

==============================
Gestionar usuarios del sistema
==============================

Conectarse como otro usuario creado

$ su nombre_de_usuario

Como root, Agregar un usuario nuevo al sistema, una nueva sesion, nos pedira
agregar el nombre de usuario y asignarle contraseña, la clave de root es la
misma para todas las sesiones.

$ adduser nombre_de_usuario

Como root, eliminar el usuario creado

$ userdel -r nombre_usuario

Otra forma de eliminar un usuario creado

$ deluser --remove-home nombre_usuario

====================================
Comandos para escribir en un fichero
====================================

Escribir una cadena de texto al final de un fichero.

$ echo "Texto al final del archivo" >> archivo.txt

Insertar una cadena de texto "xxxxx" al principio de un fichero.

$ sed -i '1i xxxxx' archivo.txt

Insertar una cadena al final del fichero, funciona como el método echo.

$ sed -i '$a xxx' archivo.txt

Huevo de pascua, muestra una vaca.

$ apt-get moo

============================================
Comandos para copiar, mover, eliminar, otros
============================================

Copiar un fichero o carpeta

$ cp

-----

Copiar un fichero o carpeta

$ cp -r

-----

Copiar un fichero en un directorio se debe estar situado en la carpeta del
archivo a copiar

$ cp Nombre_de_archivo.txt /Carpeta/destino/a/copiar

-----

Copiar un directorio en otro, se debe estar situado en la carpeta de la
carpeta a copiar.

$ cp Nombre_carpeta -r /Carpeta/destino/a/copiar

-----

Saber la ruta de un directorio: Desde el explorador de archivar (nautilus) desde
cualquier directorio sin importar el nivel donde estemos, tecleamos Ctrl + l
esto nos dirá la ruta completa hasta el directorio.

-----

Se pueden copiar archivos o carpetas especificando las rutas completas, en este
caso la primera ruta es el directorio o archivo a copiar y la segunda es la ruta
donde se va a pegar lo copiado, ambas rutas separadas por un espacio en blanco.

$ cp -r /home/usuario/carpeta1/ /home/usuario/carpeta2/

Ambas carpetas estan en el mismo directorio donde estamos situados, por lo tanto
no hay que especificar las rutas completas de las carpetas involucradas.

-----

Hacer una copia de un fichero y cambiarle el nombre.

$ cp nombre_fichero.xxx nombre_fichero2.xxx

-----

Hacer una copia de un directorio y cambiarle el nombre.

$ cp -r carpeta1 carpeta2

-----

Mover un fichero o carpeta y/o cambiar su nombre.

$ mv

-----

Mover una carpeta o archivo especificando el directorio de salida y el de
llegada, si estan en el mismo directorio no hace falta poner las rutas
completas.

$ mv /home/carpeta/archivo1.txt /home/carpeta2/

-----

Renombrar un archivo o carpeta.

$ mv archivo1.txt archivo2.txt

-----

Borrar una carpeta.

$ rmdir nombre_carpeta

-----

Borrar un fichero.

$ rm nombre_fichero

-----

Borrar varios ficheros.

$ rm fichero1 fichero2 fichero3

-----

Para borrar una carpeta, se le da la ruta del directorio a borrar.

$ rm -r /directorio

-----

Borrar todos el contenido de una carpeta, se debe estar dentro del directorio.

$ rm *

-----

Borrar todo el contenido de una carpeta, incluyendo las carpetas de ese
directorio se debe estar dentro del directorio

$ rm -r *

-----

rm: Comando "remove", eliminar. -rf: r de "recursivo" donde se borra todo y f de
"force"; nunca solicita confirmación. /xxx/xxx indica la ruta de los ficehros o
carpetas a borrar.

$ sudo rm -rf /xxx/xxxx

-----

Borrar todos los elementos de un directorio exeptuando lo que está entre "",
donde try es un directorio pero también puede ser un fichero, "x.txt" por
ejemplo.

$ rm -r !("try")

-----

Pedir contraseña root, algunas versiones basadas en Debian.

$ sudo -i

-----

Pedir contraseña del root.

$ su

-----

Para salir del root, tambien exit, funciona en algunas consolas como python,
ruby, entre otras.

root@debian:/home/user# Ctrl + d

-----

En la consola, para hacer una busqueda de comandos usados baasndose en la
palabra que se introduzca.

Ctrl + r

-----

Moverse a traves de los logs de la consola, simula el scroll up/down del mouse.

Shift + Page up <--> Page down


Borrar y purgar un paquete con todos sus archivos y configuraciones

# apt-get --purge remove nombre-paquete

=======================
Ip pública e Ip privada
=======================

==========
Ip Pública
==========

Es la que tiene asignada cualquier equipo o dispositivo conectado de forma
directa a Internet.

Algunos ejemplos son: los servidores que alojan sitios web como Google, los
router o modems que dan a acceso a Internet, otros elementos de hardware que
forman parte de su infraestructura, etc.

Las Ip públicas son siempre únicas. No se pueden repetir. Dos equipos con IP de
ese tipo pueden conectarse directamente entre sí. Por ejemplo, tu router con un
servidor web. O dos servidores web entre sí.

==========
Ip Privada
==========

Se utiliza para identificar equipos o dispositivos dentro de una red doméstica o
privada. En general, en redes que no sean la propia Internet y utilicen su mismo
protocolo (el mismo "idioma" de comunicación).

Las Ip privadas están en cierto modo aisladas de las públicas. Se reservan para
ellas determinados rangos de direcciones. Son estos:

Estas Ip deben ser únicas dentro de una misma red. Cada equipo o dispositivo ha
de tener la suya, distinta de la de los demás. De lo contrario habría problemas.
Sería como si dos vecinos tuvieran el mismo nombre y la misma dirección física.
El cartero nunca sabría a quién corresponde la carta que les envíen.

Las Ip privadas sí pueden repetirse en redes distintas (como en la tuya y la de
una empresa). Los equipos o dispositivos con esas IP pueden conectarse entre sí
SÓLO dentro de la red a que pertenecen. No hay conflictos porque las redes están
separadas. Igual que no los hay entre dos direcciones físicas iguales de
ciudades distintas.

===================
Saber la ip pública
===================

Una forma de averigar esa ip pública es haciendo uso del comando curl. Si no
tenéis instalado el paquete habrá que instalarlo.

$ sudo apt-get install curl

Nos mostrará nuestra ip pública.

$ curl ifconfig.me

-----

Saber más datos de mi ISP y mí ip pública

$ curl ipinfo.io

{
  "ip": "186.10.126.11",
  "hostname": "186-10-126-11.genericrev.cantv.net",
  "city": "Caracas",
  "region": "Caracas",
  "country": "VE",
  "loc": "8.5792,-75.1571",
  "org": "AS5748 CANTV Servicios, Venezuela",
  "timezone": "America/Caracas",
  "readme": "https://ipinfo.io/missingauth"
}

-----

Desmontar un dispositivo, pendrive, disco externo etc.

$ user@debian:/media$ umount nombre_device

Muestra usuarios conectados a nuestra máquina, tambien usado para ver las
conexiones entrantes de un servidor

$ who

Ejemplo:
user tty7         2015-07-28 08:47 (:0)
user pts/0        2015-07-30 14:03 (:0.0)
user pts/1        2015-07-30 17:03 (:0.0)
user pts/2        2015-07-31 14:15 (:0.0)
user pts/3        2015-07-31 12:37 (:0.0)

En este caso son los usuarios conectados a mi máquina, eso quiere decir que
tengo shells abiertos, por lo tanto todos son representados como usuarios, entre
los diversos parametros se puede apreciar la fecha y la hora en que se abrio el
shell, en un servidor seria el momento en que se conecto el usuario
 
Muestra que usuario soy, nombre de usuario.

$ whoami

Nos dira cual usuario somos, si navegamos por los shells abiertos y ejecutamos
el comando nos dira cual usuario es

$ who am i

Ver usuarios conectados

$ who -u

Ejemplo:

user tty7         2015-07-28 08:47  antig       4257 (:0)
user pts/0        2015-07-30 14:03 03:22        8351 (:0.0)
user pts/1        2015-07-30 17:03 03:19        8351 (:0.0)
user pts/2        2015-07-31 14:15 00:08        8351 (:0.0)
user pts/3        2015-07-31 12:37 02:53        8351 (:192.168.0.240)

Aqui observamos que hay una conexion externa a traves de ssh a nuestro servidor
proveniente de la maquina (192.168.0.240) demarcada por el id process 8351 la
cual podemos cancelar con $ kill -9 8351, pero no refusar esa conexion, el
usuario seguirá conectado por ssh.

Acabar con una conexión externa, se envió la señal -9 que indica matar (KILL) el
proceso, la opción -t indica que se basará en un atributo de nombre de terminal
y se indica después el nombre de la terminal en si pts/3. Este es el comando que
sí funciona para  refusar o eliminar conexiones externas. A veces pide su.

$ pkill -9 -t pts/3

Listar los ultimos usuarios conectados

$ last

==================================
Cambiar el pass del usuario y root
==================================

========================
Usuario normal o regular
========================

$ passwd

Nos mostrara lo siguiente:

Cambiando la contraseña de user.
(actual) contraseña de UNIX:******
Introduzca la nueva contraseña de UNIX:*****
Vuelva a escribir la nueva contraseña de UNIX:*****

============
Usuario root
============

Primero nos logeamos como root:

$ su

Luego lo mismo de arriba:

# passwd

Nos pedira que introduzcamos la nueva contraseña y la confirmacion para cambiar
la clave de root

Introduzca la nueva contraseña de UNIX:****** 
Vuelva a escribir la nueva contraseña de UNIX:*****
passwd: contraseña actualizada correctamente

======================================================
Instalacion de programas y paquetes con apt y aptitude
======================================================

 Ver el manual de aptitude.

$ man aptitude

Ver el manual de apt-get.

$ man apt-get

Instalar paquetes.

# apt-get install Nombre_Paquete

Actualizar un paquete unicamente.

# apt-get install --only-upgrade packagename

Instalar paquetes disponibles desde otro repositorio, en este caso, los de
jessie-backports.

# apt-get install -t jessie-backports Nombre_Paquete

Instalar paquetes, otra forma usando el programa aptitude

# aptitude install Nombre_Paquete

Intentará satisfacer las dependencias de compilación de un paquete fuente, el
comando build-dep busca en los repositorios locales en el sistema e instala las
dependencias de construcción para el paquete. Si el paquete no existe en el
repositorio local se devolverá un código de error.

# apt-get build-dep Nombre_Paquete

Hace una simulacion de la instalacion, podemos ver que procesos haría la
instalación.

$ aptitude install -s Nombre_Paquete

 Simulacion de instalacion con  apt-get install.

# apt-get install -s Nombre_Paquete

El -y Supone una respuesta afirmativa a todas las preguntas, de esta forma
apt-get se ejecuta sin necesidad de intervención posterior para tomar
decisiones, usar con cuidado.

# apt-get install -y package

Descargar las fuentes del paquete, para compilar e instalar.

$ apt-get source Nombre_paquete

Realizar una busqueda en los repositorios del paquete que se quiere encontrar

$ sudo aptitude search Nombre_Paquete

Para ver la informacion del paquete, version, estado, tamaño, conflictos,
dependencias, etc.

$ aptitude show Nombre_Paguete

 Ver informacion del paquete, version, dependencias, descripcion, tamaño, entre
 otros.

$ apt-cache show nombre_paquete

 Buscar un paquete en los repositorios.

$ apt-cache search nombre_paquete

Muestra las versiones de los paquetes listados en la línea de órdenes.

$ aptitude versions nombre_paquete

Elimina o Desinstala el paquete.

# aptitude remove Nombre_paquete

Elimina el paquete y sus archivos de configuracion.

# aptitude purge Nombre_Paquete

Descarga el fichero .deb del paquete dado al directorio actual.

$ aptitude download nombre_paquete

Descarga el fichero .deb del paquete dado al directorio actual.

$ apt-get download nombre_paquete

Reinstalar un paquete

# aptitude reinstall nombre_paquete

Actualizar la lista de paquetes disponibles.

$ aptitude update

Saber si un paquete está instalado y su version.

$ dpkg -l | grep nombre_paquete

Borra los paquetes huérfanos, o las dependencias que quedan instaladas después
de haber instalado una aplicación y luego eliminarla, por lo que ya no son
necesarias.

# apt-get autoremove

Saber la version de algun paquete que tengamos instalado.

$ xxx --version

Ejemplo:
bash --version
gcc --version
python --version
ruby --version

=========================
Liberando espacio con apt
=========================

APT (Advanced Packaging Tool) Herramienta Avanzada de Empaquetado es un sistema
gestor de paquetes creado por el proyecto Debian. Esta herramienta se encarga de
facilitarle al usuario las tareas de instalación y eliminación de programas en
los sistemas GNU/Linux (distribuciones derivadas de Debian).

Esta herramienta se compone de dos programas principalmente: apt-get y
apt-cache, para estos programas podemos encontrar programas frontend, me refiero
a programas con una interfaz gráfica que facilita el uso de apt como es
Aptitude, Synaptic, Adept, Ubuntu Software Center, etc.

Apt instala paquetes .deb para los sistemas debian y distribuciones derivadas,
instalar un programa con esta herramienta es tan sencillo como escribir:

$ apt-get install <nombre_del_programa>

Donde <nombre_del_programa> lo sustituimos por el nombre del programa que
deseamos instalar.

Si queremos por ejemplo instalar GIMP, un programa para la manipulación de
imágenes, se haría de la siguiente manera:

$ apt-get install gimp

================================
Comprobando el espacio utilizado
================================

Los archivos .deb que apt-get descarga de los repositorios, son almacenados en
nuestra máquina antes de comenzar el proceso de instalación, y a veces hace
falta hacer limpieza de estos archivos (ojo, al realizar los siguientes 3 pasos
para liberar espacio, liberaremos espacio sin desinstalar programas, solo
borraremos los instaladores, caché de .deb almacenados localmente); Los archivos
son almacenados en la siguiente ruta cuando van a ser instalados
/var/cache/apt/archives podemos ver cuánto espacio están utilizando estos
archivos en nuestro disco con:

$ du -hs /var/cache/apt/archives

du es un comando que nos permite ver el Disk Usage (espacio utilizado en disco).
3 Pasos para liberar espacio

1- Para liberar el espacio primero haremos un autoclean, esta opción borra todo
el caché de los paquetes .deb de paquetes de versiones anteriores y de los
programas que ya han sido instalados en nuestro sistema:

$ sudo apt-get autoclean

2- El siguiente comando con la opción clean borra todos los paquetes .deb, si
queremos instalar de nuevo un programa el archivo .deb necesitará ser descargado
nuevamente de los repos:

$ sudo apt-get clean

3- Por último el siguiente comando con la opción autoremove borra todos los
paquetes dependencias de otros programas:

$ sudo apt-get autoremove

Comprobando el espacio libre nuevamente

Ahora que hemos liberado el espacio, podemos comprobar nuevamente el tamaño de
la carpeta que apt usa para almacenar todos los archivos como caché:

$ du -hs /var/cache/apt/archives

===============================
Comprimir/Descomprimir archivos
===============================

tar se refiere a un formato de archivos ampliamente usado en entornos UNIX
identificados por el sufijo de archivo .tar.. Además hace referencia al programa
para la manipulación de archivos que es estándar en estos entornos, pero no
incluye la compresión de los mismos.

Comprimir un directorio, le damos los parametros de compresion, así como el
nombre del paquete y el directorio que vamos a comprimir.

$ tar -cvf paquete.tar nombre_directorio 

-c : indica a tar que cree un archivo
-x : extraer un archivo
-t : listar los contenidos de un archivo
-v : indica a tar que muestre lo que va empaquetando.
-f : indica a tar que el siguiente argumento es el nombre del fichero.tar
-z : comprimir a la vez que se empaqueta

Crear un paquete con el nombre que le dimos y contiene el archivo.txt

$ tar -cvf paquete.tar archivo.txt

Descomprimir un paquete

$ tar -xvf paquete.tar

=============================
Descomprimir paquetes.tar.bz2
=============================

$ tar -xjvf example.tar.bz2

=================
Ficheros .tar.gz
=================

Comprimir un directorio

$ tar -czvf paquete.tar.gz nombre_directorio

Comprimir un fichero

$ tar -czvf paquete.tar.gz nombre_fichero.xxx

Descomprimir

$ tar -xzvf paquete.tar.gz

============
Ficheros .gz
============

Comprimir

$ gzip -9 ficehro.txt

Descomprimir

$ gzip -d fichero.gz

====================
Descomprimir .tar.xz
====================

$ tar Jxvf fichero.tar.xz

-------------

Cuando nos iniciamos en Linux y buscamos un programa lo normal es que
encontremos un .deb o .rpm y en muchos casos nos encontramos programas con la
extensión .tar.gz y .tar.bz2, estos archivos están comprimidos y por lo general
contienen aparte del programa unas instrucciones para instalarlo.

La instalación para estos dos tipos de paquetes es exactamente igual, primero
entramos a la carpeta donde tengamos el archivo.

$ cd directorio

$ tar -zxvf nombredelarchivo.tar.gz

$ tar -jxvf nombredelarchivo.tar.bz2

Configuramos, con esta accion se configurara el paquete para la posterior
compilacion, si hacen falta paquetes "dependencias" para la compilacion por lo
general mostrara que paquetes faltan y fallará la configuracion.

$ ./configure

Hacemos make (compilamos)

$ make

Ahora make install

$ make install

====================
Descomprimir con RAR
====================

Necesitamos instalar unrar.

$ aptitude search unrar

Si no lo encuentra debemos bajar el source de http://www.unrarlib.org/ Nos
bajara unrarsrc-3.7.8.tar.gz

Descomprimimos, nos dejara la carpeta (unrar)

$ cd unrar

luego:

$ make -f makefile.unix

# install -v -m755 unrar /usr/bin

Ya deberíamos poder descomprimir .rar

Uso: unrar [OPTION...] ARCHIVE [FILE...] [DESTINATION]
-x, --extract              Extract files from archive (default)
-t, --list                 List files in archive
-f, --force                Overwrite files when extracting
--extract-newer        Only extract newer files from the archive
--extract-no-paths     Don't create directories while extracting
-p, --password             Decrypt archive using a password
-?, --help                 Give this help list
--usage                Give a short usage message
-V, --version              Print program version

Ejemplo:

Para descomprimir un fichero .rar.

$ unrar x archivo.rar

Para descomprimir un fichero .rar dando la ruta.

$ unrar x archivo.rar /home/user/carpeta

===============================
Comprimir/ Descomprimir con ZIP
===============================

Instalar el paquete de zip.

$ sudo aptitude install zip

Comprimir un fichero.

$ zip archivo.zip nombre_fichero.xxx

Descomprimir el fichero.

$ unzip archivo.zip

Comprimir directorios y su contenido.

$ zip -r carpeta.zip nombre_carpeta

===================================================================
Proteger un archivo ZIP con contraseña mediante la línea de comando
===================================================================

$ zip -er nombre-archivo.zip carpeta-a-comprimir

===================
Terminal Terminator
===================

Gran herramienta para los desarrolladores, permite abrir multiples terminales
y poder ordenarlos, muy personalizable, entre muchas otras cosas.
**RECOMENDADO**.

Paquete: terminator / multiple GNOME terminals in one window.

Para instalarlo

# apt-get install terminator

Dentro de Terminator:

Abrir un terminal horizontal y paralelo

Ctrl + Shift + o

Abrir un terminal vertical y paralelo

Ctrl + Shift + e

Abrir una nueva pestaña en el terminal

Ctrl + Shift + t

Moverse por los terminales

Alt + flechas

Cerrar un terminal

Ctrl + Shift + w

Maximizar un terminal, igual para salir

Ctrl + Shift + x

Maximizar un terminal(aumentado), igual para salir

Ctrl + Shift + z

Cambiar el tamaño a voluntad de un terminal

Ctrl + Shift + flechas

Aumentar tamaño de fuente, el (+) del Qwerty

Ctrl + (+)

Minimizar tamaño de fuente, el (-) del Qwerty

Ctrl + (-)

Si no hay sesion de usuario abierta, como root y otros cerrará la pestaña o
ventana.

Ctrl + d

Pantalla completa.

f11

=========================
DIA - Editor de diagramas
=========================

Es un editor de diagramas, grafos, gráficas, etc. Ofrece soporte para diagramas
de estructuras estáticas en UML (diagramas de clases), diagramas de
Entidad-Relación, diagramas de redes y mucho más.

Los diagramas se pueden exportar a postscript y a otros formatos.

$ aptitude install dia

====
Meld
====

Es una herramienta gráfica para hacer archivos diff y fusionarlos.

Permite al usuario ver los cambios entre, y fusionar, dos archivos, dos
directorios, o dos archivos con un ancestro común.

# apt install meld

========================
Editor de texto VI o VIM
========================

Es un editor de texto poderoso, muy usado en la comunidad de desarrolladores de
Software Libre para escribir scripts, modificar ficheros de texto en el shell,
programar etc. No posee botones y todas sus funcionalidades se usan a traves de
comandos.

Por lo general viene preinstalado en la mayoria de distribuciones, si no es así
solo basta con un:

# apt-get install vim

============
Modos de uso
============

Al entrar a VIM para editar un fichero por primera vez, estamos en modo de
comandos, quiere decir que no podemos editar el texto sino que solo podremos
sar comandos.

Abrir vim, un fichero en blanco sin nombre ni contenido.

$ vim

Tecleamos i para entrar en modo de edicion, podemos insertar texto.

i

Pulsamos la tecla escape para salir del modo edicion o de cualquier otro modo,
y volvemos al modo comandos.

escape

En modo comandos escribimos :q para salir del editor sin guardar.

:q

Salir del editor sin guardar ni pedir confirmacion.

:q!

Guardamos un fichero nuevo, le asignamos el nombre y la extension si es
necesario.

:w nombre_fichero.xxx

Nos aparecerá una ventana en negro, donde nos aparecerá el contenido del fichero
o en negro si está vacío.

En la parte inferior, nos aparecerán los mensajes o comandos que escribamos
para manejar el editor, así como la línea en la que estamos, porcentaje del
fichero, etc.

vim nombre_archivo.xxx

Guardar un documento.

:w

Guardar y salir, esta accion aplica a un fichero ya creado, que estemos
editando.

:wq!

Para saber el nombre y extensión del fichero abierto.

:f

Deshacer el ultimo cambio.

u

Rehacer el ultimo cambio.

Ctrl + R

Copiar la linea.

yy

Eliminar una linea, en tal caso la corta y esta lista para pegarse.

dd

Pegar una linea cortada.

p

Convertir la linea actual en minusculas.

guu

Convertir la linea actual en mayusculas.

gUU

Ir al principio del archivo.

g

Ir al final del documento.

G

Navegar palabra por palabra en el fichero.

w

Entra en modo Visual. En este modo seleccionaremos un texto con los cursores, y
después podremos cortar, copiar y pegar con los comandos:  

Copiar: y

Copiar el texto seleccionado en modo visual (de "yank".)

Cortar: c

Cortar el texto seleccionado en modo visual.

Pegar: p

Pegar el texto copiado o cortar en modo visual con anterioridad. 

v

Para hacer una busqueda de una palabra dentro del archivo.

:/palabra

Para ir a la siguiente coincidencia.

n

Para ir a la coincidencia anterior.

N

Enumerar las líneas del fichéro.

:set nu

Si queremos que se enumeren siempre las lineas editamos el fichero:

# vim /etc/vim/vimrc

y quitámos las comillas (") a la línea que tiene a set number y guardamos.

Ir a la linea (x) donde 123 es el número de linea a la cual queremos ir.

:123

Sirve para dar color al codigo que estemos editando, VIM reconoce la sintaxis de
muchos lenguajes y la resalta en colores como muchos otros editores graficos
como gedit, sublime, ninja, komodo, Geany.

:syntax on

Quitamos las (") para que quede activado directamente la coloracion de codigos

En /etc/vim en el fichero vimrc descomentamos la linea "syntax on

===============================
Configurar el localhost / hosts
===============================

En el fichero /etc/hosts está configurado el localhost de la máquina, el
contenido puede ser parecido a:

---

127.0.0.1      localhost
127.0.1.1       debian8.debian8 debian8

---

Esto quiere decir que cuando accedamos desde el navegador a "localhost"
entonces estaremos accediento a 127.0.0.1.

Para hacer una prueba agregaremos y comentaremos una línea al fichero:

---

#127.0.0.1      localhost
127.0.1.1       debian8.debian8 debian8
127.0.0.1        www.x.x

---

Lo que hicimos es cambiar localhost por una url arbitraria, ahora si accedemos a
www.x.x accederemos a 127.0.0.1

===========================================
Bloquear acceso localmente a una página web
===========================================

$ ping www.pagina_a_bloquear.com

Eso va a hacer ping o enviar paquetes a esa web y nos mostrara la ip pública del
sitio, es decir un número con este formato: 111.222.333.444

Ahora, con esa ip hacemos lo siguiente:

Para bloquear el acceso a esa página

# iptables -I INPUT -s 111.222.333.444 -j DROP

Para habilitar el acceso a esa página

# iptables -I INPUT -s 111.222.333.444 -j ACCEPT

==========
Otra forma
==========

Para bloquear sitios vamos a modificar el archivo hosts, abrimos un terminal y
escribimos la siguiente linea de comando:

Como super usuario abrimos el fichero /etc/hosts con el editor gedit, puede ser
nano vi, vim, u otro.

# gedit /etc/hosts

Ahora para bloquear en este ejemplo a Instagram, vamos a escribir al principio
del archivo:

127.0.0.1 instagram.com
127.0.0.1 www.instagram.com

Guardamos y listo.

======================================================
Bloquear acceso localmente a una página web en Windows
======================================================

Probado en 7

Editamos con el blog de notas el fichero que está en:

C:\Windows\system32\drivers\etc\hosts

Nos encontraremos con algo como esto:

127.0.0.1       localhost
127.0.0.1       localhost
127.0.0.1       localhost

Para bloquear una página, solamente agregamos un par de lineas al final del
fichero Por ejemplo, vamos a bloquear a instagram, entonces quedaría así:

127.0.0.1       localhost
127.0.0.1       www.instagram.com
127.0.0.1       instagram.com

Guardamos y listo, podemos agregar tantas webs como queramos.

====================================
Generar certificado ssl auto-firmado
====================================

Para establecer una conexión segura y de confianza es necesario generar
certificados que respalden la identidad del servidor. Estos certificados son
generalmente emitidos por entidades certificadoras (Certificate Authority)
independientes y de confianza reconocida. Sin embargo, para una utilización más
casera y económica, es posible crear un certificado "auto-firmado".

Hay que configurar el sitio a proteger en /etc/hosts, esto es opcional muy
específico e independiente del manual que continúa.

=====================
Instalar dependencias
=====================

# aptitude install openssl ca-certificates

Generar la clave RSA

$ openssl genrsa -des3 -out x.gob.ve.key 1024

ó 2048

Generar CSR (Petición de Firma de Certificado)

$ openssl req -new -key x.gob.ve.key -out x.gob.ve.csr

Esto realiza una petición para la firma con la clave privada especificada al
realizarlo nos pide algunos datos que tendrá el certificado algunos los podemos
omitir.

El "Common Name" que nos pide debe corresponder con la URL que queremos
Securizar. Si la URL a poner por https es x.gob.ve, este campo debe contener
exactamente eso.

Generar Certificado Autofirmado

$ openssl x509 -req -days 365 -in x.gob.ve.csr -signkey x.gob.ve.key -out x.gob.ve.crt

Al final nos Deben quedar 3 ficheros: .cert, .crs, .key
x.gob.ve.crt ***Este es el certificado final***
x.gob.ve.csr
x.gob.ve.key

======================================================================
Generar un certificado electrónico autofirmado en formato PKCS#12 .p12
======================================================================

El certificado en formato PKCS#12 es un archivo de almacén de clave que incluye
certificado(s), y clave privada(s) cifradas por una contraseña (frase de paso)
elegida por el usuario. El certificado autofirmado no es emitido por alguna
autoridad o proveedor de servicio de certificado, si no que puede ser construido
y avalado por una misma persona.

1) Instalación de la librería OPENSSL.

$ sudo aptitude install openssl

2) Crear una clave privada y pública RSA. El RSA es un algoritmo criptográfico
para la generación de claves utilizadas en firmas electrónicas. Para generar las
claves RSA se ejecuta el siguiente comando:

$ openssl genrsa -out localhost.key

La ejecución del comando anterior genera la clave privada y la almacena en un
archivo llamado localhost.key en el directorio donde se ejecutó el comando
(verificar la existencia del archivo).

3) Crear un certificado autofirmado con el estándar x509. El estándar X509
esencialmente se usa para la verificación de emisión de certificado dentro de la
jerarquía de autoridades certificantes. Para este ejemplo no se requiere
verificar que autoridades lo emitieron porque es un certificado autofirmado,
pero se necesita que dicho certificado este bajo ese estándar.

Para crear este certificado se ejecuta el siguiente comando:

$ openssl req -new -x509 -days 1825 -key localhost.key -out localhost.crt

Donde se indica que genere un nuevo certificado (openssl req -new) con los
siguientes parámetros:

-Estándar: ( -x509 )

-Días de duración del certificado:( -days 1825 )

-Clave privada, nombre del archivo donde esta almacenado: ( -key localhost.key )

-Nombre del archivo donde se almacenara el certificado:( -out localhost.crt )

Al ejecutar el comando se solicita la información que contendrá el certificado:

-Country Name (2 letter code) [AU]:
-State or Province Name (full name) [Some-State]:
-Locality Name (eg, city):
-Organization Name (eg, company) [Internet Widgits Pty Ltd]:
-Organizational Unit Name (eg, section):
-Common Name (e.g. server FQDN or YOUR name):
-Email Address:

La ejecución del comando anterior genera el certificado asociado a la clave
indicada y con información ingresada al momento de su generación.

El certificado se guarda en el archivo con el nombre localhost.crt en el
directorio donde se ejecutó el comando (verificar la existencia del archivo).

4) Crear un certificado en formato PKCS#12: Como ya se tiene la clave privada y
el certificado asociado a dicha clave (generada en las secciones anteriores), se
procede a generar un certificado en formato PKCS#12 ejecutando el siguiente
comando:

$ openssl pkcs12 -export -inkey localhost.key -in localhost.crt -out localhost.p12

Donde se le indica que exporte ( -export ) los siguientes parámetros:

-La clave privada ( -inkey localhost.key )
-Certificado autofirmado ( -in localhost.crt ) asociado a la clave privada
-Nombre del archivo donde se almacena el certificado ( -out localhost.p12 )

La ejecución del comando anterior solicita que ingresa una contraseña (frase de
paso), luego se genera el certificado en formato PKCS#12 y se guarda en el
archivo con el nombre localhost.p12 el directorio donde ejecuto el comando
(verificar la existencia del archivo).

Con todos estos pasos ya se dispone de un certificado autofirmado en formato
PKCS#12 almacenado en el archivo localhost.p12. Al hacer doble clic sobre el
archivo localhost.p12 se levanta una ventana solicitando la contraseña o frase
de paso para poder acceder a la información. Al ingresar la contraseña o frase
de paso mostrara toda la información referente a dicho certificado.

Fuentes
=======

Curso en línea de Firma electrónica con Murachí de CENDITEL.

=====
rsync
=====

Es una aplicación que ofrece transmisión eficiente de datos, que opera también
con datos comprimidos y cifrados. Mediante una técnica de delta encoding,
permite sincronizar archivos y directorios entre dos máquinas de una red o entre
dos ubicaciones en una misma máquina, minimizando el volumen de datos
transferidos.

Muy recomendable para hacer respaldos en discos externos.

Para instalarlo

# apt-get install rsync

Parametros: -P para mostrar el progreso de la copia y -r cuando se van a copiar
directorios

Para copiar ficheros, archivos, etc.

$ rsync -P ficehero /directorio/carpeta2

-r para copiar directorios se ponen las dos rutas: origen y destino separados
por un espacio

$ rsync -P -r /directorio/carpeta1_origen /directorio/carpeta2_destino

Ojo con carpeta1, sin el / al final, lo cual significa que se va copiar la
carpeta completa con su contenido y no solo su contenido.

========================================================
rsync para copiar ficheros a un servidor a través de ssh
========================================================

-v : Verbose (try -vv for more detailed information)
-e "ssh options" : specify the ssh as remote shell
-a : archive mode
-r : recurse into directories

$ rsync -P -r -v -e ssh name_dir_or_filename user@192.168.1.100:/home/use/dir/

==============================================================
Usando rsync desde python para copiar un fichero a un servidor
==============================================================

$ python

>>> import os
>>> os.system("rsync -varz /home/user/xxx.txt user@192.168.1.100:")
user@192.168.1.100's password: ******
sending incremental file list
xxx.txt

sent 87 bytes  received 31 bytes  33.71 bytes/sec
total size is 0  speedup is 0.00
0
>>> 

Fichero copiado al servidor!

====================================
CCLive - Descargar videos de youtube
====================================

CCLive es una aplicación que nos permite descargar un vídeo que esté en YouTube
hacia nuestro ordenador mediante un simple comando. Por defecto guarda los
vídeos en webm.

Para ver si lo tenemos en los repos, y ver la descripción, si es así.

$ aptitude show cclive

Instalación

# apt install cclive

Descargar un video pasando la url de youtube.

$ cclive https://www.youtube.com/watch?v=yWVrvce5R9

Soporta varias URLs a la vez, para bajar mas de 1 video.

$ cclive URL1 URL2 URL3 URL4

Descargar un vídeo detrás de otro, desde un archivo de texto plano con todas
las URLs (en líneas diferentes).

$ cclive < urls.txt

Manual del paquete.

$ man cclive

Comprobar los formatos disponibles antes de descargar el video.

Se podrá ver un listado de formatos disponibles separados por "|"

$ cclive -F https://www.youtube.com/watch?v=Lfj667lLLnE

Se elige el formato y se pasa en el comando, luego comenzará la descarga.

$ cclive -f fmt22_720p https://www.youtube.com/watch?v=LtzFg4JiL5E

Download the best available format of the media.

$ cclive -f best http://www.youtube.com/xxxxxx

========================================
youtube-dl - Descargar videos de youtube
========================================

Instalación de youtube-dl desde el repositorio de Debian.

# apt-get install youtube-dl

# apt-get install python-pip

Nota: De vez en cuando salen actualizaciones por lo cual hay que actualizar
manualmente el paquete, y si no se actualiza puede presentar errores, entonces,
lo actualizamos con los siguientes comandos:

# apt-get update

# apt-get install --only-upgrade youtube-dl

$ pip install --upgrade youtube-dl

Instalación desde la página oficial.

$ sudo curl -L https://yt-dl.org/downloads/latest/youtube-dl -o /usr/local/bin/youtube-dl

$ sudo chmod a+rx /usr/local/bin/youtube-dl

$ sudo pip install --upgrade youtube_dl

ó usando wget

$ sudo wget https://yt-dl.org/downloads/latest/youtube-dl -O /usr/local/bin/youtube-dl

$ sudo chmod a+rx /usr/local/bin/youtube-dl

$ sudo pip install --upgrade youtube_dl

Para enumerar todos los formatos de video disponibles, use la opción
"-list-formats" con el comando youtube-dl.

$ youtube-dl --list-formats my_youtube_url

Ejemplo de la salida del comando:

[youtube] vKtwZmhX0lw: Downloading webpage
[youtube] vKtwZmhX0lw: Downloading video info webpage
[youtube] vKtwZmhX0lw: Extracting video information
[youtube] vKtwZmhX0lw: Downloading DASH manifest
[youtube] vKtwZmhX0lw: Downloading DASH manifest
[info] Available formats for vKtwZmhX0lw:
format code  extension  resolution note
171    webm    audio only DASH audio  113k , vorbis@128k (44100Hz), 1.86MiB
140    m4a     audio only DASH audio  128k , m4a_dash container, aac  @128k (44100Hz), 2.14MiB
141    m4a     audio only DASH audio  255k , m4a_dash container, aac  @256k (44100Hz), 4.30MiB
278    webm    180x144    DASH video   63k , webm container, vp9, 1fps, video only, 946.76KiB
160    mp4     180x144    DASH video  112k , avc1.4d400c, 15fps, video only, 1.86MiB
242    webm    300x240    DASH video  170k , vp9, 1fps, video only, 2.50MiB
133    mp4     300x240    DASH video  247k , avc1.4d400d, 25fps, video only, 4.11MiB
243    webm    400x320    DASH video  288k , vp9, 1fps, video only, 4.07MiB
13     3gp     unknown    small
17     3gp     176x144    small ,  mp4a.40.2, mp4v.20.3
36     3gp     320x240    small ,  mp4a.40.2, mp4v.20.3
5      flv     400x240    small
43     webm    640x360    medium ,  vorbis, vp8.0
18     mp4     640x360    medium ,  mp4a.40.2, avc1.42001E (best)

Para descargar un formato de archivo preferido, use la opción '-f' (código de
formato de video). Por ejemplo, me gustaría descargar el formato mp4 así que uso
el código de formato como '18' como se muestra a continuación.

$ youtube-dl -f 18 my_youtube_url

===============================
Formatear pendrives desde linux
===============================

# aptitude install dosfstools

Luego de instalar el paquede, montamos el pendrive, solo esta montado si aparece
el nombre de la unidad en /media, luego escribimos:

$ df -h

Visualizamos la ruta de nuestro usb, ejemplo /dev/sdc1 que es el puerto donde
está montado, luego desmontamos el pendrive.

$ umount /media/nombre_usb

Luego, estando desmontado la unidad usb, pero conectado al puerto

# mkfs.vfat -F 32 -n Nombre_usb /dev/sdc1

Esperamos y listo. Con la opción -F 32 le decimos que será formateada como
Fat32, y con la opción -n le ponemos una etiqueta o nombre al dispositivo y al
final ponemos la ruta hasta nuestro dispositivo, la que vimos con df -h

=============
sqlitebrowser
=============

Herramienta de alta calidad visual para crear, diseñar y editar archivos de
bases de datos compatibles con SQLite. Es para usuarios y desarrolladores que
desean crear bases de datos, buscar y editar datos. Utiliza una interfaz de tipo
hoja de cálculo familiar y no necesita aprender comandos SQL complicados.

Para instalarlo

# aptitude install sqlitebrowser

Para ejecutarlo

$ sqlitebrowser

==============================================
Quemar o grabar una imagen .iso en un pendrive
==============================================

# dd if=[imagen] of=[dispositivo]

En donde imagen es la ruta completa a la imagen ISO que deseas grabar y
dispositivo la ruta de sistema hacia la unidad usb, no la ruta con el nombre del
usb, estas rutas las vemos con:

$ df -h

Por ejemplo:

# dd if=/home/user/Descargas/debian-testing-i386-businesscard.iso of=/dev/media/sdb

Copiar un imagen .iso en unidad USB

Para hacerlo booteable, debe estar desmontado pero conectado en el puerto usb.

$ cat xxxx.iso > /dev/sdxxx ; sync

====================================
Instalación de gnome en sistema base
====================================

# apt-get install gnome-shell

# apt-get install gnome-core

# apt-get install gnome

# apt-get install task-gnome-desktop

# apt-get install task-spanish-desktop

=========================
Remover gnome del sistema
=========================

# apt-get autoremove --purge 'gnome*'

# apt-get autoremove

============================================
Instalación de gnome classic en sistema base
============================================

Probado en Ubuntu 11 y 12 nada más, puede que funcione en anteriores o
superiores.

# apt-get install gnome-panel

# apt-get install gnome-session-flashback

Luego de reiniciar, saldrá el gnome-classic en las opciones de escritorio antes
de iniciar sesión.

==========================================
Configuraciones visuales extras para gnome
==========================================

# apt-get install gnome-themes-extras

=============================
Usando los programas de gnome
=============================

Captura de pantalla del escritorio usando el panel de herramientas.

$ gnome-screenshot --interactive

Captura de pantalla del escritorio.

$ gnome-screenshot

Extrae las imagenes de un .pdf

$ pdfimages fichero.pdf nombre_imagene

===================================
Instalación de xfce en sistema base
===================================

Xfce es un entorno de escritorio ligero para sistemas tipo UNIX. Su objetivo es
ser rápido y usar pocos recursos del sistema, sin dejar de ser visualmente
atractivo y fácil de usar.

# aptitude install xfce4

Luego instalamos utilidades extras, si se quiere, se le conoce como "goodies".

# aptitude install xfce4-goodies

# aptitude install lightdm

Luego de eso, cuando reiniciemos la máquina, podremos elegir acceder con xfce
como entorno de escritorio.

============================
wget para descargar ficheros
============================

Descargar toda una página completa, wget no está limitado a solo descargas de
archivos. Sitios completos pueden descargarse también.

$ wget www.ejemplo_web.com

Lo mismo que lo anterior pero con esta opción -p descarga además todos los
elementos extras necesarios de la página como hojas de estilos, imágenes en
línea, etc.

$ wget -p www.ejemplo_web.com

-c ó --continue, reanudar una descarga de wget si se detuvo por caída de red,
cancelación de proceso, etc. Se lanza el comando de nuevo con el enlace para
reanudar.

$ wget -c ftp://sunsite.doc.ic.ac.uk/ls-lR.Z

Indicar más de una descarga a la vez, incluso con distintos protocolos o extensiones

$ wget http://ejemplo.com/programa.tar.gz ftp://otrositio.com/descargas/video.mpg

Descargar varios archivos, con extensión similar.

$ wget http://ejemplo.com/*.pdf

Descargar varios archivos a traves de una lista.

$ wget -i archivos.txt

Creamos una lista en archivos.txt que serán descargados:
http://ejemplo.com/programa.tar.gz
http://ejemplo.com/rpm/paquete.rpm
ftp://otrositio.com/descargas/distro.iso

Por defecto, wget realiza 20 intentos de establecer la conexión e iniciar la
descarga, en sitios muy saturados es posible que ni con 20 intentos se logré,
con la opción -t (tries) aumenta a más intentos.

$ wget -t 50 http://ejemplo.com/pelicula.mpg

/ Con la opción -r se descarga recursivamente hasta 5 niveles del sitio.

$ wget -r www.ejemplo.com

$ wget --convert-links -r http://www.sitio.com/

ó

Por defecto, los enlaces dentro del sitio apuntan a la dirección del dominio
completo. Si deseas descargar el sitio recursivamente y después estudiarlo fuera
de línea (off line) usa la opción convert-links que los convertirá en enlaces
locales, apuntando a las páginas dentro del sitio descargado.

$ wget -k -r http://www.sitio.com/

$ wget --mirror http://ejemplo_web.com/    

ó

De este modo obtienes una copia (un espejo) completa del sitio.

$ wget -m http://ejemplo_web.com/

-l7 (nivel de profundidad) de descargara, es decir descargará en esa profundidad
de subdirectorios. De forma predeterminada wget emplea 5.

$ wget -r -l7 www.ejemplo.com

Ignorar avisos de certificados caducados, etc.

$ wget --no-check-certificate my_url

Descargar una carpeta o directorio específico con wget

$ wget -H -r --level=1 -k -p http://192.168.12.82/share/fff

=====
jigdo
=====

Jigsaw Download, o abreviadamente jigdo , se propone como la forma principal de
distribuir imágenes de CD de Debian en el futuro. Actualmente, el sistema
funciona, pero no es aún muy cómodo de usar porque la aplicación gestora de
descargas no está terminada.

Página del paquete -> https://www.debian.org/CD/jigdo-cd/

# aptitude install jigdo-file

Aquí, por ejemplo, podemos buscar los .jigdo
--> http://cdimage.debian.org/debian-cd/8.5.0/amd64/ en jigdo-dvd/

Nos pedirá un fichero .jigdo para descargar.

$ jigdo-lite

ó simplemente le pasamos el fichero en el mismo comando:

Para descargar

$ jigdo-lite http://cdimage.debian.org/debian-cd/8.5.0/amd64/jigdo-dvd/debian-8.5.0-amd64-DVD-1.jigdo

ó

Para descargar

$ jigdo-lite http://cdimage.debian.org/cdimage/archive/7.11.0/amd64/jigdo-cd/debian-7.11.0-amd64-CD-1.jigdo

Luego nos preguntará por ejemplo:

Files to scan: 

Como esta es la primera vez que vamos a descargar el iso, damos Enter y no añado
nada en este paso.

Lo otro que va a preguntar es cuál el mirror que quieres usar (se puede usar un
mirror local siempre y cuando esté actualizado). por lo tango metemos la
dirección en el espacio: http://debian.cen.... y enter

Ejecutará muchos procesos y al final debe mostrar un:

-------------------------------
Finished!
The fact that you got this far is a strong indication that `debian-7.11.0-amd64-CD-1.iso'
was generated correctly. I will perform an additional, final check,
which you can interrupt safely with Ctrl-C if you do not want to wait.

OK: Checksums match, image is good!

=======================
Conexion remota con ssh
=======================

SSH (Secure SHell) es el nombre de un protocolo y del programa que lo implementa
y sirve para acceder a máquinas remotas a través de una red. Permite manejar por
completo la computadora mediante un intérprete de comandos, y también puede
redirigir el tráfico de X para poder ejecutar programas gráficos si tenemos
ejecutando un Servidor X (en sistemas Unix y Windows).

Además de la conexión a otros dispositivos, SSH nos permite copiar datos de
forma segura (tanto archivos sueltos como simular sesiones FTP cifradas),
gestionar claves RSA para no escribir claves al conectar a los dispositivos y
pasar los datos de cualquier otra aplicación por un canal seguro tunelizado
mediante SSH.

Instalar ssh y el servidor de ssh que permite conexiones remotas.

# aptitude install ssh openssh-server

Conectarse a otra máquina o servidor

$ ssh Nombre_usuario@IP_servidor o nombre_servidor

Asi se accede a un ordenador o servidor remoto, debemos poner el usuario que
debe estar creado asi como la ip del server, nos pedira la clave de session, una
vez adentro tenemos acceso a los archivos y podemos pedir el root para tener
acceso total.

$ ssh user@192.168.0.240

ssh es muy usado por administradores de redes y de sistemas para acceder a las
maquinas y los servidores y hacer cambios asi como monitorear los procesos que
esten ejecutando, especialmente en maquinas virtuales si varios proyectos corren
en un mismo servidor.

Otra forma usando el parámetro -l.

$ ssh -l user 192.168.0.240

Si el servidor tiene el mismo usuario que el host, no hace falta especificarlo,
solamente con la ip del servidor basta, pues toma el nombre del usuario del host
para hacer la conexión.

$ ssh 192.168.200.xxx

Estando conectados al servidor, podemos enviar mensajes o abrir programas
remotamente, ejemplo:

 Enviar mensaje a traves del shell a otro usuario, en el servidor o local, debe
 haber un shell abierto que sea receptor.

echo "mensaje" > /dev/pts/2

Se puede hacer localmente para probar, con (who) veremos la identificacion de
cada shell, si estamos conectados remotamente, comprobaremos si hay shells
abiertos en el local y el servidor, se identifican con los pts/0, pts/1, etc, y
sabremos por la ip si son shells locales o del server  el mensaje sale en el
shell escogido.

Creamos la ventana virtual donde se abrira la aplicacion que ejecutemos, luego

$ export DISPLAY=:0.0

Deberia abrir el programa en el servidor, ya esportada la ventana podemos:

$totem o $nautilus

Abrir el reproductor totem en el servidor

DISPLAY=:0.0 totem

Abrir el explorador de archivos en el servidor

DISPLAY=:0.0 nautilus

Reiniciar el servicio de ssh, a veces se hace para que sirvan algunos cambios de
configuración.

$ sudo service ssh restart

Para ver el estado del servicio.

$ sudo service ssh status

================
Seguridad en ssh
================

Para hacer mas seguras las conexiones a través de ssh es necesario realizar
ajustes adicionales en la configuración del servidor. Estos ajustes se deben
realizar en el fichero de configuración del servidor que, por ejemplo, en Linux
se encuentra en /etc/ssh/sshd_config

==============================================
Cambiar el puerto por defecto del servidor SSH
==============================================

Por defecto los servidores SSH utilizan el puerto 22 para las conexiones. Cuando
un pirata intente buscar la forma de conectarse a nuestro servidor SSH este
probará en primer lugar con este puerto y, de estar abierto, comenzará
el ataque.

Si cambiamos el puerto por defecto por otro de nuestra elección evitaremos que
utilicen el puerto 22 para establecer las conexiones, sin embargo, es fácil
descubrir si este tipo de protocolos utilizan otros puertos adicionales para
las conexiones.

=================================================
Bloquear el acceso root en las conexiones remotas
=================================================

Es recomendable crear un único usuario para conectarse al servidor con una
contraseña lo más fuerte posible de manera que no pueda ser explotada
fácilmente, sin embargo, por defecto el usuario Root también puede conectarse
al servidor SSH de forma remota evitando a un atacante el tener que adivinar el
usuario y facilitándose el trabajo.

Desactivando los permisos de Root para conectarse al servidor SSH complicaremos
notablemente la tarea de explotación por fuerza bruta del servidor al tener que
adivinar también el usuario establecido para permitir la conexión.

El valor por defecto en el archivo de configuración que permite las conexiones
de root es:

PermitRootLogin yes

Debemos cambiarlo por:

PermitRootLogin no

De esta manera las conexiones root quedarán bloqueadas evitando que usuarios no
autorizados puedan realizar ataques de fuerza bruta contra nuestro servidor SSH
para adivinar los credenciales del usuario Root.

========================================
Configuraciones de seguridad adicionales
========================================

Existen otras configuraciones recomendadas para evitar las conexiones no
deseadas a nuestro servidor SSH. Estas conexiones son:

LoginGraceTime: Estableceremos el tiempo necesario para introducir la
contraseña, evitando que el atacante tenga que “pensar mucho”.

MaxAuthTries: Número de errores permitidos al introducir la contraseña antes de
desconectarnos.

MaxStartups: Número de logins simultáneos desde una IP, para evitar que se pueda
utilizar la fuerza bruta con varias sesiones a la vez.

AllowUsers: Este parámetro nos permite configurar los usuarios que podrán
conectarse y desde la IP que lo podrán hacer. Una medida muy restrictiva pero a
la vez muy segura ya que bloqueará todas las conexiones que no cumplan los dos
parámetros.

=====================================================
Reiniciar el servidor para aplicar los nuevos ajustes
=====================================================

Una vez realizados los ajustes debemos reiniciar el servidor para que se
apliquen correctamente. Para ello teclearemos:

$ sudo service ssh reload

En pocos segundos el servidor volverá a arrancar con la nueva configuración
aplicada y mucho más seguro que antes.

========================
Ejemplo de configuración
========================

Port 432 (o el que se quiera menor a 1024)
Protocol 2
LoginGraceTime 30
PermitRootLogin no
MaxAuthTries 2
MaxStartups 3
AllowUsers jose  o también:
AllowUsers jose maria@192.1.1.300

---

Port: Por default el demonio ssh funciona en el puerto 22, y precisamente muchos
scripts de ataques están dirigidos a este puerto, el cambiar de puerto no
garantiza que el servicio ya no será localizable, de hecho con herramientas como
nmap o amap es sumamente fácil descubrir que un servicio ssh esta a la escucha
en otro puerto distinto al 22, pero al menos no será localizable por varios
scripts que de manera automática escanean redes y en cuanto a ssh se enfocan
solo al puerto 22.

Protocol 2: Hay dos versiones de ssh en cuanto a su protocolo de comunicación,
la versión 1 y la versión 2. La 1 esta en desuso pero todavía se incluye por
compatibilidad, tiene varias vulnerabilidades conocidas y su uso no es ya
recomendable. Un error frecuente es dejar al demoinio ssh que permita el uso de
las dos versiones (Protocol 2,1). Para evitar el uso del protocolo 1 y sus
posibles ataques a este, basta con indicar en esta línea que solo admita
comunicaciones de ssh basadas en el protocolo 2.

LoginGraceTime 30: El número indica la cantidad de segundos en que la pantalla
de login estará disponible para que el usuario capture su nombre de usuario y
contraseña, si no lo hace el login se cerrará, evitando así dejar por tiempo
indeterminado pantallas de login sin que nadie las use, o peor aun, que alguien
este intentando mediante un script varias veces el adivinar un usuario y
contraseña. Aqui conviene identificar en nuestros usuarios el tiempo promedio
que tardan en ingresar su usuario y contraseña y darles unos cuantos segundos
más de margen por los usuarios lentos para que ingresen sus credenciales. Si
somos el único usuario del sistema considero que con 20 o 30 segundos es mas
que suficiente.

PermitRootLogin no: Esta es quizás la más importante directiva de seguridad que
podemos indicar para fortalecer nuestro servidor ssh.

Prácticamente todos los sistemas Linux y Unix crean por default al usuario root,
entonces sabemos que existe!!!. Muchos ataques de fuerza bruta se concentran en
atacar al usuario root con la esperanza de que tenga una contraseña débil (¡que
es mas común de lo que pensamos!).

Entonces si ya sabemos una parte de la ecuación (root) solo será cuestión de
tiempo para que alguien con paciencia y suerte vulnere el sistema.

Al poner en 'no' la variable PermitRootLogin el usuario root no tendrá permiso
de acceder mediante ssh y por lo tanto cualquier intento de ataque directo a
root será inútil. Con esto siempre tendremos que ingresar como un usuario normal
y ya estando adentro entonces mediante su o sudo podremos usar funciones de
root, no problem. Ahora bien, para el nombre de login del usuario normal te
recomiendo que también NO uses palabras conocidas como: admin, manager, juan,
pedro, sistemas, etc. Usa algo mas dífcil de adivinar como jgon (de juan
gonzález) o sispat (de sistemas pato) o mejor aun también puedes combinar algún
guión bajo o mayúsculas, minúsculas y números en la cuenta de login. Con lo
anterior el hacker tendrá que atinarle o crackear tanto al nombre del usuario
como su contraseña.

MaxAuthTries 2: El número indica la cantidad de veces que podemos equivocarnos
en ingresar el usuario y/o contraseña, en este caso después de dos intentos, se
perderá o cerrará la conexión. Claro, es totalmente posible volver a intentarlo,
pero como son dos intentos por vez, evitaremos ataques basados en la
persistencia de la conexión, como se perderá al tercer intento de conexión, el
ataque cesará.

MaxStartups 3: El número indica la cantidad de pantallas de login, o cantidad de
conexiones simultaneas de login que permitirá el sshd por ip que intente
conectarse. Hay ataques muy efectivos que dividen el ataque en decenas y puede
ser que en cientos (si el sistema atacado lo permite) de conexiones de login.
Es decir, el ataque divide en una gran cantidad de logins los intentos por
ingresar, aumentando sus posibilidades de más rapidamente adivinar al usuario y
contraseña. Con esta directiva limitamos a tan solo 3 pantallas de login. Que
quede claro, una vez logueados en el sistema, es posible tener mas de 3
terminales de ssh, se refiere exclusivamente a pantallas de login.

AllowUsers: En sistemas donde se tiene varios usuarios, quizás existan varios
que solo pueden acceder desde la LAN por ejemplo, o quizás solo desde ciertos
equipos. O incluso que solo desde su PC puedan trabajar en Linux por lo que no
hay razón para que se conecten remotamente via ssh. Con esta directiva podemos
indicar los usuarios que pueden ingresar via ssh. Si solo indicamos al usuario:

AllowUsers jose

El usuario jose podrá ingresar desde cualquier PC en cualquier lugar, no se está
validando el host.

Si se quiere mas seguridad, es posible indicar también el host mediante el
símbolo @

AllowUsers jose@192.168.0.25     (solo desde la IP indicada)
AllowUsers jose@192.168.0.*       (Toda la red indicada)
AllowUsers jose@*.desarrollo.com  maria@contabilidad.com    

(jose desde cualquier equipo del dominio indicado, maria solo desde el equipo
indicado)

Como puede verse, bastan algunas cuantas directivas o variables bien
configuradas en nuestro archivo /etc/ssh/sshd_config para incrementar
enormemente la seguridad en este servicio, seguramente no estoy considerando
alguna otra variable que también pudiera ser importante para la seguridad de ssh
si es así por favor házmelo saber para incluirla en este documento. Asi como
también hay que tener en cuenta que hay variables que permiten el no acceso con
contraseñas y sería más bien con certificados o llaves, las posibilidades son
extensas y es posible incluso tener varios equipos Linux comunícandose entre si
para respaldos, bases de datos, etc. con ssh y certificados de seguridad,
evitando intervención humana, consulta la sección de servicios si es lo que
buscas en tu empresa.

==============================
X11 forwarding a través de ssh
==============================

X11, es el servidor gráfico que usan casi todas las distribuciones Linux. Este
servidor permite, entre otras cosas, forwarding a través de SSH. Esto significa
que es posible ejecutar apliaciones gráficas de una máquina remota exportando el
display a nuestro escritorio. Es decir, la aplicación se ejecuta en el servidor
remoto, pero la interfaz gráfica la visualizamos en nuestro escritorio local.

Ejemplo:

1- En el servidor, editar el archivo /etc/ssh/ssh_config y modificar la opción
X11Forwarding o ForwardX11 para que quede así:

X11Forwarding yes

ó

ForwardX11 yes

Luego de este cambio, posiblemente sea necesario reiniciar el demonio ssh. La
forma de hacer esto varía de acuerdo a cada distribución Linux.

$ sudo service ssh restart

O lo más sencillo es reiniciar la máquina.

2- En el escritorio local, loguearse al servidor a través de ssh utilizando el
parámetro -X:

$ ssh -X user@hostname

Donde user es el nombre de usuario utilizado para loguearse en el servidor y
hostname es el ip o el alias del servidor.

3- Para ejecutar una aplicación, simplemente hay que hacerlo desde el terminal.

Por ejemplo:

$ firefox

$ nautilus

$ evince

Cuando ejecutamos una aplicación gráficamente la consola se bloqueara con el
proceso en ejecución, por lo que podemos usar & para que se ejecute el proceso,
construya el entorno grafico del programa y luego dezplace el proceso para poder
seguir usando la consola, ejemplo:

$ firefox

ó

$ firefox & nautilus &

==========================
Escritorio remoto, por ssh
==========================

Esta guía nos permitirá ejecutar un escritorio remoto a través de una conexión
por ssh, el cliente debe estar en modo consola, puede usar tty1 por ejemplo.

Primer paso, instalar openssh-server en el cliente y en el servidor

# apt-get install openssh-server openssh-client

Una vez hecho esto configuramos el servidor para que sea accesible desde los
clientes:

$ sudo nano /etc/ssh/ssh_config

Hay tres lineas del archivo que deberían quedar así:
ForwardAgent yes
ForwardX11 yes
ForwardX11Trusted yes

Guardamos y abrimos otro archivo:

$ sudo nano/etc/ssh/sshd_config

Debe aparecer la siguiente línea:
ForwardX11 yes

Una vez hecho esto reiniciamos el servidor ssh:

$ sudo service ssh restart

Luego nos conectamos por ssh al servidor, con el parámetro -X que nos permitirá
levantar gráficos en el cliente de aplicaciones que se ejecutan en el servidor.

$ ssh -X username@ip_server

======
startx
======

Para iniciar o levantar el modo gráfico

Arrancar el servidor gráfico indicándole el DISPLAY, por defecto el primer
DISPLAY es 0 (al cual accedemos con Cntrl+Alt+F7).

$ startx -- :DISPLAY

Levantará una sesión de escritorio como root, el cliente debe estár en
modo ttyX.

$ sudo startx

ó

Puede que falle a veces, si es que el cliente ya tiene una interáz gráfica
corriendo, por eso se recomienda que esté en ttyX.

$ gnome-session

===================================================
El error ssh remote host identification has changed
===================================================

Cuando el sistema base guarda una llave de acceso a un host, pero el host
cambió, entonces la llave no funciona y arroja el típico error:

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
...
...
...

Entonces borramos ese host roto, llave perdida, etc.

$ ssh-keygen -R <host>

Ejemplo:

$ ssh-keygen -R 192.168.3.10

========================================================
Error: Read from socket failed: Connection reset by peer
========================================================

# rm /etc/ssh/ssh_host_*

# ssh-keygen -A

# apt-get --reinstall install openssh-server openssh-client

$ ssh-keygen -R 192.168.12.xxx

==============================================
Generar llaves para ssh para saltar contraseña
==============================================

Si el host desea conectarse al servidor, sin tener que escribir password cada
vez que se intente conectarse puede usar este método donde se generan claves
publica y privada.

Generamos las claves en el host

$ ssh-keygen -b 4096 -t rsa

No generar frase de paso: simplemente presionemos [Enter], un segundo después
volvemos a presionar [Enter], y un segundo después volvemos una vez más a
presionar [Enter]. O sea, presionaríamos [Enter] un total de tres (3) veces,
solo lo presionamos… no escribimos nada.

Eso nos va a generar las claves en:

/home/user/.ssh
id_rsa // Es nuestra llave privada.
id_rsa.pub // Es nuestra llave pública.
known_hosts // Es un fichero ya existente en ese directorio.

Enviamos la llave publica para el home del servidor:

$ scp /home/.ssh/id_rsa.pub user@192.168.12.x:

Luego en el servidor renombraremos la clave publica a:

$ mv id_rsa.pub authorized_keys

Luego moveremos ese nuevo fichero a .ssh

$ mv authorized_keys .ssh/

Luego quedaría intentar conectarse desde el host al servidor, si todo está bien
no debería pedir contraseña.

Es funcional, pero hubo una vez que no se que coño paso y no quizo funcionar,
las demas pruebas si fueron exitosas.

========================================
Copias de directorios o ficheros por scp
========================================

scp copies files between hosts on a network. It uses ssh for data transfer, and
uses the same authentica‐tion and provides the same security as ssh(1). scp will
ask for passwords or passphrases if they are needed for authentication.

===================================
Copiar archivos de local a servidor
===================================

Si queremos subir el archivo archivo.txt de nuestro ordenador a la carpeta
/home/usuario del servidor, hacemos lo siguiente:

Se especifica el archivo a copiar, luego el servidor y luego el directorio en
el servidor donde copiaremos el archivo.

$ scp archivo.txt usuario@dominio.com:/home/usuario

===================================
Copiar archivos de servidor a local
===================================

Si queremos copiar el fichero archivo.txt del servidor a nuestro ordenador en la
carpeta Documentos, hacemos lo siguiente:

Especificamos el servidor, luego la ruta y el archivo a copiar y luego el
directorio local donde sera copiado el archivo.

$ scp usuario@dominio.com:/home/usuario/archivo.txt /home/usuario/Documentos

======================================
Copiar archivos de servidor a servidor
======================================

$ scp usuario1@dominio1.com:/home/usuario1/archivo.txt usuario2@dominio2.com:/home/usuario2/

=================================================
Copiar un directorio completo de local a servidor
=================================================

Para copiar un directorio completo de mi ordenador al servidor, por ejemplo
/home/mario/carpeta a /home/usuario, añadimos un -r en el comando:

$ scp -r /home/mario/carpeta usuario@dominio.com:/home/usuario

Con los dos puntos al final se copiara automáticamente en el home del usuario.

$ scp -r /home/mario/carpeta usuario@dominio.com:

=================================================
Copiar un directorio completo de servidor a local
=================================================

Para copiar un directorio completo del servidor al local, por ejemplo
/home/usuario/carpeta a /home/user/docs, añadimos un -r en el comando:

$ scp -r usuario@dominio.com:/home/usuario/carpeta /home/user/docs

---

Si el servidor tiene el mismo usuario "user" en este caso, no hace falta
especificarlo, solamente con la ip del servidor basta, pues toma el nombre del
usuario del host para hacer la conexión y osterior copia.

user$ scp x.txt 192.168.200.x

=======
sshpass
=======

Nos permite enviar el password de SSH en la misma línea con el paquete sshpass,
ejemplo:

$ sshpass -p «PASSWORD» ssh root@servidor

Accedemos remotamente a ese servidor, si la contraseña coincide no debería pedir
mas nada, y despliega el prompt del servidor.

$ sshpass -p 123456 ssh user@192.168.1.200

========================================================
Conexion por nautilus explorador de archivos/directorios
========================================================

Usando el navegador de archivos de Debian, Ubuntu, etc, podemos acceder a
ordenador remoto "servidor" para ver graficamente los directorios, es decir,
desde nuestro navegador de archivos, navegaremos en los directorios del servidor
para acceder vamos a:

$ nautilus

Archivo > Conectar con el servidor // Nos saldrá una ventana para llenar con:

Servidor: 192.168.12.400 // Aqui va la ip del servidor
Puerto: 22 // El puerto que tiene habilitado el ssh_config
Tipo: SSH
Carpeta: /home // Carpeta que abrira al entrar en conexion
Nombre de usuario: // Nombre de usuario, de sesion de ese servidor
Contraseña: // Contraseña de la sesion de usuario del servidor

Si todo esta bien deberia entrar a explorar los directorios del servidor.

=======================
Crear alias de comandos
=======================

Un alias es una palabra o frase que se asignara para remplazar un comando, por
lo generalmente se usa para remplazar comandos muy largos y dificiles de
recordar por lo que es una gran ventaja la creacion de alias.

Un alias Se pueden crear temporalmente, directamente en la consola y durara
hasta que cerremos ese shell, tambien asignar permanentemente escribiendolo en
el archivo .bashrc que esta en el /home

$ alias nombre_alias='comando'

Ejemplo:

$ alias sa='aptitude search apache | grep rt4'

(sa) es ahora el alias de ese comando de busqueda en los repositorios de un
paquete especifico.

Para eliminar el alias creado temporalmente

$ unalias nombre_alias

Otros ejemplos:

# some more ls aliases
alias ll='ls -l --color'
alias buscar='grep --color -n -Ir'

Para que se haga efectivo algun cambio en .bashrc es necesario reiniciar pero
hay otra forma de actualizar el fichero sin reiniciar, entonces:

Bastara para que se apliquen los cambios hechos

$ source .bashrc

Mensaje de bienvenida al usuario

Pegamos esto al final del .bashrc, reiniciamos el fichero y ahora cada vez que
iniciemos un shell nos saludará.

## Mensaje al iniciar
echo "Hola Usuario"

================================================
Saber la direccion ip de una pagina o un sevidor
================================================

Saber la de google por ejemplo:

user@debian:~$ nslookup google.com
Non-authoritative answer:
Name:   google.com
Address: 216.58.192.110 // Direccion ip de google

==========
Otra forma
==========

Haciendo ping a una pagina.

$ ping google.com

La ip que se muestra es la ip de google

PING google.com (216.58.192.110) 56(84) bytes of data.
64 bytes from mia07s35-in-f14.1e100.net (216.58.192.110): icmp_req=1 ttl=49 time=69.6 ms
64 bytes from mia07s35-in-f14.1e100.net (216.58.192.110): icmp_req=2 ttl=49 time=70.4 ms

--- google.com ping statistics ---
3 packets transmitted, 2 received, 33% packet loss, time 2001ms
rtt min/avg/max/mdev = 69.645665/70.00475/470.48645/0.010 ms

============================
Cambiar permisos de usuarios
============================

Al ver los permisos de los ficehros o directorios nos encontramos con varios
parametros:

En la primera columna se pueden ver una serie de letras y guiones (-rwxr-x---)
estas letras nos dicen quien en el sistema, y que clases de permisos tiene el
fichero o carpeta.

Estas letras están agrupadas en tres grupos con tres posiciones cada uno más una
primera posición que nos dice de que clase de archivo se trata (los mas normales
(d) directorios, o (-) archivos de datos).

El primer grupo de tres (rwx en nuestro caso) nos dice que clase de permisos
tiene el dueño del fichero (u)(user/owner).

El segundo grupo de tres (r-x en nuestro caso) nos dice que clase de permisos
tiene el grupo del fichero (g)(group).

Y el último grupo de tres (--- en nuestro caso) nos dice que clase de permisos
tienen todos los demás usuarios del sistema sobre este fichero (o)(others).

r :significa permiso para leer 
w :significa permiso para escribir  
x :significa permiso para ejecutar

u :permisos para el usuario/dueño del fichero/directorio
g :permisos de grupos
o :permisos de los demás usuarios

Los permisos se pueden especificar de diferentes maneras, una serie de ejemplos,
es lo mejor para comprenderlo:

chmod ugo+rwx (da permisos rwx a todos, user,group,others)
chmod ugo-x test (quita permiso x (ejecucion) a todos, user,group,others) 
chmod o-rwx test (quita permisos rwx a others) 
chmod u=rwx,g=rx (da permisos rwx a user, rx a group y ninguno a others)

Ejemplo de como otorgar permisos a un directorio específico, estos serían los
permisos predeterminados o por defecto de un directorio.

chmod -R u=rwx,g=rx,o=rx /dir/dir2/dir3

==============
chmod en octal
==============

Representación octal de chmod

Lectura tiene el valor de 4
Escritura tiene el valor de 2
Ejecución tiene el valor de 1

Entonces:

rwx |  7  | Lectura, escritura y ejecución
rw- |  6  | Lectura, escritura
r-x |  5  | Lectura y ejecución
r-- |  4  | Lectura
-wx |  3  | Escritura y ejecución
-w- |  2  | Escritura
--x |  1  | Ejecución
--- |  0  | Sin permisos

Por lo tanto:

chmod u=rwx,g=rwx,o=rx  | chmod 775 |
chmod u=rwx,g=rx,o=     | chmod 760 |
chmod u=rw,g=r,o=r      | chmod 644 |
chmod u=rw,g=r,o=       | chmod 640 |
chmod u=rw,go=          | chmod 600 |
chmod u=rwx,go=         | chmod 700 |

=====
chown
=====

Permite modificar a los usuarios o grupos dueños de un archivo o carpeta en el
sistema de archivos.

$ chown usuario archivo/carpeta

$ chown -R usuario archivo/carpeta

$ chown usuario *

# chown -R username directory

Para asignar tanto dueño como grupo usamos

# chown -R username:group directory

============
Criptografía
============

Criptografía es la ciencia y arte de escribir mensajes en forma cifrada o en
código.

Es parte de un campo de estudios que trata las comunicaciones secretas.

La criptografía se ha definido, tradicionalmente, como el ámbito de la
criptología que se ocupa de las técnicas de cifrado o codificado destinadas a
alterar las representaciones lingüísticas de ciertos mensajes con el fin de
hacerlos ininteligibles a receptores no autorizados. Estas técnicas se utilizan
tanto en el arte como en la ciencia y en la tecnología. Por tanto, el único
objetivo de la criptografía era conseguir la confidencialidad de los mensajes,
para lo cual se diseñaban sistemas de cifrado y códigos, y la única criptografía
existente era la llamada criptografía clásica.

La aparición de la informática y el uso masivo de las comunicaciones digitales,
han producido un número creciente de problemas de seguridad. Las transacciones
que se realizan a través de la red pueden ser interceptadas, y por tanto, la
seguridad de esta información debe garantizarse. Este desafío ha generalizado
los objetivos de la criptografía para ser la parte de la criptología que se
encarga del estudio de los algoritmos, protocolos (se les llama protocolos
criptográficos), y sistemas que se utilizan para proteger la información y dotar
de seguridad a las comunicaciones y a las entidades que se comunican.

Para ello los criptógrafos investigan, desarrollan y aprovechan técnicas
matemáticas que les sirven como herramientas para conseguir sus objetivos. Los
grandes avances producidos en el mundo de la criptografía, han sido posibles
gracias a la evolución que se han producido en el campo de la matemática y la
informática.

=======
Fuentes
=======

-https://es.wikipedia.org/wiki/Criptograf%C3%ADa

===========
Criptología
===========

La criptología es, tradicionalmente, la disciplina que se dedica al estudio de
la escritura secreta, es decir, estudia los mensajes que, procesados de cierta
manera, se convierten en difíciles o imposibles de leer por entidades no
autorizadas.

Con la aparición de las tecnologías de la información y la comunicación y el uso
masivo de las comunicaciones digitales, se han producido un número creciente de
problemas de seguridad. El objetivo de la criptología se ha generalizado para
estudiar las técnicas que se encargan de proporcionar seguridad a la
información.

======
Fuente
======

-https://es.wikipedia.org/wiki/Criptolog%C3%ADa

==============
Criptoanálisis
==============

El criptoanálisis es la parte de la criptología que se dedica al estudio de
sistemas criptográficos con el fin de encontrar debilidades en los sistemas y
romper su seguridad sin el conocimiento de información secreta. En el lenguaje
no técnico, se conoce esta práctica como romper o forzar el código, aunque esta
expresión tiene un significado específico dentro del argot técnico. A las
personas que se dedican al criptoanálisis se llaman criptoanalistas.

======
Fuente
======

-https://es.wikipedia.org/wiki/Criptoan%C3%A1lisis

======================
Encriptación o Cifrado
======================

Con frecuencia a los procesos de cifrado y descifrado se les denomina encriptado
y desencriptado, ambos anglicismos de los términos ingleses encrypt y decrypt.
La Real Academia Española recogió esa acepción en la edición de su diccionario
de 2014. Por su parte La Fundación del Español Urgente defiende que encriptar
es un término válido y que no hay razón para censurar su uso.

======
Fuente
======

-https://es.wikipedia.org/wiki/Cifrado_(criptograf%C3%ADa)

=======
Cifrado
=======

Cifrado, en la criptografía.

El cifrado es un procedimiento que utiliza un algoritmo de cifrado con cierta
clave (clave de cifrado) para transformar un mensaje, sin atender a su
estructura lingüística o significado, de tal forma que sea incomprensible o, al
menos, difícil de comprender a toda persona que no tenga la clave secreta (clave
de descifrado) del algoritmo. Las claves de cifrado y de descifrado pueden ser
iguales (criptografía simétrica), distintas (criptografía asimétrica) o de ambos
tipos (criptografía híbrida).

==========================
¿Cómo funciona el cifrado?
==========================

Los métodos de cifrado actuales se basan en fórmulas matemáticas complejas. Se
utilizan estos dos tipos de sistemas:

==================================
El cifrado simétrico y asimétrico
==================================

En el cifrado simétrico, ciframos el archivo con una clave X
Para descifrarlo y obtener el archivo original, utilizamos la misma clave X.

El cifrado asimétrico es más complicado. Aquí no tenemos una sola clave común.
En su lugar cada persona tiene dos claves, una pública y una privada. Para
enviarle un archivo a un amigo lo cifras con su clave pública. De esta forma,
sólo lo puede descifrar él con su clave privada. Es más seguro que el cifrado
simétrico, ya que la clave de descifrado (la privada) nunca se comparte, siempre
la tiene el receptor.

Ejemplo: Sabiendo lo anterior, si queremos que tres compañeros de trabajo nos
manden un archivo cifrado debemos de mandarle nuestra clave pública (que está
vinculada a la privada) y nos podrán mandar de forma confidencial ese archivo
que solo nosotros podremos descifrar con la clave privada.

=======
Fuentes
=======

-https://es.wikipedia.org/wiki/Cifrado_(criptograf%C3%ADa)
-https://www.genbeta.com/desarrollo/tipos-de-criptografia-simetrica-asimetrica-e-hibrida

=============
Firma digital
=============

La firma digital consiste en la creación de un código, a través de la
utilización de una llave privada, de modo que la persona o entidad que recibe un
mensaje conteniendo este código pueda verificar si el remitente es quien dice
ser e identificar cualquier mensaje que pueda haber sido modificado.

=================
Firma Electrónica
=================

Es un método criptográfico que asocia la identidad de una persona o de un equipo
informático al mensaje o documento. En Función del tipo de firma, se puede,
además, asegurar la integridad del documento o mensaje.

=====================================================================
Cifrado de ficheros gpg, cifrado simétrico, asimétrico, firma digital
=====================================================================

Revisar si está instalado gnupg

$ aptitude search gnupg

==================================
¿Qué es GnuPG? (GNU Privacy Guard)
==================================

Es un derivado libre de PGP y su utilidad es la de cifrar y firmar digitalmente,
siendo además multiplataforma (podéis descargarlo desde la página oficial)
aunque viene incorporado en algunos sistemas Linux, como en Ubuntu o Debian.

GnuPG es una herramienta de GNU para la comunicación y el almacenamiento de
datos de manera segura. Se puede utilizar para cifrar datos y para crear firmas
digitales. Incluye capacidad avanzada de gestión de claves y cumple con el
estándar de Internet OpenPGP propuesto tal como se describe en el RFC 4880.

================
Anillo de claves
================

GPG tiene un repositorio de claves (anillo de claves) donde guarda todas las que
tenemos almacenadas en nuestro sistema, ya sean privadas o públicas (como
comenté, con la clave pública cifraremos un mensaje que solo podrá descifrar el
que posee la clave privada).

Más adelante cuando veamos un anillo de claves debemos de recordar que pub hace
referencia a la clave pública y sub hace referencia a la privada (y que tenemos
que tener a buen recaudo).

====================
Servidores de claves
====================

Para que nos cifren un mensaje tenemos que compartir la clave pública de nuestro
par de claves para cifrar, y como es un poco engorroso difundir una clave a
muchas personas existen los servidores de claves PGP (compatibles con GPG),
donde subiré una clave pública para el que quiera probar los ejemplos. Unos
ejemplos de servidores son estos: pgp.rediris.es (español, aunque falla algunas
veces) o pgp.mit.edu (americano, del MIT y a mi no me ha dado problemas).

=================
Cifrado simétrico
=================

El cifrado simétrico es el tipo de cifrado más sencillo que hay, es más rápido
de procesar y por desgracia menos seguro que el cifrado asimétrico.

Crear un fichero cualquiera de ejemplo

$ touch prueba.txt

Dentro del fichero copiaremos algún texto de prueba para comprobar luego con el
descifrado, luego en el shell escribimos el comando gpg con el parámetro -c para
cifrar y -d para descifrar.

=========================
Parámetros básicos de gpg
=========================

Encrypt with a symmetric cipher using a passphrase. The default symmetric cipher
used is CAST5.

-c

Decrypt the file given on the command line.

-d

El comando gpg -c nombre_fichero nos aparecerá un cuadro que nos pide la
contraseña luego una confirmacion de la misma, luego  generará un archivo .gpg

$ gpg -c prueba.txt

Para descifrarlo usamos el comando gpg -d notas.txt.gpg introduciendo la
contraseña correcta para poder decifrarlo.

Descifrar el fichero, nos permitira mirar el contenido.

$ gpg -d prueba.txt.gpg

Ver el Manual de gpg

$ man gpg

==================
Cifrado asimétrico
==================

Generar las claves

Para poder cifrar asimétricamente primero tenemos que crear la pareja de claves
(pública y privada) con el comando gpg --gen-key.

$ gpg --gen-key
gpg (GnuPG) 1.4.12; Copyright (C) 2012 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Por favor seleccione tipo de clave deseado:
(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sólo firmar)
(4) RSA (sólo firmar)
Su elección:

GPG nos permite elegir el tipo de clave que queremos usar, hay opciones que solo
permiten firmar y otras que permiten firmar y cifrar, en este caso usaremos DSA
y Elgamal.

Las claves DSA pueden tener entre 1024 y 3072 bits de longitud.

¿De qué tamaño quiere la clave? (2048)

Nos pedirá el tamaño de la clave que puede variar entre 1024 bits y 3072 esto es
de libre elección, tomarémos el que propone por defecto (2048).

Nos pide la fecha en la que expirará la clave, la información del emisor de la
clave (nombre, mail y algunos datos extra que queramos dar) y por último nos
pedirá la contraseña que salvaguarda la clave privada.

Tras generar las claves podemos verlas con el comando gpg -k que nos muestra
nuestro anillo de claves, lo importante de este paso es que veremos la
identificación de cada una que es necesaria para poderlas exportar y enviar.

Visualizar anillo de claves públicas importadas.

$ gpg -k

ó

$ gpg --list-key

Eso nos muestra por pantalla lo siguiente:

/home/user/.gnupg/pubring.gpg
--------------------------------

pub   1559C/88651986 2017-01-01
uid               username_lastname (Enunciado de la clave) <username@email.com>
sub   2048g/55GD33FG 2017-01-01

88651986, Éste es el ID de la llave pública.

55GD33FG, Éste es el ID de la llave privada.

Visualizar anillo de claves privadas importadas, si no hay nada entonces debo
importar mis llave/s privadas.

$ gpg --list-secret-key

Para poder usar mi llave privada debo copiar mi directorio /home/my_user/.gnupg
que es donde la genere, eso si quiero usarla en otro equipo.

==================================
Exportar y enviar la clave pública
==================================

El objetivo de esta pareja de claves es que cualquiera nos pueda mandar un
archivo cifrado que solo veremos nosotros y esto se hace difundiendo la clave
pública que acabamos de crear (la pública, nunca la privada), para exportarla en
un archivo usaremos el comando:

La clave pública generada antes tiene la ID 88651986).

$ gpg -output [archivo destino] --export [ID de a clave pública]

$ gpg --output ClavePublica_username.gpg --export 88651986

Fichero generado que contiene la clave pública

$ ls
ClavePublica_username.gpg

Este archivo ahora se puede difundir por el medio que queramos.

===============================================
Subir una clave pública a un servidor de claves
===============================================

Los servidores de claves suelen ser de acceso público (al no haber mucho
problema por difundir una clave pública) y en este caso subiremos una clave a
los servidores del MIT (pgp.mit.edu) usando el comando:

Al igual que antes la ID es 88651986)

$ gpg --send-keys --keyserver [Dirección del servidor] [ID de la clave pública]

$ gpg --send-keys --keyserver pgp.mit.edu 88651986

Entramos a --> https://pgp.mit.edu/ y buscamos nuestra clave pública por El
Nombre y Apellido que añadimos cuando la estuvimos creando.

=======================================================
Importar la clave desde el archivo o servidor de claves
=======================================================

Para poder usar la clave pública para cifrar o comprobar la identidad del
remitente tenemos que importar previamente la clave, desde un archivo debemos de
usar el comando gpg --import [Archivo de la clave pública].

$ gpg --import CPub.gpg

 Eso nos mostrará lo siguiente:

/home/user/.gnupg/pubring.gpg
--------------------------------
pub   2048R/XXXXXX XXXX-XX-XX
uid                  My User <My email>
sub   2048R/XXXX XXX-XX-XX

Para realizar la importación desde el servidor tenemos que usar el comando

$ gpg --keyserver [Dirección del servidor] --recv-keys [ID de la clave]

$ gpg --keyserver pgp.mit.edu --recv-keys 5616846865

=======================================
Borrar una clave de mi anillo de claves
=======================================

Pasamos el id de la clave que queremos borrar.

$ gpg --delete-keys id_pub_key

$ gpg --delete-keys 23484556

=================
Cifrar un fichero
=================

Creamos el fichero, lo llenamos con algo de texto para la prueba, lo guardamos.

$ vim x.txt

Cifrar con una clave pública.

$ gpg --encrypt --recipient [ID de la clave] [Archivo]

Ciframos el fichero con la clave publica creada para la prueba.

$ gpg --encrypt --recipient 88651986 x.txt

Fichero cifrado con la clave pública

Nos creará un fichero: x.txt.gpg

=========================================
Descifrar un archivo con la clave privada
=========================================

$ gpg -d [Archivo]

$ gpg -d x.txt.gpg

Si las llaves con que se cifro el fichero están en el anillo de claves entonces
se podrá descifrar el contenido.

Si las claves no han sido importadas entonces mostrará lo siguiente:

gpg: cifrado con clave RSA, ID XXXXXXXX
gpg: descifrado fallido: clave secreta no disponible

Si importamos nuestra llave/s privadas copiando /home/user/.gnupg a una nueva
máquina, si así fuera el caso, nos mostrará:

Necesita una frase contraseña para desbloquear la clave secreta del usuario:
"Name_user Last_name (comment) <mail@mail.xxx>" clave RSA de 2048 bits, ID
88651986, creada el 201x-xx-xx(ID de clave primaria 5F829889).

Introduzca frase contraseña:

La contraseña es la clave privada, la cual solo tendremos nosotros y nunca
compartiremos, pues es la que nos permite descifrar los ficheros que fueron
cifrados con nuestra clave publica.

===============
Firmar archivos
===============

Una de las medidas de seguridad básicas al pasar un mensaje o fichero es
asegurarnos que el emisor es quien dice ser, para asegurarnos de esto
digitalmente existe la firma digital, podemos cifrar y a su vez firmar ficheros,
que es lo que haremos con el comando:

$ gpg -u [ID de la clave] --output [Archivo resultante] --sign [Archivo para firmar]

...e introduciendo la contraseña de la clave privada.

$ gpg -u 88651986 --output x_firmado.txt.gpg --sign x.txt

...

Necesita una frase contraseña para desbloquear la clave secreta
del usuario: "xxx xxx (xx) <mail@mail.xxx>"
clave RSA de 2048 bits, ID 88651986, creada el 201x-xx-xx

Introduzca frase contraseña: 

...

nos generará el fichero:

x_firmado.txt.gpg

========================================
Verificar y descifrar un archivo firmado
========================================

Cualquiera con la clave pública asociada a la que ha firmado el documento puede
leerlo, de la misma forma que desciframos un archivo (gpg -d [Archivo]) o
verificándolo únicamente con el comando gpg --verify [Archivo].

$ gpg --verify x_firmado.txt.gpg 

muestra...

gpg: Firmado el xxx xx xx 201x xx:xx:xx VET usando clave RSA ID 88651986
gpg: Firma correcta de "User_name Last_name (comment) <user@mail.xxx>"

=========================
Exportar la clave privada
=========================

Si queremos verificar o firmar desde otro equipo con nuestra clave privada
tenemos que tener nuestra clave privada en ese equipo, para eso es necesario
copiar el directorio .gnupg que está en el /home/user de la máquina en la cual
creamos la clave privada a la nueva máquina.

=========================
Configurar sudo en Debian
=========================

En Debian no viene instalado y configurado por defecto.

$ aptitude install sudo

Una vez con el sudo instalado deberemos agregar nuestro usuario en la sección
"User privilege specification" en el archivo /etc/sudoers, de tal forma que la
sección quede así:

User privilege specification
root ALL=(ALL) ALL
tu_usuario ALL=(ALL) ALL

Una vez configurado esto, ya podremos ejecutar acciones de administrador desde
una terminal común, anteponiendo el sudo a la acción a realizar.

=======================================================
Lista de fuentes de los paquetes de debian sources.list
=======================================================

===
Apt
===

Apt (Advanced Package Tool) es un set de herramientas del núcleo de Debian. Apt
hace posible: instalar, eliminar, mantener sus aplicaciones al día y mucho más.

Apt, que basicamente resuelve problemas de dependencias y busca los paquetes
solicitados, trabaja con dpkg, otra herramienta que maneja la instalación y
eliminación de paquetes (aplicaciones). Apt es muy poderoso, y se usa
frecuentemente desde la línea de comandos o consola/terminal. Sin embargo, hay
muchas herramientas GUI/Gráficas para ayudarle a usar Apt sin tener que tocar la
línea de comando.

Al presente, aptitude es la herramienta recomendada para interactuar con la
suite APT. Las herramientas APT deben ser usadas especificamente para manejar
acciones que no puedan ser manejadas por aptitude, o dónde se necesite mayor
control de las dependencias.

APT utiliza un archivo que enlista las "fuentes" en donde se encuentran los
paquetes. Este archivo es: /etc/apt/sources.list

/etc/apt/sources.list 

El contenido de este archivo, normalmente sigue este formato:

deb http://host/debian distribución sección1 sección2 sección3
deb-src http://host/debian distribución sección1 sección2 sección3

Los renglones arriba mencionados son ficticios y no deberán ser usados. La
primera palabra en cada línea, deb o deb-src, indican el tipo del archivo: ya
sea que contenga paquetes binarios (deb), esto es, los paquetes pre-compilados
que normalmente se usan o los paquetes fuente (deb-src), que son los códigos
originales, más el archivo de control de Debian (.dsc) y el diff.gz que
contienen los cambios necesarios para "debianizar" el programa.

Generalmente se encuentra lo siguiente por defecto en el archivo sources.list:

# See sources.list(5) for more information, especialy
# Remember that you can only use http, ftp or file URIs
# CDROMs are managed through the apt-cdrom tool.
deb http://http.us.debian.org/debian stable main contrib non-free
deb http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free
deb http://security.debian.org stable/updates main contrib non-free

# Uncomment if you want the apt-get source function to work
#deb-src http://http.us.debian.org/debian stable main contrib non-free
#deb-src http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free

Éstas son las líneas necesarias para una instalación básica de Debian. La primer
línea deb apunta al archivo en el servidor oficial la segunda línea apunta hacia
el archivo del servidor non-US y la tercera línea apunta hacia el archivo del
servidor de actualizaciones de seguridad.

Las dos últimas líneas están deshabilitadas (con un "#" al inicio), así que
apt-get las ignora. Éstas son las líneas de deb-src esto es, apuntan hacia los
paquetes fuente de Debian. Si frecuentemente descarga paquetes fuente para
probar o recompilar habilítelas (borrando el "#" al inicio de la línea).

El archivo /etc/apt/sources.list puede contener varios tipos de líneas. APT sabe
como interpretar líneas del tipo http, ftp, file (archivos locales, p.e., un
directorio que contiene un CD-ROM) y ssh, según mis conocimientos.

No olvide ejecutar el comando apt-get update después de modificar el archivo
/etc/apt/sources.list. Debe hacer esto para permitir a APT obtener la lista de
paquetes de las fuentes que especificó.

=====================================
Enlaces físicos y simbólicos en Linux
=====================================

===============
Enlaces físicos
===============

Un enlace físico no es más que una etiqueta o un nuevo nombre asociado a un
archivo. Es una forma de identificar el mismo contenido con diferentes nombres.

Éste enlace no es una copia separada del archivo anterior sino un nombre
diferente para exactamente el mismo contenido.

Para crear un enlace físico en Linux del archivo archivo.txt a nuevo_nombre.txt

$ ln archivo.txt nuevo_nombre.txt

El enlace aparecerá como otro archivo más en el directorio y apuntará al mismo
contenido de archivo.txt.

Cualquier cambio que se haga se reflejará de la misma manera tanto para
archivo.txt como para nuevo_nombre.txt.

Un enlace se puede borrar usando el comando rm de la misma manera en que se
borra un archivo, sin embargo el contenido del iniodo no se eliminará mientras
haya un enlace físico que le haga referencia. Esto puede tener varias ventajas,
pero también puede complicar la tarea de seguimiento de los archivos.

Un enlace físico tampoco puede usarse para hacer referencia a directorios o a
archivos en otros equipos.

==================
Enlaces simbólicos
==================

Un enlace simbólico también puede definirse como una etiqueta o un nuevo nombre
asociado a un archivo pero a diferencia de los enlaces físicos el enlace
simbólico no contiene los datos del archivo, simplemente apunta al registro del
sistema de archivos donde se encuentran los datos.

Tiene mucha similitud a un acceso directo en guindows o un alias en OS X.

Situados en "b" crearemos un enlace simbólico del fichero x.txt que está en la
carpeta "a".

b$ ln -s ../a/x.txt

Éste enlace también aparecerá como otro archivo más en el directorio y apuntará
al mismo contenido de archivo.txt, reflejando todos los cambios que se hagan
tanto para archivo.txt como para nuevo_nombre.txt.

Sobre un enlace simbólico también se pueden usar todos los comandos básicos de
archivos (rm, mv, cp, etc). sin embargo cuando el archivo original es borrado o
movido a una ubicación diferente el enlace dejará de funcionar y se dice que el
enlace está roto.

Un enlace simbólico permite enlazar directorios y, usando NFS, también permite
enlazar archivos fuera del equipo.

Ejemplo práctico:

# ln -s /etc/nginx/sites-available/prueba /etc/nginx/sites-enabled/

===========
debootstrap
===========

Es una herramienta que instala un sistema basado en Debian dentro de un
subdirectorio de otro sistema ya instalado. Esto no requiere un CD de
instalación, solamente acceso a al repositorio de Debian. Este puede también
ser instalado y ejecutado desde otro sistema operativo.

Definimos un directorio en la raíz del sistema donde se ejecutará el sistema
enjaulado, en este ejemplo lo mostrare para debían Wheezy pero siguiendo la
misma secuencia y sustituyendo adecuadamente se puede instalar cualquier versión
de debían.

======
Fuente
======

-https://wiki.debian.org/es/debootstrap

======
chroot
======

Todo lo que chroot hace es, para todos los procesos hijo, reemplazar el
directorio raíz con uno especificado.

======
Fuente
======

-https://wiki.debian.org/es/debootstrap

============
jaula chroot
============

Con los programas chroot y debootstrap, es posible configurar un sistema Debian
aislado en el cual poder entrar y hacer pruebas, sin temor alguno a destruir su
sistema principal.

# mkdir /home/user/jaulas/wheezy

Instalamos la aplicación necesaria para ejecutar la jaula:

# apt-get install debootstrap

Creamos la jaula indicando el mirror

$ sudo debootstrap wheezy /home/user/jaulas/wheezy http://ftp.us.debian.org/debian/

O usamos un repo local o mas cercano para que las descarga de los ficheros sea
mas rápida

# debootstrap wheezy /home/user/jaulas/wheezy http://debian.cenditel/debian/

Y también se puede especificar la arquitectura:

# debootstrap -arch i386 /home/user/jaulas/wheezy http://ftp.es.debian.org/debian

Cuando termine, dependiendo de la velocidad de descarga, habrá creado todo el
sistema básico para correr debían wheezy en el directorio definido.

Antes de ejecutar la jaula se deben montar algunos directorios:

# mount -o bind /proc /home/user/jaulas/wheezy/proc

Si senecesita conexión a periféricos como un módem usb o una impresora estos se
guardan en el directorio /dev/ por ende tambien se debe montar.

# mount -o bind /dev/ /home/user/jaulas/wheezy/dev/

# mount -o bind /dev/pts/ /home/user/jaulas/wheezy/dev/pts/

# mount -o bind /sys/ /home/user/jaulas/wheezy/sys/

o creamos un script para montar los directorios, creamos el script: montar.sh

---

#!/bin/bash
mount -o bind /proc /home/user/jaulas/wheezy/proc
mount -o bind /dev/ /home/user/jaulas/wheezy/dev/
mount -o bind /dev/pts/ /home/user/jaulas/wheezy/dev/pts/
mount -o bind /sys/ /home/user/jaulas/wheezy/sys/

---

y lo ejecutamos con:

# ./montar.sh

Para desmontar por alguna razón (borrar la jaula por ejemplo), creamos un
desmontar.sh:

---

#!/bin/bash
umount /home/user/jaulas/wheezy/proc
umount /home/user/jaulas/wheezy/dev/
umount /home/user/jaulas/wheezy/dev/pts/
umount /home/user/jaulas/wheezy/sys/

---

# ./desmontar

A partir de este momento ya tienes el sistema listo y puedes hacer cualquier
tipo de prueba sin que corra riesgo tu sistema base para salir de la jaula y
continuar con tu sistema solo debes ejecutar:

# exit

Para accecer a la jaula o ejecutarla debes ser usuario root o usar sudo

# chroot /home/user/jaulas/wheezy

===========================
Instalar el paquete locales
===========================

# apt install locales y locales-all

$ dpkg-reconfigure locales

Escogemos las configuraciones regionales que desea generar:

es_VE.UTF-8 UTF-8

Configuración regional predeterminada para el entorno del sistema:
es_VE.UTF-8

==================================================
Montando una jaula para GNU-Linux Debian 10 Buster
==================================================

Instalar la jaula

# debootstrap buster /home/user/jaulas/debian/buster http://deb.debian.org/debian/

Montar directorios

# mount -o bind /proc /home/user/jaulas/debian/buster/proc/

# mount -o bind /dev/ /home/user/jaulas/debian/buster/dev/

# mount -o bind /dev/pts/ /home/user/jaulas/debian/buster/dev/pts/

# mount -o bind /sys/ /home/user/jaulas/debian/buster/sys/

El siguiente paso solo se realiza luego de comprobar que los archivos no
existan:

Copiar el archivo /etc/hosts del entorno principal al entorno chroot:

# cp /etc/apt/sources.list /home/user/jaulas/debian/buster/etc/apt/sources.list

# cp /etc/hosts /home/user/jaulas/debian/buster/hosts

Acceder a la jaula

# chroot /home/user/jaulas/debian/buster

====
Nota
====

Este sistema solo puede ejecutar aplicaciones en el terminal si se requiere
interfaz gráfica se debe utilizar una aplicación como Xnest que su utilización
te detallo a continuación:

$ sudo apt-get xnest

Ejecución:

En terminal 1 ejecutas 

$ Xnest -ac -geometry 800x600 :1 

en un segundo terminal inicias la jaula 

# sudo chroot /jaulas/wheezy 

y dentro de la jaula ejecutas 

# export DISPLAY=localhost:1 

En este momento toda aplicación que ejecutes en dicha jaula que posea interfaz
gráfica se mostrara en la pantalla mostrada por Xnest adicionalmente cabe
destacar que puedes colocar cualquier geometria de ventana al ejecutar xnest.

Cada ves que reinicies la pc debes volver a montar los directorios /proc,
/dev/pts y /dev, esto lo puedes automatizar agregando las siguientes siguientes
lineas en el archivo /etc/fstab o corriendo un script con esas sentencias.

/proc      /home/user/jaulas/wheezy/proc/        auto     bind 0       0
/dev       /home/user/jaulas/wheezy/dev/pts/     auto     bind 0       0
/dev/pts   /home/user/jaulas/wheezy/dev/pts/     auto     bind 0       0
/sys       /home/user/jaulas/wheezy/sys/      auto     bind 0       0

Descargamos los paquetes locales y locales-all y ejecutamos:

$ dpkg-reconfigure locales 

Escogemos las configuraciones regionales que desea generar:

es_VE.UTF-8 UTF-8

Configuración regional predeterminada para el entorno del sistema:
es_VE.UTF-8

Listo, jaula de wheezy lista!

=========================
Remover un entorno chroot
=========================

Desmontar los directorios montados y borrar el directorio que alverga la jaula
(wheezzy)

================================
El error con el update y el /tmp
================================

Couldn't create temporary file /tmp/apt.conf for passing config to apt-key

# chown root:root /tmp

# chmod ugo+rwXt /tmp

====================
Variables de entorno
====================

Las variables de entorno contienen información a la que se accede a través del
nombre de la variable (al igual que ocurre en los lenguajes de programación).

Por ejemplo, PWD es una variable de entorno. Algo que puedo comprobar así:

$ echo $PWD
/home/user

Lo que significa que el comando "pwd" es una llamada a "echo $PWD"

Consultar todas mis variables de entorno.

$ env

$ printenv

Crear una variable de entorno

$ export name_var=Value

Eliminar una variable de entorno

$ export name_var=

============
Terminal tty
============

tty es la consola que nos permite en GNU/Linux acceder a nuestro sistema
operativo fuera de su entorno gráfico (X-Window). En general disponemos de hasta
seis terminales, para acceder:

Ctrl + Alt + F1 para acceder a la primera, F2 para la segunda y así hasta F6
para la sexta y F7 para volver al entorno gráfico.

No debemos confundir las consolas tty con la que habitualmente usamos sobre el
entorno gráfico X-Window.

=======
tasksel
=======

El paquete Tasksel proporciona una interfaz sencilla para los usuarios que
quieren configurar su sistema para realizar una tarea específica. Este programa
es utilizado durante el proceso de instalación, pero los usuarios puede usarlo
también en cualquier momento.

=====================
Entorno de escritorio
=====================

Después de instalar un sistema básico, usted puede instalar el
DesktopEnvironment utilizando tasksel. La orden tasksel (ingresado como root)
le muestra algunas opciones (de alto nivel de abstraccion) para instalar
paquetes. Podría usted simplemente marcar la opción Desktop environment.

Instalará los paquetes de Gnome y algunos paquetes considerados como estándar
para un escritorio Debian.

====
dhcp
====

DHCP (siglas en inglés de Dynamic Host Configuration Protocol, en español
«protocolo de configuración dinámica de host») es un servidor que usa protocolo
de red de tipo cliente/servidor en el que generalmente un servidor posee una
lista de direcciones IP dinámicas y las va asignando a los clientes conforme
éstas van quedando libres, sabiendo en todo momento quién ha estado en posesión
de esa IP, cuánto tiempo la ha tenido y a quién se la ha asignado después. Así
los clientes de una red IP pueden conseguir sus parámetros de configuración
automáticamente.

============================
Asignación de direcciones IP
============================

Cada dirección IP debe configurarse manualmente en cada dispositivo y, si el
dispositivo se mueve a otra subred, se debe configurar otra dirección IP
diferente. El DHCP le permite al administrador supervisar y distribuir de forma
centralizada las direcciones IP necesarias y, automáticamente, asignar y enviar
una nueva IP si fuera el caso en que el dispositivo es conectado en un lugar
diferente de la red.

El protocolo DHCP incluye tres métodos de asignación de direcciones IP:

============================
Asignación manual o estática
============================

Asigna una dirección IP a una máquina determinada. Se suele utilizar cuando se
quiere controlar la asignación de dirección IP a cada cliente, y evitar,
también, que se conecten clientes no identificados.

=====================
Asignación automática
=====================

Asigna una dirección IP a una máquina cliente la primera vez que hace la
solicitud al servidor DHCP y hasta que el cliente la libera. Se suele utilizar
cuando el número de clientes no varía demasiado.

===================
Asignación dinámica
===================

El único método que permite la reutilización dinámica de las direcciones IP. El
administrador de la red determina un rango de direcciones IP y cada dispositivo
conectado a la red está configurado para solicitar su dirección IP al servidor
cuando la tarjeta de interfaz de red se inicializa. El procedimiento usa un
concepto muy simple en un intervalo de tiempo controlable. Esto facilita la
instalación de nuevas máquinas clientes.

Algunas implementaciones de DHCP pueden actualizar el DNS asociado con los
servidores para reflejar las nuevas direcciones IP mediante el protocolo de
actualización de DNS establecido en RFC 2136 (Inglés).

El DHCP es una alternativa a otros protocolos de gestión de direcciones IP de
red, como el BOOTP (Bootstrap Protocol). DHCP es un protocolo más avanzado, pero
ambos son los usados normalmente.

======================
Configuración del grub
======================

Fichero de configuración donde se define el tiempo de espera del grup para
mostrar la lista de SO disponibles y sus opciones.

/etc/default/grub

=====================================
w3m - Nnavegador web desde la consola
=====================================

w3m es un navegador web basados en texto/paginador.

# apt-get install w3m

Para iniciar el navegador en modo interactivo

$ w3m https://www.debian.org

Volcado de una página con formato de salida estándar

$ w3m https://www.debian.org -dump

=====================================
Atajos de teclado en modo interactivo
=====================================

Salir del navegador: q
Página anterior: B
Descargar página actual: a
Ir a inicio: g
Saltar al final: G
Desplazarse hacia arriba una página: -
Desplazarse hacia abajo una página: +
Abrir URL: U

=========================================
apg - generador automático de contraseñas
=========================================

apg (Automatic Password Generator)

Instalación:

# apt-get install apg

Apg es capaz de generar un listado de contraseñas.

Usa un algoritmo para generar contraseñas pronunciables e impronunciables
también permite generar contraseñas aleatorias definidas a partir de conjuntos
de símbolos definidos por el usuario (dígitos, letras mayúsculas y minúsculas, y
símbolos especiales.) Por defecto, apg genera 6 contraseñas con caracteres
alfanuméricos que además son pronunciables (en inglés)

$ apg

Please enter some random data (only first 16 are significant)
(eg. your old password):>
OrwefdyetEc6 (Or-wef-dyet-Ec-SIX)
9ovCaulvac5 (NINE-ov-Caulv-ac-FIVE)
EryidribMeb7 (Er-yi-drib-Meb-SEVEN)
beoddIcox2 (be-odd-Ic-ox-TWO)
Oamyalirl6 (Oam-yal-irl-SIX)
IgPiham1 (Ig-Pi-ham-ONE)

Ahora generemos 4 contraseñas con una longitud mínima de 8 caracteres, máxima de
12 y que además sean impronunciables, usan el segundo algoritmo:

-n x = Número de contraseñas a generar.
-m x = Mínimo de caractéres que deberá tener la contraseña.
-x x = Máximo de caractéres que deberá tener la contraseña.

$ apg -n 4 -m 8 -x 8 -a 1

Mínimo 8 máximo 12, incluyendo caractéres especiales.

$ apg -n 4 -m 8 -x 12 -a 1

Mínimo 8 máximo 12, incluyendo caractéres especiales en menor medida.

$ apg -n 4 -m 8 -x 12 -a 0

===================================================
Actualizar la versión de GNU/Linux Debian instalada
===================================================

En este ejemplo actualizaremos la versión GNU/Linux Debian 8 a la 9.

Actualizamos el fichero source.list con los repositorios de GNU/Linux Debian 9
Stretch. Como usuario root editamos y comentamos todo su contenido, los
comentarios en ese fichero comienzan con #.

# nano /etc/apt/sources.list

Una vez que todo esté comentado, agregamos lo siguiente:

# ==========================
# Debian GNU/Linux 9 Stretch
# ==========================

deb http://deb.debian.org/debian stretch-updates main
deb http://deb.debian.org/debian stretch main contrib non-free
deb http://http.debian.net/debian/ stretch main contrib non-free
deb http://security.debian.org/debian-security/ stretch/updates main
deb https://fasttrack.debian.net/debian-fasttrack/ stretch-fasttrack main contrib
deb https://fasttrack.debian.net/debian-fasttrack/ stretch-backports-staging main contrib

Actualizamos la lista de los repositorios con:

# apt-get update

Actualizamos los paquetes del sistema, para que instale las versiones de
GNU/Linux Debian 9 Stretch:

# apt-get upgrade

Finalmente actualizamos todo de manera inteligente y segura:

# apt-get dist-upgrade

Ahora Reiniciamos el sistema, con eso ya deberíamos estar en GNU/Linux Debian 9
Stretch:

# reboot

Hay que estar pendiente de la consola, porque seguro va a pedir revisión manual
de algunos paquetes, donde te dirá si quieres conservar la versión y
configuración actual, como ssh, vim, postgresql, otros...

====================
sources.list example
====================

En distribuciones GNU/Linux derivadas de Debian el fichero sources.list es el
archivo hallado donde se enlistan las "fuentes" o "repositorios" disponibles de
los paquetes de software candidatos a ser: actualizados, instalados, removidos,
buscados, sujetos a comparación de versiones, etc.

**The format is
deb <respository server/mirror> <repository name> <sub branches of the repo>

#===== Debian GNU/Linux Testing & Unstable =====

# Testing repository - main, contrib and non-free branches
#deb http://http.us.debian.org/debian testing main non-free contrib
#deb-src http://http.us.debian.org/debian testing main non-free contrib

# Testing security updates repository
#deb http://security.debian.org/ testing/updates main contrib non-free
#deb-src http://security.debian.org/ testing/updates main contrib non-free

# Unstable repo main, contrib and non-free branches, no security updates here
#deb http://http.us.debian.org/debian unstable main non-free contrib
#deb-src http://http.us.debian.org/debian unstable main non-free contrib

#===== Debian GNU/Linux 12 (Bookworm) =====

deb http://deb.debian.org/debian bookworm main contrib non-free

#===== Debian GNU/Linux 11 (bullseye) Updates =====

deb http://deb.debian.org/debian bullseye main contrib non-free
deb http://deb.debian.org/debian bullseye-updates main
# Actualizaciones de seguridad
deb http://security.debian.org/debian-security bullseye-security main contrib non-free

#===== Debian GNU/Linux 10 (Buster) Updates =====

deb http://deb.debian.org/debian buster main contrib non-free
deb-src http://deb.debian.org/debian buster main contrib non-free

deb http://security.debian.org/debian-security/ buster/updates main contrib non-free
deb-src http://security.debian.org/debian-security/ buster/updates main contrib non-free

#===== Non free =====

deb http://deb.debian.org/debian buster main contrib non-free
deb-src http://deb.debian.org/debian buster main contrib non-free

#===== Debian GNU/Linux 9 (Stretch) Updates =====

deb http://deb.debian.org/debian stretch main contrib non-free
deb-src http://deb.debian.org/debian stretch main contrib non-free

deb http://security.debian.org/debian-security/ stretch/updates main contrib non-free
deb-src http://security.debian.org/debian-security/ stretch/updates main contrib non-free

deb http://deb.debian.org/debian stretch-updates main contrib non-free
deb-src http://deb.debian.org/debian stretch-updates main contrib non-free

#===== Non free =====

#deb http://deb.debian.org/debian stretch main contrib non-free
#deb-src http://deb.debian.org/debian stretch main contrib non-free

#===== Debian GNU/Linux 8 (Jessie) Estable =====

# Repositorio Oficial
deb http://http.us.debian.org/debian/ jessie main contrib non-free
deb-src http://http.us.debian.org/debian/ jessie main contrib non-free
deb http://httpredir.debian.org/debian/ jessie main
deb-src http://httpredir.debian.org/debian/ jessie main

# jessie-updates, previously known as 'volatile'
deb http://httpredir.debian.org/debian/ jessie-updates main
deb-src http://httpredir.debian.org/debian/ jessie-updates main

# Repositorio de Seguridad
deb http://security.debian.org/ jessie/updates main contrib non-free
deb-src http://security.debian.org/ jessie/updates main contrib non-free
deb http://security.debian.org/ jessie/updates main
deb-src http://security.debian.org/ jessie/updates main

#===== Debian GNU/Linux 7 (Wheezy) Estable =====

#Repositorio Oficial
deb http://ftp.us.debian.org/debian/ wheezy main contrib
deb-src http://ftp.us.debian.org/debian/ wheezy main contrib

#Actualizaciones de Seguridad
deb http://security.debian.org/ wheezy/updates main contrib
deb-src http://security.debian.org/ wheezy/updates main contrib

#Actualizaciones de Wheezy
deb http://ftp.debian.org/debian wheezy-updates main contrib non-free
deb-src http://ftp.debian.org/debian wheezy-updates main contrib non-free

#Backports
deb http://ftp.debian.org/debian/ wheezy-backports main

#===== Debian GNU/Linux 8 (Jessie) Multimedia repo =====

deb http://www.deb-multimedia.org jessie main non-free
#or
#deb ftp://ftp.deb-multimedia.org jessie main non-free
#or
#deb http://www.deb-multimedia.org stable main non-free
#or
#deb ftp://ftp.deb-multimedia.org stable main non-free

#===== Debian GNU/Linux 7 (Wheezy) Multimedia repo =====

deb http://www.deb-multimedia.org wheezy main
#or
#deb ftp://ftp.deb-multimedia.org wheezy main
#or
#deb http://www.deb-multimedia.org oldstable main
#or
#deb ftp://ftp.deb-multimedia.org oldstable main

#===== CENDITEL mirror - Debian GNU/Linux 11 (Bullseye) =====

# Debian CENDITEL
deb http://debian.cenditel/debian bullseye main contrib non-free
deb http://debian.cenditel/debian bullseye-updates main contrib non-free
deb http://debian.cenditel/debian bullseye-proposed-updates main contrib non-free
deb http://debian.cenditel/debian bullseye-updates main contrib non-free
deb http://debian.cenditel/debian-security bullseye-security main contrib non-free
deb http://debian.cenditel/debian-multimedia bullseye main non-free

Para que no falle la firma del repositorio multimedia ejecute:

$ wget http://www.deb-multimedia.org/pool/main/d/deb-multimedia-keyring/deb-multimedia-keyring_2016.8.1_all.deb

Luego instale con dpkg

# dpkg -i *.deb

Pero se recomienda:

# Debian CENDITEL
deb http://debian.cenditel/debian bullseye main contrib non-free
deb http://debian.cenditel/debian bullseye-updates main contrib non-free
deb http://debian.cenditel/debian-security bullseye-security main contrib non-free

#===== CENDITEL mirror - Debian GNU/Linux 10 (Buster) =====

deb http://debian.cenditel/debian buster main contrib non-free
deb-src http://debian.cenditel/debian stretch main contrib non-free

deb http://debian.cenditel/debian buster-updates main contrib non-free
deb-src http://debian.cenditel/debian stretch-updates main contrib non-free

#===== CENDITEL mirror - Debian GNU/Linux 9 (Stretch) =====

deb http://debian.cenditel/debian stretch main contrib non-free
deb-src http://debian.cenditel/debian stretch main contrib non-free

deb http://debian.cenditel/debian stretch-updates main contrib non-free
deb-src http://debian.cenditel/debian stretch-updates main contrib non-free

deb http://debian.cenditel/debian-security stretch/updates main contrib non-free
deb-src http://debian.cenditel/debian-security stretch/updates main contrib non-free

#===== CENDITEL mirror - Debian GNU/Linux 8 (Jessie) Estable =====

deb http://debian.cenditel/debian/ jessie main contrib non-free
deb-src http://debian.cenditel/debian/ jessie main contrib non-free

# jessie-updates, previously known as 'volatile'
deb http://debian.cenditel/debian/ jessie-updates main contrib non-free
deb-src http://debian.cenditel/debian/ jessie-updates main contrib non-free

#deb http://repositorio.cenditel.gob.ve/debian/ jessie main contrib non-free
#deb http://tibisay.cenditel.gob.ve/repositorio jessie main contrib non-free

# Agregar la llave del repositorio al sistema, como root escribimos:
# wget -q -O- http://repositorio.cenditel.gob.ve/debian/repositorio_cenditel.asc | apt-key add -

#===== CENDITEL mirror - Debian GNU/Linux 7 (Wheezy) Estable =====

deb http://debian.cenditel/debian/ wheezy main
deb-src http://debian.cenditel/debian/ wheezy main

# wheezy-updates, previously known as 'volatile'
deb http://debian.cenditel/debian/ wheezy-updates main
deb-src http://debian.cenditel/debian/ wheezy-updates main

======================
Repositorios de Debian
======================

Aquí podemos encontrar un espejo donde poder descargar los paquetes de todas las
versiones de Debian:http://archive.debian.org/debian/README

O simplemente agregando el repositorio en el source.list, por ejemplo:

#deb http://archive.debian.org/debian/ squeeze main contrib
#deb http://archive.debian.org/debian/ wheezy main contrib
deb http://archive.debian.org/debian/ jessie main contrib

===========================================
Para compilacion y construcción de paquetes
===========================================

build-essential
gcc
dpkg-dev
fakeroot
cmake
devscripts
autoconf
automake
dh-make
debhelper
autotools-dev
gnupg
lintian
quilt
packaging-dev

==========
Desarrollo
==========

curl
Sublime (Instalar el .deb de la página o buscar en los repos, > a v2.)
python (Probarlo)
python-pip
virtualenv
virtualenvwrapper
python-requests
django (Opcional)
    pip install django-compressor (Opcional)
    pip install south (Opcional)
    pip install django-extensions (Opcional)

ruby (Probarlo)
ruby on rails (Opcional)
Qt-Creator (Opcional)

=====================
Navegador Web Firefox
=====================

Poner firefox en español.

# apt-get install firefox-esr-l10n-es-es

-----

Poner el libreoffice en español.

# apt-get install libreoffice-l10n-es

-----

Poner el libreoffice en español de venezuela.

# apt-get install libreoffice-l10n-ve

-----

adblock-plus para bloquear puplicidad.

https://addons.mozilla.org/es/firefox/addon/adblock-plus/

-----

Complemento de Firefox para traducir las páginas a español con un click.

https://addons.mozilla.org/es/firefox/addon/traduzir-paginas-web/

-----

Tema Hacker para firefox

https://addons.mozilla.org/es/firefox/addon/hacker-animated/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=rating

-----

Diccionario en español Venezuela para firefox

Marca en rojo las palabras mal escritas.

https://addons.mozilla.org/es/firefox/addon/diccionario-espa%C3%B1ol-venezuela/

===============================
Touch VPN, una VPN para Firefox
===============================

1) Navegar hasta https://addons.mozilla.org/es/firefox/addon/touch-vpn/

2) “Agregar a Firefox” y se instalará.

2) Ir a Touch Firefox VPN.

Aunque está en inglés no será ningún problema conectarte a cualquiera de las 7
ubicaciones disponibles de esta vpn, haces clic en donde dice “best choice” o
puedes escoger entre: Alemania, Canadá, Rusia, Países Bajos, Estados Unidos,
Francia y Reino Unido para cambiar tu IP.

=====================================
Complemento web developer form filler
=====================================

Complete formularios en sitios web, guarde los datos del formulario con un click
y rellene fácilmente los formularios con los datos guardados de nuevo con un
click.

Fuente
======

https://addons.mozilla.org/es/firefox/addon/web-dev-form-filler/

===========================================================================
Instalación de Virtualbox 6 con el .run de la página en GNU/Linux Debian 11
===========================================================================

Descargar el .run desde https://www.virtualbox.org/wiki/Linux_Downloads

De la lista, descargar el que dice "All distributions (built on EL6 and
therefore not requiring recent system libraries)"

En este caso he descargado el VirtualBox-6.1.22-144080-Linux_amd64.run

$ sudo apt install build-essential linux-headers-amd64

$ sudo chmod +x VirtualBox*.run

$ sudo ./VirtualBox*.run

Los siguientes pasos no los ejecuté, ya que sirvió hasta el paso anterior.

$ vboxversion=$(wget -qO - https://download.virtualbox.org/virtualbox/LATEST.TXT)

$ wget "https://download.virtualbox.org/virtualbox/${vboxversion}/Oracle_VM_VirtualBox_Extension_Pack-${vboxversion}.vbox-extpack"

$ sudo vboxmanage extpack install --replace Oracle_VM_VirtualBox_Extension_Pack-${vboxversion}.vbox-extpack

$ sudo usermod -aG vboxusers [username]

$ sudo reboot

=======================================================
Instalación de Virtualbox en GNU/Linux Debian 9 Stretch
=======================================================

Agregamos la siguiente línea en el /etc/apt/sources.list

deb http://download.virtualbox.org/virtualbox/debian stretch contrib

Añade la Public Key de VirtualBox 5.2

# apt-get install curl

$ curl -O https://www.virtualbox.org/download/oracle_vbox_2016.asc

# apt-key add oracle_vbox_2016.asc

# apt-get update

# apt-get install virtualbox-5.2

==========================================================================
Instalación en GNU/Linux Debian 9 Stretch desde los repositorios backports
==========================================================================

Agregamos la siguiente línea en el /etc/apt/sources.list

deb http://deb.debian.org/debian/ stretch-backports main contrib non-free

# apt-get update

# apt-get install virtualbox

=======================================================
Instalación de Virtualbox en GNU/Linux Debian 10 Buster
=======================================================

Hay que poner a apuntar a los repositorios de Stretch y seguir los pasos de
arriba y ligar que no haya peos con dependencias y versiones de paquetes,
prender una vela a Neo en este proceso.

# apt-get install virtualbox-5.2

y si da peo instalar

# apt install virtualbox-5.1

=================================================
Instalar Guest Additions de Virtual Box en Debian
=================================================

Primero instalamos los siguientes paquetes:

# apt-get install build-essential

# apt-get install linux-headers-$(uname -r)

En el menú de VirtualBox de la máquina “guest” con Debian pulsamos en
Dispositivos / Insertar imagen de CD de las Guest Additions.

Por lo general, Virtualbox trae integrada entre sus ficheros las Guest Additions
en una imágen .iso, siguiendo el paso anterior esa imagen debería montarse
automáticamente, ahora solo queda ejecutar el script de instalación:

# bash /media/cdrom0/VboxLinuxAdditions.run

Si no hay problemas con la instalación, reiniciamos la máquina virtual  y ya se
debería poder usar el modo pantalla completa, el modo fluido o la función de las
carpetas compartidas.

======================
Desinstalar VirtualBox
======================

# apt-get remove --purge virtualbox

# rm -rf VirtualBox\ VMs/

# rm -rf .config/VirtualBox/

=====
Otros
=====

Usar tty en la máquina virtual

Entrar en tty1 desde la máquina virtual, lo mismo para ttyn...

RightCtrl + F1

===========
Gnome Boxes
===========

GNOME Boxes es una aplicación del entorno de escritorio GNOME, que se utiliza
para acceder a sistemas remotos o virtuales. Boxes utiliza las tecnologías de
virtualización QEMU, KVM y libvirt.

GNOME Boxes requiere que la CPU sea compatible con algún tipo de virtualización
sistida por hardware (Intel VT-x , por ejemplo); por lo tanto, GNOME Boxes no
funcionan con las CPU con procesador Intel Pentium / Celeron ya que carecen de
esta característica.

Instalación
===========

# apt-get install -y gnome-boxes qemu-kvm libvirt0 virt-manager bridge-utils

¿Dónde guarda Cajas las imágenes de los discos?
===============================================

/home/user/.local/share/gnome-boxes/images

================
Debian backports
================

Proporciona paquetes para nuevas versiones de determinadas aplicaciones que se
van incluyendo a lo largo del periodo de vida de la versión. Sin embargo desde
el sitio oficial (http://backports.debian.org/Instructions/) recomiendan
utilizar este repositorio con precaución ya que en ocasiones pueden existir
incompatibilidades de dependencias entre estos paquetes y los estables.

=====
bind9
=====

El Nombre de Dominio de Internet de Berkeley (BIND) implementa un servidor de
nombres de dominio de Internet. BIND es el servidor de nombres más ampliamente
utilizado en Internet, y tiene el respaldo del Consorcio de «Software» de
Internet, www.isc.org. Este paquete proporciona el servidor y los archivos de
configuración relacionados.

Instalación del paquete bind9

# apt-get install bind9 bind9-doc

Editamos /etc/resolv.conf para que lea el localhost

nameserver 127.0.0.1

En /etc/bind están los archivos de configuración del paquete.

====
vlan
====

Una VLAN, acrónimo de virtual LAN (Red de área local virtual), es un método para
crear redes lógicas independientes dentro de una misma red física.

Varias VLAN pueden coexistir en un único conmutador físico o en una única red
física. Son útiles para reducir el tamaño del dominio de difusión y ayudan en la
administración de la red, separando segmentos lógicos de una red de área local
(los departamentos de una empresa, por ejemplo) que no deberían intercambiar
datos usando la red local (aunque podrían hacerlo a través de un enrutador o un
conmutador de capa 3 y 4).

Una VLAN consiste en dos o más redes de computadoras que se comportan como si
estuviesen conectados al mismo conmutador, aunque se encuentren físicamente
conectados a diferentes segmentos de una red de área local (LAN). Los
administradores de red configuran las VLAN mediante software en lugar de
hardware, lo que las hace extremadamente fuertes.

===
vpn
===

Una red privada virtual (en inglés: Virtual Private Network (VPN)) es una
tecnología de red de computadoras que permite una extensión segura de la red de
área local (LAN) sobre una red pública o no controlada como Internet.

Permite que la computadora en la red envíe y reciba datos sobre redes
compartidas o públicas como si fuera una red privada con toda la funcionalidad,
seguridad y políticas de gestión de una red privada.

Esto se realiza estableciendo una conexión virtual punto a punto mediante el uso
de conexiones dedicadas, cifrado o la combinación de ambos métodos.

Ejemplos comunes son la posibilidad de conectar dos o más sucursales de una
empresa utilizando como vínculo Internet, permitir a los miembros del equipo de
soporte técnico la conexión desde su casa al centro de cómputo, o que un usuario
pueda acceder a su equipo doméstico desde un sitio remoto, como por ejemplo un
hotel. Todo ello utilizando la infraestructura de Internet.

La conexión VPN a través de Internet es técnicamente una unión wide area network
(WAN) entre los sitios pero al usuario le parece como si fuera un enlace
privado, de allí la designación "virtual private network".

===================================
Desactivar actualización en firefox
===================================

Probado en Firefox 55 o menor.

La desactivación la podemos hacer desde la interfáz del navegador pero para
hacerla a nivel de codigo editamos el fichero:

firefox/defaults/pref/channel-prefs.js

Nos quedará así:

---

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/*pref("app.update.channel", "release");*/
pref("app.update.channel", "false");

---

Guardamos, reiniciamos el firefox y listo, actualizaciones desactivadas.

=====================
Reiniciar un servicio
=====================

Funcional para GNU/Linux Debian 7 Wheezy

user@debian7:~$ /etc/init.d/ssh 
force-reload  reload        restart       start         status        stop          try-restart   
user@debian7:~$ /etc/init.d/ssh restart

==========================================================
Instalar esto para porder descargar repositorios con https
==========================================================

# apt-get install apt-transport-https

=================================================
Winetricks, Instalando librerias (DLLs) para Wine
=================================================

Wine es la aplicacion que generalmente empleamos para ejecutar aplicaciones de
Windows en Linux, pero muchas veces, la aplicacion falla porque no tenemos una
determinada libreria de enlace dinamico (DLL) instalada. Winetricks es un script
que nos va a ayudar un poco en esta faena, con este script podemos descargar e
instalar en wine, las principales librerias que nos solicitan los programas
windows.

Para instalarlo:

$ wget http://www.kegel.com/wine/winetricks

Le damos permisos de ejecucion:

$ chmod +x ./winetricks

Y si quisieramos ya instalar una determinada libreria, podriamos hacerlo
directamente. Por ejemplo:

$ sh winetricks corefonts vcrun6

Para instalar unas fuentes de texto, y el runtime de VisualC.

Si lo ejecutamos sin parametros, se abre una ventana y nos permite seleccionar
las librerias a instalar.

======
Fuente
======

-https://ubuntulife.wordpress.com/2008/10/16/winetricks-instalando-librerias-dlls-para-wine/

=====
xkill
=====

Probado en gnome-desktop

xkill permite formar el cierre de programas rebeldes desde la interfáz gráfica,
con solo escribir xkill en la consola el cursor del mouse se transforma en una
calavera, acto seguido podemos cliquear derecho sobre alguna ventana para matar
ese proceso.

$ xkill

===================
Instalar Unetbootin
===================

Netbootin le permite crear unidades USB Live de Ubuntu y otras distribuciones de
Linux sin necesidad de grabar un CD.

Página para descarga: https://unetbootin.github.io/linux_download.html

Podemos descargamos directamente el .bin, este enlace es para arquitecturas de
64bits

$ wget -c https://github.com/unetbootin/unetbootin/releases/download/657/unetbootin-linux64-657.bin

Eso nos descargara el fichero unetbootin-linux64-657.bin

Instalamos lo siguiente, que son unas herramientas para manipular archivos
MSDOS.

# apt-get install mtools

Para correrlo

# ./unetbootin-linux64-657.bin

Listo, se nos debería ejecutar la ventana del programa.

============================================
Instalar Google Chrome en GNU/Linux Debian 8
============================================

Primero hay que añadir un repositorio de google en el  /etc/apt/sources.list, es el siguiente:

# Chrome de 64bits
deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main

Ahora añadimos la llave pública del repositorio “Google Chrome stable” a apt.

# gpg --keyserver keys.gnupg.net --recv-key A040830F7FAC5991

# gpg --export --armor A040830F7FAC5991 | apt-key add -

Actualizamos la lista de paquetes de los repositorios.

# apt-get update

Si sale el siguiente error:

W: No existe ninguna clave pública disponible para los siguientes
identificadores de clave:
1397BC53640DB551

Ejecutamos los siguiente:

# wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | apt-key add -

Actualizamos la lista de paquetes de los repositorios.

# apt-get update

Ahora instalamos Google Chrome stable con:

# apt-get install google-chrome-stable

Si toda va bien, debería estar disponible en la sección internet de nuestro
GNU/Linux Debian 8 o 9

==================================================
Instalar Google Chrome en GNU/Linux Debian 10 y 11
==================================================

Debes descargar el paquete de la siguiente URL:

https://www.google.com/chrome/

En este caso, descargué el de 64Bits

Antes de instalar el paquete debes tener instalada el paquete wget, que es una
dependencia que se debe cumplir para poder instalar Chrome, lo puedes hacer con
este comando:

$ sudo apt install wget libappindicator3-1

De libappindicator, Instalas el que esté disponible, en mi caso el 3-0.

Luego puedes instalar Google Chrome, mediante el comando:

$ sudo dpkg -i google-chrome-stable_current_amd64.deb

Luego lo lanzas con:

$ google-chrome

Listo!

=======================================
Instalar Chromium en GNU/Linux Debian 8
=======================================

# apt-get install chromium chromium-l10n

===================================
Instalar extensiones en LibreOffice
===================================

# apt-get install myspell-es

Este es el diccionario de español para usar con el corrector ortográfico
myspell, que actualmente se usa en OpenOffice.org y el corrector ortográfico de
mozilla. Al parecer con esto basta pero a mi no me funciono esa mierda, de todas
maneras se debe comprobar primero a ver si funcionó, si no funciono, entonces
hacer lo siguiente:

Hay que bajarse un .oxt, investigarlo, luego desde el LibreOffice

Herramientas > Gestor de extensiones > Buscar el .oxt descargado

En este caso lo he probado con spanish-dictionary.oxt que es la extensión para
que funcione la correción de errores.

======
cheese
======

# apt-get install cheese

A webcam application that supports image and video capture.

Paquete para probar la cámara web de la computadoras/laptop en debian.

===========
pavucontrol
===========

# apt-get install pavucontrol

PulseAudio Volume Control (pavucontrol) es una herramienta de control de volumen
basada en GTK + (mezclador) para el servidor de sonido PulseAudio. A diferencia
de las herramientas de mezclador clásicas, esta le permite controlar tanto el
volumen de los dispositivos de hardware como los de cada secuencia de
reproducción por separado. También le permite redirigir una secuencia de
reproducción a otro dispositivo de salida sin interrumpir la reproducción.

=====================================
Debian 8 (live cd) login and password
=====================================

username "user" and the default password "live".

=============================================================
Resetear password o contraseña del usuario root desde el grub
=============================================================

Cuando inicia la pc y estando en el grub, seleccionamos editar presionando la
letra e

Esto nos abre un fichero que podemos editar, ubicamos la parte que dice:

linux /boot/vmlinuz-3.2.0-4-xxx-xxx root=UUID=04064ae3XXXXXXXX ro quiet

y agregamos al final de esa línea lo siguiente: init=/bin/bash y nos quedará así:

linux /boot/vmlinuz-3.2.0-4-xxx-xxx root=UUID=04064ae3XXXXXXXX ro quiet init=/bin/bash

Presionamos f10 para que se guarden los cambios y continúe con la carga del
sistema, luegos nos aparece la terminal o consola, como root.

Escribiremos el siguiente comando para montar el sistema de ficheros:

# mount -o remount -rw /

Luego ya procedemos a cambiar la contraseña de root, ejecutamos el comando:

# passwd root

El sistema nos pide la nueva contraseña, luego nos pide que la volvamos a
escribir la nueva contraseña y validara que sea iguales. (cuando ponemos la
contraseña por seguridad en linux no aparece lo que tecleamos y al terminar de
poner la contraseña pulsamos enter y ¡listo! Contraseña del usuario root
cambiada.

=======
Fuentes
=======

http://primeros-pasos-linux.blogspot.com/2013/03/guia-pasoa-apaso-recuperar-contrasena.html

==================================
Encriptar directorios con Ecryptfs
==================================

ECryptfs es una herramienta que nos permite encriptar la informacion contenida
en un directorio.

Instalamos ecryptfs:

# apt-get install ecryptfs-utils

Creamos el directorio a encriptar

$ mkdir private

Asignamos permisos para que solo nuestro usuario pueda acceder

$ chmod 700 private

Montamos el nuevo filesystem eCryptfs en la nueva carpeta creada:

# mount -t ecryptfs private private

Nos hara una serie de preguntas como la palabra secreta a utilizar. Por defecto
usa la encriptación AES, con una longitud de 16 bytes de longitud.

En resumen, las preguntas que nos hace son:

La passphrase o la clave para la encriptación.

El algoritmo de cifrado que de manera predeterminada es AES.

Magnitud de la clave, que es de 16 bytes de manera predeterminada Plaintext
passthrough para poder llegar a ficheros que no están cifrados.

filename encryption o encriptar los nombres de los ficheros, esta opción me ha
dado algunos problemas, me falta seguir probandola bien para poder recomendarla,
por ahora no la usaremos.

# mount -t ecryptfs private private
Select key type to use for newly created files:
 1) tspi
 2) passphrase
Selection: 2
Passphrase:
Select cipher:
 1) aes: blocksize = 16; min keysize = 16; max keysize = 32
 2) blowfish: blocksize = 8; min keysize = 16; max keysize = 56
 3) des3_ede: blocksize = 8; min keysize = 24; max keysize = 24
 4) twofish: blocksize = 16; min keysize = 16; max keysize = 32
 5) cast6: blocksize = 16; min keysize = 16; max keysize = 32
 6) cast5: blocksize = 8; min keysize = 5; max keysize = 16
Selection [aes]: 1
Select key bytes:
 1) 16
 2) 32
 3) 24
Selection [16]: 1
Enable plaintext passthrough (y/n) [n]: n
Enable filename encryption (y/n) [n]: n
Attempting to mount with the following options:
  ecryptfs_unlink_sigs
  ecryptfs_key_bytes=16
  ecryptfs_cipher=aes
  ecryptfs_sig=5e2dd35dd40f619a
Mounted eCryptfs

Ahora ya podemos crear archivos, moverlos, trabajar dentro del directorio
private.

Cuando terminemos de trabajar con el directorio private, desmontamos el sistema
de ficheros.

# umount private

Si ahora accedemos a la carpeta, veremos los nombres de los ficheros y
directorios, pero si intentamos abrirlos veremos que estan encriptados y no
podemos ver la informacion. Podemos usar un editor hexadecimal para ver su
contenido, pero no sera legible.

Si queremos volver a acceder a los archivos, tendremos que montar de nuevo el
filesystem

# mount -t ecryptfs private private

Nos pedira la frase de paso para poder desencriptar, tambien que respondamos a
las otras preguntas que respondimos cuando hicimos la primera encriptación, pero
podemos dar enter a todas(usar los valores por defecto), si todo esta bien nos
debe mostrar el mensaje: Mounted eCryptfs.

=======
Fuentes
=======

-https://ubuntulife.wordpress.com/2008/08/07/crea-un-directorio-privado-encriptado-con-ecryptfs/
-https://blog.desdelinux.net/cifra-directorios-en-gnulinux-con-ecryptfs/

=======================================
Reducir tamaño de ficheros mp3 con Lame
=======================================

Lame es una biblioteca de codificación MP3

Un poco de teoría primero

Mono

Una señal monofónica es una señal grabada con un solo micrófono.

Al escuchar la grabación con dos altavoces o auriculares, la señal se duplica y
oímos lo mismo por la izquierda que por la derecha. Al grabar una voz con un
solo micrófono, lo haremos en una pista mono de nuestro programa de grabación.

Stereo

En cambio, una señal estereofónica es una señal grabada con un "par stereo"
(pareja de dos micrófonos iguales). Al escuchar la grabación, por la izquierda
oímos la grabación de un micrófono y por la derecha la del otro. Al grabar un
ambiente la diferencia entre mono y stereo se nota muchísimo. Una grabación en
stereo es mucho más realista ya que los humanos lo escuchamos todo por dos
oídos. Cuando grabamos una batería acústica, utilizamos un par stereo (aereos)
para captar los platos y un poco de ambiente.

Debes saber que…

Un archivo en stereo “pesa” aproximadamente el doble que el mismo archivo en
mono, siempre que sea la misma señal de audio. Cuando digo que un archivo "pesa"
me refiero al espacio que dicho archivo ocupa en el disco duro de tu ordenador.

El archivo mono solo contiene una pista mientras que el archivo en stereo
contiene dos, una para la señal izquierda y otra para la
derecha, y se tienen que guardar el doble de datos.

Instalamos lame:

# apt-get install lame

Entre los parámetros que podemos usar están:

-b 90 es el BitRate, si deseamos otro distinto lo modificamos.

-q 0 puede ser sustituida por -h (-q 2), hay que tener en cuenta que
cuanto menor sea la calidad, mayor es la velocidad de conversión, el rango va del 0 al 9.

-a mono channel

-s stereo channel

Con el siguiente comando las canciones se comprimen pero resultan en canal mono:

$ lame -a -h -b 90 -q 0 archivo_a_reducir.mp3 archivo_resultante.mp3

Con el siguiente comando las canciones se comprimen pero resultan en canal
stereo:

$ lame -s -h -b 90 -q 0 archivo_a_reducir.mp3 archivo_resultante.mp3

y listo, la compresión es cerda del 50% en relación al peso anterior y no se
nota en la calidad del audio, mejor dicho, es casi imperceptible un cambio o
baja en al calidad del audio.

=======
Fuentes
=======

-http://www.kacharreando.com/ubuntu/reducir-mp3/
-http://www.comograbar.com/conceptos-basicos/diferencia-entre-mono-y-stereo/

====================================================
Instalar steam client en GNU/Linux Debian de 64 bits
====================================================

1- Descargar el .deb de la página oficial de steam, debe ser el archivo
steam_latest.deb

2- Habilitar el soporte multi-arch y actualizar la lista de paquetes
disponibles:

# dpkg --add-architecture i386

$ sudo aptitude update

3- Instalar esta dependencia dependencia

$ sudo apt-get install libc6-i386

# dpkg -i steam_latest.deb

4- Luego ya saldrá steam en las opciones del menú, al darle click, te pide dar
enter para actualizarse.

Nota: Lo anterior no me funciono, me dio problemas de dependencias, hay que
probarlo bien.

Instalación con snap
====================

Nota: Leer guía de Sanp por si hay dudas.

$ sudo apt update

$ sudo apt install snapd

$ sudo snap install core

$ sudo snap install steam --candidate

=============================================================
Cambiar el nombre de la máquina o el host en GNU/Linux Debian
=============================================================

El hostname es el nombre que configuramos para la máquina en el momento de la
instalación del sistema operativo, después de la instalación del sistema este
nombre puede ser alterado.

El nombre del sistema, o hostname, está guardado en el archivo /etc/hostname.

Este archivo debe contar sólo con el nombre del sistema y no con el nombre
completo del dominio: 

Para ver el nombre del host, En este caso el nombre es debian.:

$ hostname

mi_user@debian:~$

Para cambiar el hostname editamos el archivo /etc/hostname 

# vim /etc/hostname

Tambien editamos a /etc/hosts y cambiamos el nombre de la máquina:

# vim /etc/hosts

Ahora corremos para reiniciar el servicio de hostname

# /etc/init.d/hostname.sh start

ó

# invoke-rc.d hostname.sh start

Para ver si se hizo el cambio correctamente escribimos:

$ hostname

A veces es mejor cerrar sesión y volver a entrar a ver si se hizo el cambio.

========================================================
Ajustar el brillo del monitor desde la línea de comandos
========================================================

Primero, necesitamos verificar el estado actual de la visualización del sistema.
Para hacerlo, ejecuta:

$ xrandr -q

Salida

Screen 0: minimum 320 x 200, current 1366 x 768, maximum 8192 x 8192
LVDS-1 connected primary 1366x768+0+0 (normal left inverted right x axis y axis) 344mm x 194mm
1366x768 60.00*+ 40.00
1280x720 60.00 59.99 59.86 59.74
1024x768 60.04 60.00
960x720 60.00
928x696 60.05
896x672 60.01
.
.
.

El valor de brillo debe estar entre 0.0 y 1.0, donde 0.0 se refiere al valor más
bajo (negro completo) y 1.0 se refiere al valor más brillante. Por ejemplo para
configurar el valor de brillo de la pantalla como 0.7, ejecuta:

$ xrandr --output LVDS-1 --brightness 0.7

No uses nada por encima de 1.0. Puede convertir la pantalla en blanco completo y
es posible que no veas claramente nada.

============================================
Activar pantalla HDMI cuando no es detectada
============================================

$ xrandr --setprovideroutputsource 1 0

======
Fuente
======

https://maslinux.es/como-ajustar-el-brillo-del-monitor-desde-la-linea-de-comandos-en-gnu-linux/

=========================================================
Instalar la última versión del kernel disponible (estable)
=========================================================

# apt-get update

# apt-get install linux-image-amd64

# apt-get dist-upgrade

# reboot

===============================
Instalar WPS Office en Debian 9
===============================

1) Instalar Qt 4 Settings

# apt install qt4-qtconfig

2) Entrar en Qt 4 Settings

$ qtconfig-qt4

3) Selecione GTK+ en Qt Conifiguration > GUI Style y guardar los cambios.

4) Descargar e instalar la dependencia libpng12

$ wget -c http://ftp.us.debian.org/debian/pool/main/libp/libpng/libpng12-0_1.2.50-2+deb8u3_amd64.deb

# dpkg -i libpng12-0_1.2.50-2+deb8u3_amd64.deb

5) Descargar e instalar de WPS Office

$ wget -c http://kdl1.cache.wps.com/ksodl/download/linux/a21//wps-office_10.1.0.5707~a21_amd64.deb -O wps-office.deb

$ wget -c http://kdl.cc.ksosoft.com/wps-community/download/fonts/wps-office-fonts_1.0_all.deb -O fonts.deb

# dpkg -i *.deb

6) Abrir WPS Office desde el menú o con el comando:

$ wps

===============================
Instalar las fuentes faltantes
===============================

1) Descargar el .zip desde https://github.com/IamDH4/ttf-wps-fonts, este fichero
contiene las fuentes que necesita WPS Office para que no se queje con el mensaje
que sale, luego de descargarlo lo descomprimimos

2) Borramos todos los archivos descomprimidos exeptuando los .ttf y TTF y los
guardamos en una carpeta que llamaremos wps_office.

3) Copiamos la carpeta creada que contiene las fuentes a la ruta
/usr/share/fonts/truetype/

$ sudo cp -r wps_office /usr/share/fonts/truetype/

4) Recargamos las fuentes del sistema

# fc-cache -f -v

Listo ya podemos abrir WPS Office y no debería quejarse por fuentes faltantes.

==============================
Poner en español el WPS Office
==============================

1) Descargar el fichero wps-full-fix-es_1.0-2019_all.deb desde aquí:

https://drive.google.com/file/d/1WjvO0tGffN0nI7uAxoq9VR-DmHdqmjlE/view?usp=sharing

2) Instalar el fichero descargado

$ sudo dpkg -i wps-full-fix-es_1.0-2019_all.deb

3) Abrir WP Office y cambiar el idioma en el ícono con la letra A que está
debajo de la X y el de minimizar, al lado de "?".

==================================
Instalar el diccionario en español
==================================

1) Desde http://wps-community.org/download/dicts descargamos es_ES.zip

2) Descomprimimos el fichero y eso nos deja la carpeta es_ES

3) Copiamos la carpeta es_ES a la ruta /opt/kingsoft/wps-office/office6/dicts/spellcheck

# cp -r es_ES /opt/kingsoft/wps-office/office6/dicts/spellcheck/

4) Ahora ya podemos abrir WPS Office. Nos dirigimos a la pestaña Revisar,
clicamos el botón de Revisión Ortográfica y cuando aparezca el submenú clicamos
encima de Establecer idioma. A continuación aparecerá la ventana donde tenemos
que seleccionar el idioma del corrector ortográfico. En nuestro caso
seleccionamos Español y presionamos encima del botón Establecer predeterminado.

La verdad es que lo estuve probando y esa verga funciona ahí más o menos, se
recomienda tener cuidado con la escritura.

=========================
Instalar megasync desktop
=========================

Descargar el .deb desde https://mega.nz/sync, en este caso descargué
megasync-Debian_9.0_amd64.deb

# apt-get install libc-ares2 libcrypto++6 libmediainfo0v5 libtinyxml2-4 libzen0v5 apt-transport-https libraw10

# dpkg -i megasync-Debian_9.0_amd64.deb

Listo!!!

===============================
Problema con /var/lib/dpkg/lock
===============================

Si da problemas con el fichero dir/dir/lock por ejemplo, lo borramos

# rm -f dir/dir/lock

No se pudo bloquear /var/lib/dpkg/lock - open (11: Recurso no disponible
temporalmente)

Solución...

$ sudo fuser -vki /var/lib/dpkg/lock

-----

En Debian 11 Bullseye el problema puede ser:

E: Could not get lock /var/lib/apt/lists/lock. It is held by process 1232 (packagekitd)
N: Be aware that removing the lock file is not a solution and may break your system.

# rm -f /var/lib/apt/lists/lock

------

Simple, easy to use paint program for GNOME

gnome-paint

-----

Herramienta sencilla para la edición de menús de GNOME

alacarte

-----

Muestra un árbol de directorios con sangría, en color.

tree

-----

Busca y muestra información sobre el sistema operativo que estemos utilizando,
datos como el tipo de distribución, kernel, entorno de escritorio, windows
manager, CPU, themes, RAM, etc.

screenfetch

==================================
Grabar el escritorio de la máquina
==================================

kazam

$ sudo apt-get install kazam

Para abrirlo.

$ kazam

O buscarlo en el menú de programas.

==================================
Grabar el escritorio de la máquina
==================================

Vokoscreen

$ sudo apt install vokoscreen

Para abrirlo:

$ vokoscreen

O buscarlo en el menú de programas.

=============================
Grabar el audio de la máquina
=============================

Lista filtrada de dispositivos de audio del sistema.

$ pacmd list-sources | egrep '^\s+name: .*alsa_output'

Eso nos mostrará algo como esto:

name: <alsa_output.pci-0000_00_1b.0.analog-stereo.monitor>

Luego de identificar el dispositivo usaremos el comando para grabar el audio de
la máquina usando el dispositivo que identificamos:

$ parecord --channels=1 -d alsa_output.pci-0000_00_1b.0.analog-stereo.monitor grabacion.wav

Con Ctrl + c detenemos la grabación.

===============================================
Particionado recomendado de discos en GNU/Linux
===============================================

* swap: Las particiones swap sirven para soportar la memoria virtual. En otras
palabras los datos se escriben en una partición swap cuando no hay suficiente
memoria RAM para almacenar la información que su sistema está procesando.

* /boot: La partición montada en /boot/ contiene el kernel del sistema operativo
(el cual permite a su sistema arrancar el SO) junto con archivos utilizados
durante el proceso de arranque.

* /: Aquí es donde se localiza "/" (el directorio raíz). En esta configuración,
todos los archivos (excepto aquellos almacenados en /boot) están en la partición
raíz.

La partición / (o raíz) es la cima de la estructura del directorio. El
directorio /root (algunas veces pronunciado "slash-root") es el directorio
principal de la cuenta del usuario-administrador del sistema.

* /home: Para almacenar datos de forma independiente de los datos del sistema,
cree una partición dedicada dentro de un grupo de volumen para el directorio
/home. Así podrá actualizar o reinstalar el SO sin borrar archivos de datos de
los usuarios.

Imaginemos que tenemos un disco SATA de 500GB.

-- Partición primaria:

/boot = 500mb

-- Particiones extendidas:

swap = El doble de la memoria RAM

/ = 30 GB

/home = 465GB o lo que sobre para los usuarios del SO

El particionamiento no es una ciencia exacta, y mucho menos con las miles de
combinaciones que hay, pero os aseguramos que separar el punto de montaje /home
del resto nos ahorrará muchos problemas, sobre todo en actualizaciones, donde
no perderemos ni un solo dato.

===================
Instalación de Mate
===================

# apt-get install mate-desktop-environment-extras

========================================
Conectar 2 computadoras de punto a punto
========================================

Conectar con un cable de red, de puerto eternet a puerto eternet 2 pc

Entrar en la pc A, luego escribimos:

% ip link

Con esto veremos los dispositivos de red y su configuración, algo como esto

user@debian:~$ ip link
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc pfifo_fast state DOWN mode DEFAULT group default qlen 1000
    link/ether 00:26:2d:9c:39:12 brd ff:ff:ff:ff:ff:ff
3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DORMANT group default qlen 1000
    link/ether 88:9f:fa:4d:5d:53 brd ff:ff:ff:ff:ff:ff

Falta probar bien...

================
Telegram desktop
================

===========
Instalacion
===========

Para instalar el telegram desktop se debe descargar y descomprimir el fichero
desde la pagina oficial de telegram, al descomprimir nos dejara un directorio
que contiene 2 ficheros:

Telegram Updater

Para ejecutar la instalacion, ejecutamos desde la consola:

$ ./Telegram

Luego de eso, si no hay errores, deberia aparecer en el menu el icono de
telegram.

================
Remover Telegram
================

Borramos la carpeta donde esta el script de instalacion de telegra, la del paso
anteior, de la de instalacion

y tambien borramos la carpeta que esta en el hoem del usuario:

.local/shares/TelegramDesktop

=======================
Instalar snap en Debian
=======================

En Debian 9 (Stretch) y Debian 10 (Buster), snap puede ser instalado
directamente desde la linea de comandos con:

$ sudo apt update

$ sudo apt install snapd

$ snap install core

$ snap install hello-world

hello-world 6.3 from Canonical✓ installed

Este paso final no se por que coño no me funciono.

$ hello-world

Hello World!

======================
Solucion de aviso dpkg
======================

dpkg: aviso: `ldconfig' no se ha encontrado en el PATH o no es ejecutable

Ejecutar:

$ echo 'export PATH=$PATH:/usr/local/sbin:/usr/sbin:/sbin' >> /home/usuario/.bashrc

Otro error...

dpkg: atención: `ldconfig' no se ha encontrado en el PATH o no es ejecutable

Ejecutar:

$ export PATH=$PATH:/usr/local/sbin:/usr/sbin:/sbin

=============================
Instalar Sublime Text con apt
=============================

Install the GPG key:

wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -

Ensure apt is set up to work with https sources:

sudo apt-get install apt-transport-https

Select the channel to use:

Stable

echo "deb https://download.sublimetext.com/ apt/stable/" | sudo tee /etc/apt/sources.list.d/sublime-text.list

Dev

echo "deb https://download.sublimetext.com/ apt/dev/" | sudo tee /etc/apt/sources.list.d/sublime-text.list

Update apt sources and install Sublime Text

sudo apt-get update

sudo apt-get install sublime-text

Instalar Package Control
========================

1) Abrir consola de comando sde sublime con:

ctrl+shift+p

2) Escribir

Install Package Control

3) Presionar enter y listo

Instalando Themes y ColorSchemes
================================

Para instalar un theme tenemos que saber el nombre de este, para eso tienes que
navegar entre el listado de themes y buscar el que mas te guste.

Lista de themes: https://packagecontrol.io/browse/labels/theme

Una vez hayas identificado el que te ha gustado tienes que descargarlo para ello
nos vamos a Sublime Text y presionamos:

Ctrl + Shift + P

Esto nos abrirá una ventana en la que escribiremos:

install

Y seleccionaremos la opción que dice:

Package Control: Install Package

Presionamos Enter una vez mas y ahora tendremos un listado con todos los
plugins, themes y colorschemes de sublime text. Basta con buscar el que queremos
y seleccionarlo y darle enter.

Temas y paquetes recomendados
=============================

-SublimeCodeIntel: Plugin  mas completo para el auto completado de código y
también reconoce las funciones definidas en nuestro proyecto.

-babel-sublime: Para mejorar la coloración de sintaxis de babel y .jsx.
Syntax definitions for ES6 JavaScript with React JSX extensions.

-JavaScript Completions: JavaScript Completions for sublime text. It helps you
to write your scripts more quickly with hints and completions.

-Sublime-HTMLPrettify

-VUEFormatter

-vue-syntax-highlight

-ReactIDE

-Laravel Blade Highlighter

-A File Icon.

-Spacefunk.

-Theme Monokai Pro (Actual).

Buscarlos e instalarlos con las directrices anteriores:

-A File Icon: Se activa desde las Preferences

-Spacefunk: Para activar el theme tenemos que ir a:

Precerencias > Settigs - User

Esto nos abrirá un documento con algunas lineas de código, modificamos a:

Preferences.sublime-settings - User, y nos debe quedar así:

{
	"color_scheme": "Packages/Color Scheme - Default/Monokai.sublime-color-scheme",
	"font_size": 11,
	"ignored_packages":
	[
		"Vintage"
	],
	//"theme": "Default.sublime-theme"
	"theme": "Spacefunk (Blue Monday).sublime-theme"
}

Guardamos y reiniciamos SublimeText.

=====================================
Eliminar cualquier paquete de Sublime
=====================================

1- Vaya al menú Sublime-> Preferencia o presione Ctrl + Shift + P.

2- Elija -> la opción Eliminar paquete, después de elegir, mostrará todos los
paquetes instalados en su sublime, seleccione uno de ellos.

3. Después de la selección, se eliminará o, para mejor, puede reiniciar su
sistema.

====================================================================
Configuraciones de Sublime Text esenciales después de la instalación
====================================================================

1) Ir a menú Preferences > Settings.

2) Translate Tabs To Spaces

translate_tabs_to_spaces está por defecto en false, cambiarla a true. Esta
configuración creará espacios (\s) en vez de tabs (\t) al presionar la tecla
Tab.

3) Draw White Space

Esta configuración de draw_white_space por defecto está en selection. Al
cambiarla a all permite visualizar los espacios en blanco en cualquier parte del
código sin necesidad de que esté seleccionado.

Fuente
======

-https://blog.pleets.org/article/configuraciones-de-sublime-text-esenciales

=================
Programa progress
=================

Progress , anteriormente conocido como Coreutils Viewer, es un comando ligero C
que busca los comandos básicos de coreutils como cp , mv , tar, dd , gzip/gunzip
, cat, grep, etc. actualmente en ejecución en el sistema y muestra el porcentaje
de datos copiados, solo se ejecuta en sistemas operativos Linux y Mac OS X.

# apt install progress

Luego usamos el comando cp para copiar algun directorio

$ cp -r dir /tmp

Ahora podemos ver el % de avance de la copia si ejecutamos el siguiente comando
en otra consola

$ progress -q

[28281] cp /tmp
    10.0% (380.2 MiB / 3.7 GiB)

Para ver en vivo el progreso usamos -m

$ progress -m

[28281] cp /tmp
    10.0% (380.2 MiB / 3.7 GiB)

=======
Fuentes
=======

-https://es.linux-console.net/?p=896

=============================
Paquete locales y locales-all
=============================

Este paquete contiene los datos regionales precompilados de todas las regiones
que se pueden elegir. Un alternativa mejor es instalar el paquete locales y
seleccionar sólo las regiones deseadas, pero puede ser útil en una máquina con
poca memoria porque algunos archivos regionalización necesitan un montón de
memoria para compilarse.

# apt install locales y locales-all

$ dpkg-reconfigure locales

Escogemos las configuraciones regionales que desea generar:

es_VE.UTF-8 UTF-8

Configuración regional predeterminada para el entorno del sistema:
es_VE.UTF-8

=============================================
Cron y Crontab en Linux para programar tareas
=============================================

¿Has intentado programar una tarea en Linux y no has sabido como? ¿A pesar de
consultar el manual propio no has sido capaz? Primero hay que entender a  Cron y
Crontab. Estos dos elementos son muy importantes a la hora de programar tareas
periódicas y que se ejecuten sin que tengamos que estar pendientes de su estado.

En los sistemas operativos Windows existe algo similar denominado Tareas
Programadas. En esta ocasión el proceso no se realiza de forma gráfica y se
tiene que realizar a través de terminal.

Hemos mencionado con anterioridad Cron y Crontab. En primer lugar, vamos a ver
que diferencias existen entre ambos elementos. Posteriormente aprenderemos a
agregar tareas y para finalizar nos adentraremos en la gestión de los jobs
(trabajos) de Cron.

================================
Diferencias entre Cron y Crontab
================================

Aunque pueda parecer que estamos hablando de lo mismo, no es así, y se podrían
considerar dos elementos dependientes uno del otro. Para ser más claros, son los
encargados de que la programación de tareas en sistemas Linux sea posible.

===========
Qué es Cron
===========

Es un demonio (proceso en segundo plano) que se ejecuta desde el mismo instante
en el que arranca el sistema. Comprueba si existe alguna tarea (job) para ser
ejecutado de acuerdo a la hora configurada en el sistema. Muy importante que la
zona horaria esté bien configurada ya que de lo contrario las ejecuciones puede
que no coincidan con los ajustado.

En función de la distribución, se inicia utilizando las carpetas /etc/rc.d/ o
/etc/init.d y cada minuto comprueba los ficheros /etc/crontab o /var/spool/cron
es busca de posibles ejecuciones (ahora empieza todo a cuadrar).

==============
Qué es Crontab
==============

Un archivo de texto. Por simple que parezca la definición es así. Aunque es
verdad que se trata de un archivo con contenido especial. Posee una lista con
todos los scripts a ejecutar. Generalmente cada usuario del sistema posee su
propio fichero Crontab. Se considera que el ubicado en la carpeta etc pertenece
al usuario root.

Para generar el archivo propio, cada usuario deberá hacer uso del comando
crontab (sí, es el mismo nombre).

Cada usuario tiene sus crontabs, el root tiene los suyos y los demás usuarios
los suyos.

Para ver los contrabs configurados del usuario regular utilizamos este comando:

$ crontab -l

Para ver los contrabs configurados del usuario root utilizamos este comando:

# crontab -l

Para editarlos el crontab por defecto del usuario regular

$ crontab -e

Para editarlos el crontab por defecto del usuario root

# crontab -e

=====================
Formato de las tareas
=====================

Las tareas cron siguen una determinada sintaxis. Tienen 5 asteriscos seguidos
del comando a ejecutar. Ahora explicaré para qué sirve cada cosa.

* * * * * /bin/ejecutar/script.sh

Los 5 asteriscos, de izquierda a derecha, representan:

Minutos: de 0 a 59.
Horas: de 0 a 23.
Día del mes: de 1 a 31.
Mes: de 1 a 12.
Día de la semana: de 0 a 6, siendo 0 el domingo.

Si se deja un asterisco, quiere decir "cada" minuto, hora, día de mes, mes o
día de la semana. Por ejemplo:

* * * * * /bin/ejecutar/script.sh

Ejecuta este script:

Cada minuto
De cada hora
De cada día del mes
De cada mes
De cada día de la semana

Otro ejemplo:

30 2 * * 1 /bin/ejecutar/script.sh

Ejecutar este script:

En el minuto 30
De las 2 de la noche
De cada día del mes
De cada mes
Sólo si es Lunes

En resumen, todos los lunes a las 2:30 horas se ejecutará el script.

====================
Intervalos de tiempo
====================

Ejecutar un script de lunes a viernes a las 2:30 horas:

30 2 * * 1-5 /bin/ejecutar/script.sh

Ejecutar un script de lunes a viernes cada 10 minutos desde las 2:00 horas
durante una hora:

0,10,20,30,40,50 2 * * 1-5 /bin/ejecutar/script.sh

Esto quizá puede ser largo. La sintaxis de crontab permite lo siguiente.
Imaginemos que queremos ejecutarlo cada 5 minutos:

*/5 2 * * 1-5 /bin/ejecutar/script.sh

===================
Palabras reservadas
===================

Muchas veces tenemos palabras reservadas para facilitar el uso de programas o
lenguajes de programación. Cron no podía ser menos, así que tenemos algunas que
suelen ser las más comunes. Ya cada uno que lo configure conforme a sus
necesidades. Aquí van:

@reboot: se ejecuta una única vez al inicio.
@yearly/@annually: ejecutar cada año.
@monthly: ejecutar una vez al mes.
@weekly: una vez a la semana.
@daily/@midnight: una vez al día.
@hourly: cada hora.

Por ejemplo, para ejecutar el script cada hora:

@hourly /bin/ejecutar/script.sh

==============================
Ejemplo de script para pruebas
==============================

#!/bin/bash
# Abrir un fichero específico con el editor gedit
gedit /home/user/try.txt

=======
Fuentes
=======

-https://www.redeszone.net/2017/01/09/utilizar-cron-crontab-linux-programar-tareas/
-https://geekytheory.com/programar-tareas-en-linux-usando-crontab

===========================================
Transparencia de la barra superior en gnome
===========================================

Clonamos el proyecto con este comando:

$ git clone https://github.com/rockon999/dynamic-panel-transparency.git

Lo anterior nos descargará la extensión en nuestra carpeta personal.

Ahora vamos a nuestra carpeta personal y accedemos a la carpeta
"dynamic-panel-transparency", copiamos la carpeta
"dynamic-panel-transparency@rockon999.github.io" en
/home/user/.local/share/gnome-shell/extensions, si la carpeta "extensions" no
está, la creamos.

El siguiente paso es reiniciar el shell, lo que podemos hacer con Alt+F2
introduciendo la tecla "r" sin las comillas y presionando Intro o reiniciamos el
sistema operativo.

A continuación abrimos Retoques de GNOME. Si no lo tenemos instalado, instalamos
el paquete gnome-tweak.

Luego vamos a "Extensiones" y activamos "Dynamic panel transparency" Y eso sería
todo, solo quedaría configurarlo.

=======
Fuentes
=======

-https://ubunlog.com/asi-puedes-recuperar-la-transparencia-dinamica-de-la-barra-superior-en-ubuntu-19-04/

==========================================
Crear o añadir memoria swap en un servidor
==========================================

1) Comprobar el sistema de información Swap

$ sudo swapon -s

ó

$ cat /proc/swaps

Si tras ejecutar lo anterior solo aparece en pantalla las cabeceras de una
tabla, significará que actualmente no tenemos espacio swap habilitado.

Filename				Type		Size	Used	Priority

Otra forma de ver si tenemos disponible memoria swap en nuestro sistema es
mediante el comando «free». Este comando se encarga de mostrar el uso de los
diferentes tipos de memoria del sistema.

$ free -m

El resultado que aparecería por pantalla sería algo parecido a lo que os
mostramos a continuación:

             total       used       free     shared    buffers     cached
Mem:          3953        154       3799          0          8         83
-/+ buffers/cache:         62       3890
Swap:            0          0          0

Si en el apartado «Swap» aparece el valor 0, esto quiere decir que no tenemos
espacio disponible para este fin.

2) Revisar el espacio disponible en la partición del disco duro

Para asignar espacio para el intercambio se suele utilizar una partición
independiente. Sin embargo, no siempre es posible cambiar el esquema de
particionado utilizado en un servidor. Lo que se puede hacer en estos casos es
crear un archivo de intercambio de forma sencilla, que resida en una de las
particiones ya existentes. Antes de hacer esto, es muy importante que sepamos el
estado de uso de las distintas particiones para ver donde sería más factible
crearlo. Podemos conseguir esta información mediante la instrucción:

$ df -h

Por pantalla tenemos que ver algo parecido a lo siguiente:

Filesystem      Size  Used Avail Use% Mounted on
/dev/vda         59G  1.3G   55G   3% /
none            4.0K     0  4.0K   0% /sys/fs/cgroup
udev            2.0G   12K  2.0G   1% /dev
tmpfs           396M  312K  396M   1% /run
none            5.0M     0  5.0M   0% /run/lock
none            2.0G     0  2.0G   0% /run/shm
none            100M     0  100M   0% /run/user

Como podemos ver en el resultado anterior, nuestro disco duro tiene un tamaño de
55 GB disponibles, lo que se traduce en un gran espacio para trabajar. Ya que
sabemos el espacio disponible, ya podemos determinar el tamaño que destinaremos
a la memoria swap. En este punto existen opiniones diversas, pero nosotros os
recomendamos asignar un espacio que sea al menos igual o el doble de la RAM; por
supuesto, esto también dependerá del espacio disponible que tengamos. En nuestro
caso, dedicaremos 4 GB a este fin.

3) Crear un archivo swap

Una vez que sabemos el espacio que tenemos disponible, vamos a proceder a crear
un fichero swap en nuestro sistema de archivos. Para ello vamos a crear uno de
nombre «swapfile» en nuestro directorio root. A este archivo tenemos que
asignarle el espacio que queremos que tenga. Para ello lo podemos hacer de dos
formas diferentes.

==================
Método tradicional
==================

Primero de todo, cabe decir que el método tradicional es la opción más lenta.
El sistema que se utiliza en este caso es el comando «dd», una herramienta que
es capaz de escribir de una ubicación a otra. Para conseguir un tamaño de 4 GB,
tenemos que ejecutar la siguiente instrucción:

$ sudo dd if=/dev/zero of=/swapfile bs=1G count=4

Con esto, lo que hacemos es asignar un bloque de tamaño de 1 GB y un contador
con el valor 4, que serán las veces que se debería ejecutar. De esta forma
conseguiríamos los 4 GB de espacio mediante el uso de ceros como contenido. Os
recomendamos que tengáis mucho cuidado a la hora de utilizarlo, ya que si
ponemos mal algún tipo de información, podríamos corromper el sistema. Tampoco
os preocupéis si veis que tarda mucho tiempo en generarse, se trata de un
fichero muy grande, así que es normal que tarde.

=============
Método rápido
=============

La forma más rápida de conseguir esto es utilizando el programa «fallocate».
Este comando crea un fichero del tamaño indicado de forma inmediata. Para crear
un archivo hay que ejecutar lo siguiente:

$ sudo fallocate -l 4G /swapfile

El archivo se crea inmediatamente y lo podemos comprobar ejecutando la siguiente
instrucción:

$ ls -lh /swapfile

Como salida deberíamos ver algo parecido a lo siguiente:

-rw-r--r-- 1 root root 4.0G Jul 03 17:15 /swapfile

4) Habilitar el archivo swap

Aunque ya hemos creado nuestro archivo, el sistema no sabe que queremos
utilizarlo como partición de intercambio. Así que ahora toca darle formato y
activarlo. Para ello debemos ajustar los permisos en nuestro archivo, para que
solo el usuario root pueda leerlo, porque dejar que cualquiera pudiera acceder a
él supondría un problema de seguridad importante.

Para cambiar los permisos debemos ejecutar:

$ sudo chmod 600 /swapfile

Lo siguiente que haremos será indicar al sistema que ese fichero se usará como
memoria swap. Para ello ejecutaremos lo siguiente:

$ sudo mkswap /swapfile

Por pantalla tenemos que ver algo parecido a esto:

Setting up swapspace version 1, size = 4194300 KiB
no label, UUID=e2f1e9cf-c0a9-4ed4-b8ab-714b8a7d6944

Nuestro archivo está listo para ser utilizado como espacio swap, así que vamos a
activarlo.

$ sudo swapon /swapfile

Ahora podemos verificar si nuestro sistema nos informa de que tenemos un espacio
creado de tipo swap.

$ sudo swapon -s

Por pantalla deberíamos ver algo así:

Filename                Type        Size    Used    Priority
/swapfile               file        4194300 0       -1

Si utilizamos la herramienta «free», nos debería aparecer que la memoria swap
tiene espacio disponible, en lugar del valor 0 que aparecía antes.

$ free -m

La salida sería la siguiente:

             total       used       free     shared    buffers     cached
Mem:          3953        101       3851          0          5         30
-/+ buffers/cache:         66       3887
Swap:         4095          0       4095

5) Hacer permanente el archivo de intercambio

Aunque hayamos creado nuestro archivo de intercambio, cada vez que reiniciemos
la máquina el sistema no lo habilitará de forma automática. Para que esto ocurra
tenemos que modificar el archivo «fstab». Para ello lo editaremos con
privilegios root con nuestro editor de preferencia.

$ sudo nano /etc/fstab

En la parte inferior del archivo tenemos que añadir una línea que será la
encargada de indicar al sistema que utilice el archivo creado de forma
automática.

/swapfile   none    swap    sw    0   0

Cuando hayas añadido esa línea, puedes guardar y salir.

6) Afinar la configuración de nuestra memoria swap

Para finalizar, es bueno que realicemos algunas acciones para mejorar el
rendimiento del sistema de intercambio. El parámetro «swappiness» configura la
frecuencia con la que su sistema intercambia datos de memoria RAM con el espacio
de intercambio. El «swappinness» es un valor que va de 0 a 100. Cuando el valor
esté cerca de 0, no se intercambiará datos en el disco a menos que sea
absolutamente necesario. Si por el contrario, el valor está más cerca de 100, se
llevarán a cabo un mayor número de intercambios para dejar más espacio libre en
la RAM.

Si queremos ver el valor actual de «swappiness», lo podemos hacer ejecutando la
siguiente instrucción:

cat /proc/sys/vm/swappiness

Para asignar un valor de 10 a este parámetro, podemos ejecutar:

sudo sysctl vm.swappiness=10

El valor se mantendrá así hasta el próximo reinicio de la máquina. Si queremos
que sea permanente, podemos añadir la siguiente línea al final de nuestro
/etc/sysctl.conf.

vm.swappiness=10

Cuando termines, guarda y cierra el archivo. Como véis, crear un archivo para
utilizarlo como memoria swap en Ubuntu no es nada complicado. El beneficio para
el rendimiento de nuestro sistema puede ser considerable. Recuerda realizar
siempre copias de seguridad antes y, si dudas, pregunta o delega en
profesionales de administración de sistemas.

=======
Fuentes
=======

-https://www.stackscale.com/es/blog/anadir-memoria-swap-servidor-ubuntu/

=================================================================
Cambiar el fondo de la pantalla o wallpaperde login en gnome gdm3
=================================================================

Cada vez que inicies sesión o bloquees y desbloquee tu escritorio, serás
recibido con una pantalla de color gris. Es el fondo de GDM
(GNOME Display Manager) por defecto.

Para cambiar el fondo debemos editar el archivo

/usr/share/gnome-shell/theme/gnome-classic.css

Antes de modificar este archivo, haz una copia de seguridad del mismo. Así que,
podemos restaurarla si algo sale mal.

Ahora, edita el archivo gnome-classic.css:

# nano /usr/share/gnome-shell/theme/gnome-classic.css

Encuentra las siguientes líneas bajo la directiva llamada "lockDialogGroup" en
el archivo:

#lockDialogGroup {
  background: #2e3436 url(resource:///org/gnome/shell/theme/noise-texture.png);
  background-repeat: repeat;
}

y lo cambiamos a

/* Nuevo fondo para pantalla del login */
#lockDialogGroup {
  background: #2e3436 url(file:///home/user/Imágenes/mi_nuevo_fondo.jpg);
  background-repeat: no-repeat;
  background-size: cover;
  background-position: center;
}

Nota que hay que poner la ruta completa a la nueva imágen.

Guardamos, refrescamos el escritorio con Alt + F2 y escriba r y presione enter
esto para gnome3.

y listo, ya deberíamos ver nuestra nueva imagen como fondo de login.

=======
Fuentes
=======

-https://www.linuxenespañol.com/tutoriales/como-cambiar-fond-pantalla-inicio-sesion-gdm-ubuntu/

====================================
Editar el tema por defecto en Debian
====================================

En este ejemplo, mi Debian tiene el gnome-classic por defecto, y el tema
Adwaita-dark configurado por defecto y la hoja de estilos del tema está en:

/usr/share/themes/Adwaita-dark/gtk-3.0/gtk.css

Sin embargo dentro de ese archivo encontramos una referencia a otro archivo:

@import url("resource:///org/gtk/libgtk/theme/Adwaita/gtk-contained-dark.css");

Nosotros vamos a escribir otra hoja de estilos para sobre escribir los estilos
del tema por defecto.

Nos vamos a /home/my-user/.config/gtk-3.0 y vamos a crear gtk.css

Dentro vamos a agregar el siguiente código que cambiara los colores de la
cabecera del explorador de archivos nautilus. Copiamos, pegamos, guardamos.

/* REMOVE "-dark" IF USING LIGHT THEME */
@import url("resource:///org/gtk/libgtk/theme/Adwaita/gtk-contained-dark.css");

/* Fonde de la mayoría de aplicaciones de gnome 
.background { color: #eeeeec; background-color: #000000; } */

/* THIS ONE CHANGES TITLEBAR COLOR */
headerbar.titlebar,
headerbar.titlebar:active {
    background:#000000;
}

/* THIS CHANGES NAUTILUS SEARCH BAR */
.horizontal.path-bar-box,
row:selected:backdrop {
    background:#3F51B5;
    border-color:#3F51B5;
}

Ahora recargamos el escritorio con Alt + f2 + r + enter y si abrimos nautilus
podremos ver los cambios en los colores.

Fuentes
=======

-https://unix.stackexchange.com/questions/175385/where-may-i-find-a-reference-scheme-for-gnome-3-theming-e-g-adwaita

=============
Programa curl
=============

Instalar curl

# apt install curl

Verifica la versión de Curl

$ curl --version

Sintaxis básica del comando Curl

$ curl [OPTIONS] [URL]

El uso más simple de Curl es mostrar el contenido de una página. El siguiente
ejemplo mostrará la página de inicio de testdomain.com.

$ curl testdomain.com

La salida sería:

<html><head><title>testdomain.com</title></head><body><h1>testdomain.com</h1><p>
Coming soon.</p></body></html>

=======================================
Opciones de archivo de comandos de Curl
=======================================

Los comandos Curl pueden descargar archivos desde una ubicación remota. Puedes
hacerlo de dos maneras diferentes:

-O guardará el archivo en el directorio de trabajo actual con el mismo nombre de archivo que el remoto.

-o permite especificar un nombre de archivo o ubicación diferente.

A continuación se muestra un ejemplo:

Guardar testfile.tar.gz.

$ curl -O http://testdomain.com/testfile.tar.gz

Guardar el archivo como newtestfile.tar.gz.

$ curl -o newtestfile.tar.gz http://testdomain.com/testfile.tar.gz

Reanudar descarga

$ curl -C - http://testdomain.com/testfile.tar.gz

Descargar varios archivos a la vez

$ curl -O http://testdomain.com/testfile.tar.gz -O http://mydomain.com/myfile.tar.gz

Si quieres descargar múltiples archivos de múltiples URLs, inclúyelos todos en
un archivo. Los comandos Curl se pueden combinar con xargs para descargar las
diferentes URLs.

Por ejemplo, si tenemos un archivo allUrls.txt que contiene una lista de todas
las URLs que se descargarán, el siguiente ejemplo se puede usar para descargar
todos los archivos.

$ xargs -n 1 curl -O < allUrls.txt

=======================
Comandos Curl para Http
=======================

Curl también se puede usar cuando hay un servidor proxy. Si estás detrás de un
servidor proxy que escucha en el puerto 8090 en sampleproxy.com, descarga los
archivos como se muestra a continuación:

$ curl -x sampleproxy.com:8090 -U username:password -O http:// testdomain.com/testfile.tar.gz

En el ejemplo anterior, puedes omitir -U username:password si el proxy no
requiere un método de autenticación.

Una solicitud HTTP típica siempre contendrá un encabezado. El encabezado HTTP
envía información adicional sobre el servidor web remoto junto con la solicitud
real. Si bien a través de las herramientas de desarrollador de un navegador
puedes verificar la información del encabezado, puedes verificarla utilizando un
comando curl.

Recuperar o consultar la información del encabezado de un sitio web.

$ curl -I www.testdomain.com

Hacer una solicitud GET

$ curl http://mydomain.com

Hacer una solicitud POST. El sitio web o url al cual se hace la solicitud
debería estar preparado para dar respuestas, de lo contrario dara error el
comando.

Aquí text=Hello es el parámetro de solicitud POST. Este comportamiento sería
similar a los formularios HTML.

$ curl -data "text=Hello" https://myDomain.com/firstPage.php

Otro ejemplo curl post real

$ curl -X POST https://petroapp-price.petro.gob.ve/price/PTR -H 'Content-Type: application/json' -d' {"coins":["BTC","DASH","LTC","ETH"]}'

Respuesta

{"status":200,"success":true,"data":{"BTC":{"BTC":185.10780816,"PTR":0.00540226}}}

=======
Fuentes
=======

-https://www.hostinger.es/tutoriales/comando-curl/

===========
gnome-paint
===========

Programa parecido al paint de windows, muy facil de usar

# apt install gnome-paint

================
¿Qué és el SMTP?
================

El SMTP (Simple Mail Transfer Protocol o Protocolo para Transferencia Simple de
Correo) es un protocolo de comunicación que permite el envío de correos
electrónicos en internet.

Este protocolo se asocia normalmente con otros como POP3 o IMAP, siendo SMTP
utilizado para el correo de salida y POP3 o IMAP utilizado para el correo
entrante.

El protocolo para transferencia simple de correo (en inglés Simple Mail Transfer
Protocol o SMTP) es un protocolo de red utilizado para el intercambio de
mensajes de correo electrónico entre computadoras u otros dispositivos (PDA,
teléfonos móviles, impresoras, etc). Definido inicialmente en agosto de 1982 por
el RFC 821 (para la transferencia) y el RFC 822 (para el mensaje). Son
estándares oficiales de Internet que fueron reemplazados respectivamente por el
RFC 2821 y el RFC 2822, que a su vez lo fueron por el RFC 5321 y el RFC 5322.1​

El funcionamiento de este protocolo se da en línea, de manera que opera en los
servicios de correo electrónico. Sin embargo, este protocolo posee algunas
limitaciones en cuanto a la recepción de mensajes en el servidor de destino
(cola de mensajes recibidos). Como alternativa a esta limitación se asocia
normalmente a este protocolo con otros, como el POP o IMAP, otorgando a SMTP la
tarea específica de enviar correo, y recibirlos empleando los otros protocolos
antes mencionados (POP O IMAP).

=======
Fuentes
=======

-https://es.wikipedia.org/wiki/Protocolo_para_transferencia_simple_de_correo

============================
Poner el audacity en español
============================

1) Editar el archivo /home/user/.audacity-data/audacity.cfg Buscamos la variable
"language" que debe estar vacía y pones "es"

language=es

Guardamos y abrimos audacity de nuevo.

2) Si en el audacity.cfg no está la variable "language" simplemete pega estas
líneas al final del archivo.

[locale]
language=es

Guardas y listo, abres audacity para comprobar

=======
Fuentes
=======

-https://salmorejogeek.com/2018/04/16/en-linux-como-poner-audacity-en-espanol-cuando-ni-siquiera-viene-en-preferencias/

====================
Instalar Tor browser
====================

1) Descargar el paquete desde https://www.torproject.org/es/

2) Descomprimir el paquete tor-browser-linux64-10.0.2_es-ES.tar.xz

3) Entrar en la carpeta tor-browser_es-ES

4) Ejecutar el siguiente comando:

$ ./start-tor-browser.desktop

5) Esto nos abre el navegador en una nueva ventana y ya está listo para usarse.

==================================================================
Mejorar el rendimiento de un sistema operativo de escritorio Linux
==================================================================

Para aprovechar mejor la memoria de nuestro equipo les recomiendo realicen lo
siguiente.

1) Abre un terminal y ejecuten el siguiente comando:

$ sudo nano /etc/sysctl.conf

2) Cuando se abra el editor de texto nano vayanse al final del archivo y peguen
el siguiente código:

vm.swappiness = 10
vm.vfs_cache_pressure = 50
vm.watermark_scale_factor = 200
vm.dirty_ratio = 3

3) Una vez pegado el código ya pueden guardar los cambios, cerrar el fichero,
para aplicar los cambios sin reiniciar usamos el siguiente comando:

$ sudo sysctl -p

4) Para chequear los nuevos valores ejecutar los siguientes comando:

$ cat /proc/sys/vm/swappiness

$ cat /proc/sys/vm/vfs_cache_pressure

$ cat /proc/sys/vm/watermark_scale_factor

$ cat /proc/sys/vm/dirty_ratio

Fuentes
=======

-https://geekland.eu/mejorar-el-rendimiento-de-un-sistema-operativo-de-escritorio-linux/

/home/user/.config/gtk-3.0

======================
Instalar Opera browser
======================

$ sudo nano /etc/apt/sources.list

Añadimos al final las líneas siguientes:

# Repositorio para Opera browser
deb http://deb.opera.com/opera-stable/ stable non-free

Una vez editado y guardado el archivo, descargamos e instalamos la key para
confiar en el repositorio añadido:

$ wget -O - https://deb.opera.com/archive.key | sudo apt-key add -

Antes de instalar, actualizamos los repositorios:

$ sudo apt update

y finalmente instalamos:

$ sudo apt-get install opera-stable

===================
Free-vpn para Opera
===================

https://www.opera.com/es-419/features/free-vpn

===============
¿Qué es un DNS?
===============

Los servidores DNS (Sistema de Nombres de Dominio) se encargan de traducir las
direcciones web en direcciones IP. Por ejemplo, cuando navegas por google.com,
tú ves esa dirección, pero el navegador necesita otra forma para saber a qué
servidor necesita conectarse para acceder a esos contenidos.

Un DNS es básicamente, un traductor. Es más fácil para el usuario escribir una
dirección web que recordar la dirección IP de cada una de estas webs.

Fuentes
=======

-https://www.xatakandroid.com/tutoriales/dns-android-que-como-cambiarlo-tu-movil

==========================
Modificar o agregar un DNS
==========================

Se debe editar este archivo:

$ sudo nano /etc/resolv.conf

Los de google son:

8.8.8.8
8.8.4.4

Pero para saltar restricciones para algunas páginas bloqueadas se puede usar

1.1.1.1

Esta configuración al parecer se resetea cada vez que se reinician las
conexiones de red, por lo que se debe hacer un ajuste a nivel de configuración
de la red del sistema.

Configuración manual y definitiva
=================================

https://1.1.1.1/es/

==========================================
Firmar electrónicamente con PortableSigner
==========================================

Es un programa de firma (con certificados X.509) para archivos PDF. Es
independiente de la plataforma ya que se puede ejecutar GNU/Linux, Windows y
Mac OS X.

Se puede descargar desde: http://portablesigner.sourceforge.net/

Una vez descargado y descomprimido se obtienen los siguientes archivos:

PortableSigner.jar
linux-install.sh
linux
lib

Para ejecutarlo y levantar la interfaz del sistema se debe instalar el paquete
de java disponible:

$ sudo aptitude install default-jre

Luego si ejecutamos el archivo principal:

$ java -jar PortableSigner.jar

Una vez abierto le se deben cargar los siguientes documentos:

-Primero el archivo pdf a firmar.
-Segundo (El sistema coloca el nombre del archivo firmado)
-Tercero el archivo .p12
-Cuarto la frase de paso o contraseña del archivo .p12

Para firmar se ejecuta.

$ java -jar ruta-ejecutable -n -t ruta-documento-firmar -o ruta-almacenar-documento-firmardo -s ruta-del-certificado -p frase-de-paso

$ java -jar PortableSigner.jar -n -t descarga.pdf -o descargar-sign.pdf -s miarchivo.p12 -p "micontraseñ@"

======
pdfsig
======

Portable Document Format (PDF) digital signatures tool.

Es una herramienta de firmas digitales en formato de documento portátil (PDF).

pdfsig verifica las firmas digitales en un documento PDF. También muestra la
identidad de cada firmante (campo commonName y nombre distinguido completo del
certificado del firmante), la hora y la fecha de la firma, el algoritmo hash
utilizado para firmar, el tipo de firma como se indica en el PDF y los rangos
firmados. con una declaración si el documento total está firmado. También puede
firmar documentos PDF.

Instalación:

$ sudo apt install poppler-utils

Para verificar la firma de un archivo se ejecuta el siguiente comando:

$ pdfsig mi-archivo-firmado.pdf

======================================================================
Pŕactica del Curso en línea del uso de Murachí para firmar y verificar
documentos PDF
======================================================================

Este tutorial no lo he probado aún pero debería funcionar.

PORTABLESIGNER es una aplicación de firmar (con certificado X.509) para archivos
PDF desarrollado en lenguaje JAVA. En esta sección realizaremos la firma
electrónica de documento PDF usando la aplicación PORTABLESIGNER y un
certificado digital en formato PKCS#12. Para desarrollar esta tarea se requiere
disponer del certificado electrónico en formato PKCS#12.

Para realizar esta actividad es necesario que realizamos los siguientes pasos:

Instalar el servidor APACHE2

Descargar el zip de la aplicación PORTABLESIGNER

Instalar OPENJDK (JAVA .6 or 1.7)

Instalar PHP7

Crear un formulario HTML que permita obtener del sistema de archivo de tu
computador un archivo PDF, un archivo correspondiente al certificado digital en
formato PKCS#12.

Crear los scripts necesarios que permitan realizar el proceso de firma
electrónica de usando la aplicación PORTABLESIGNER Y para ello, es
importante seguir las siguientes instrucciones:

1. Crear el ambiente de prueba para realizar el ejercicio

Se procede a instalar los paquetes APACHE2, JAVA y PHP

$ sudo aptitude install openjdk-8-jre apache2 php7.3
Descargar en el servidor Apache la aplicación PORTABLESIGNER y moverlo al servidor WEB APACHE

$ wget https://sourceforge.net/projects/portablesigner/files/portablesigner/2.0-Release/PortableSigner-Generic-2.0.38c0573.zip

Se crea el directorio del ambiente de trabajo

$ sudo mkdir /var/www/html/murachi/

$ sudo mv PortableSigner-Generic-2.0.38c0573.zip /var/www/html/murachi/.

Del comando anterior se descarga la aplicación en el archivo PortableSigner-Generic-2.0.38c0573.zip. Para descomprimir el archivo zip debe tener instalado en su computadora el paquete Unzip. De no tener el paquete Unzip instalado se procede a instalar con el comando

$ sudo aptitude install unzip

Luego se procede a descomprimir el archivo PortableSigner-Generic-2.0.38c0573.zip en el servidor web Apache con el comando

$ cd /var/www/html/murachi/

$ sudo unzip PortableSigner-Generic-2.0.38c0573.zip

Al descomprimir debe poseer los directorios lib/, linux/ y el archivo ejecutable PortableSigner.jar

2. Crear la pagina básica y el script necesarios para realizar la firmar electrónica usando la aplicación PORTABLESIGNER

La aplicación PORTABLESIGNER se ejecuta por consola y para la misma se requiere tener:

El archivo PDF a firmar
El certificado electrónico en formato PKCS#12 con su contraseña o frase de paso (generado en la sección Contenido 1).
El objetivo de este ejercicio es invocar un script en PHP desde un formulario HTML que ejecute por comando la aplicación PORTABLESIGNER.

En primer lugar, realizaremos el formulario que permita enviar el archivo PDF a firmar y cargar el certificado electrónico en formato PKCS#12 junto a la contraseña o frase de paso del certificado. Para este ejercicio se creará el formulario en un archivo con el nombre de index.php

Características del formulario HTML

Control: Botón de envío (Submit button)

Atributos: Función en php que gestione los parámetros del formulario (Action)

Código del formulario index.php

<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>Firma electrónica</title>
</head>
<body>

<h1> Firmando un archivo PDF con PortableSigner </h1>
<form action="run_script.php" method="POST" enctype="multipart/form-data">
  <fieldset>
    <legend>PDF</legend>
    <label for="pdf">Seleccione su PDF</label>
    <input id="pdf" type="file" name="pdf" accept=".pdf" required tabindex="1">
  </fieldset>
  <fieldset>
    <legend>Certificado</legend>
    <label for="pkcs12">Seleccione su certificado PKCS12 (.p12)</label>
    <input id="pkcs12" type="file" name="pkcs12" accept=".p12" required tabindex="2">
  </fieldset>
  <fieldset>
    <legend>Clave</legend>
    <label for="password">Clave del certificado</label>
    <input id="password" type="password" name="password" required tabindex="3" />
  </fieldset>
  <p>
    <input name="submit" type="submit" value="Upload Files">
  </p>
</form>
</body>
</html>

En la action del formulario invoca a la función run_script.php. Este script en
PHP debe gestionar los archivos enviados en el formulario y gestionar el proceso
de firmar electrónica ejecutando por consola la aplicación PortableSigner.jar

Pasos a realizar en el script run_script.php:

-Manejo del nombre y ruta del archivo a firmar Ruta del certificado PKCS#12
-Ruta del archivo firmado
-Ejecutar por consola el proceso de firma usando la aplicación PORTABLESIGNER
-Eliminar tanto el archivo a firmar como el certificado PKCS#12 enviado por el
formulario

Código del script run_script

<?php

/**
* ValidateFiles
* valida de archivos subidos
* @param temp (ruta del archivo temporal)
* @param route (ruta relativa del archivo subido)
* @return bool
*
* @author Angelo Osorio (@engelpain)
* @licence CENDITEL 2.0
*/

function ValidateFiles($temp, $route) {
    move_uploaded_file($temp, $route) or die("Error al intentar subir el archivo." . $route);
}

// Datetime
$datetime = date_timestamp_get(date_create()); // nombre que tendrán los archivos temporales cargados

// Frase de paso del p12
$passphase = $_POST["password"]; // Contraseña o frase de paso cifrada

// PDF
$route_pdf = './tmp/' . $datetime . '.pdf'; // ruta donde se alojará el archivo firmado
$pdf = $_FILES['pdf']['tmp_name']; // ruta temporal del archivo a firmar subido

// PKCS12
$route_pkcs12 = './tmp/' . $datetime . '.p12'; // Ruta donde se alojará el archivo PKCS#12
$pkcs12 = $_FILES['pkcs12']['tmp_name']; // ruta temporal del archivo PKCS#12 subido
print_r(ValidateFiles($pdf, $route_pdf));
print_r(ValidateFiles($pkcs12, $route_pkcs12));

// Ejecución del script que conecta con el API de PortableSigner
$callPortable = "java -jar ./PortableSigner.jar -n";
$run_shell = shell_exec("$callPortable -t $route_pdf -o ./tmp/$datetime-signed.pdf -s $route_pkcs12 -p $passphase");
$run = ($run_shell) ? false : true;

if ($run) {
//Eliminación del archivo a firmar y del archivo PKCS12
    echo '<a href="./tmp/'.$datetime.'-signed.pdf"> Download PDF signed</a>';
    // Se borran los archivos de tmp
    unlink($route_pdf) or die("No se pudo eliminar el pdf");
    unlink($route_pkcs12) or die("No se pudo eliminar el p12");
} else {
    echo "PortableSigner no se ejecutó correctamente.";
}

Como podemos observar en el código del script run_script.php se almacenan los
archivos gestionados para el proceso de firma en un directorio con el nombre de
tmp/, en este sentido procedemos a crear dicho directorio dentro de la carpeta
murachi creada anteriormente y le asignamos los permiso necesarios para que
pueda ser utilizado.

$ mkdir tmp

$ sudo chown -R www-data:www-data /var/www/html/murachi/*

$ sudo chmod 777 /var/www/html/murachi/*

Hasta este momento se debe tener en el servidor de Apache dentro de la carpeta
murachi el archivo index.php, run_script.php, el ejecutable PortableSigner.jar y
el directorio tmp/. Verifique que sea así y que se encuentra en la ruta
indicada.

Por último, se ejecuta en el navegador /localhost/murachi/index.php, se carga el
archivo PDF a firmar, el certificado en formato PKCS#12 junto con su contraseña
o frase paso y se procede a hacer clic en el botón enviar y el resultado sera un
enlace (Download PDF signed) para descargar el archivo firmado.

Para verificar la firma electrónica del archivo firmado en esta sección puede
ingresar al portal de MURACHÍ (https://murachi.cenditel.gob.ve/) sección
Verificar (viñeta Verificar) y enviar el archivo firmado.

===============================
Abrir nautilus desde la consola
===============================

$ /usr/bin/nautilus

ó

Alt + f2 y tipear y luego enter:

/usr/bin/nautilus

============
Patch (Unix)
============

Patch es un comando de Unix que actualiza ficheros de texto de acuerdo a las
instrucciones contenidas en un archivo separado, llamado archivo de parche. Este
archivo (denominado patch) es un archivo de texto que consiste en una lista de
las diferencias entre ficheros y se produce mediante la ejecución del comando
diff comparando con el fichero original y actualizándolo con los argumentos de
diff.

El programa original fue escrito por Larry Wall (creador del lenguaje de
programación Perl) en mayo de 1985. Una nueva versión del programa es parte del
proyecto GNU y es mantenido por la FSF.

Contexto de uso
===============

El comando se utiliza con frecuencia para la actualización del código fuente a
una versión más reciente. Debido a esto es utilizado frecuentemente en sistemas
de control de código fuente como CVS. El programa no solo es capaz de añadir
texto como puede intuirse, también es capaz de eliminarlo.

Ejemplo de uso
==============

1- Creación del fichero:

Creamos el fichero a.txt, agregar contenido, hacer una copia de a.txt que se
llamará b.txt y hacerle modificaciones:

2- Comparar las diferencias con git diff, se requiere tener instalado el paquete
git:

$ git diff diff a.txt b.txt

3- Crear archivo que contiene la mezcla de ambos archivo, lo cual incluye las
modificaciones:

$ diff -u a.txt b.txt > mods.diff

Esto nos crea el archivo mods.diff el cual podemos revisar y ver su contenido
para ver como funciona.

4- Aplicación del parche, con el siguiente comando vamos a aplicar creado,
esto quiere decir que b.txt ahora a.txt se actualizara con las modificaciones de
b.txt:

$ patch < mods.diff

El resultado es que ahora a.txt y b.txt son iguales.

================================================================
Monitorear temperatura del CPU y otros componentes de la máquina
================================================================

$ sudo apt install lm-sensors

$ sudo sensors-detect

Luego darle yes a todo

$ sensors

Esto muestra algo como esto:

HP_smm-virtual-0
Adapter: Virtual device
Processor Fan: 2876 RPM
CPU:            +56.0°C
Ambient:        +33.0°C
SODIMM:         +43.0°C
GPU:            +47.0°C

nouveau-pci-0100
Adapter: PCI adapter
GPU core:         N/A  (min =  +0.85 V, max =  +1.03 V)
temp1:            N/A  (high = +95.0°C, hyst =  +3.0°C)
                       (crit = +105.0°C, hyst =  +5.0°C)

                       (emerg = +135.0°C, hyst =  +5.0°C)
acpitz-acpi-0
Adapter: ACPI interface
temp1:        +25.0°C  (crit = +107.0°C)

coretemp-isa-0000
Adapter: ISA adapter
Package id 0:  +58.0°C  (high = +86.0°C, crit = +100.0°C)
Core 0:        +58.0°C  (high = +86.0°C, crit = +100.0°C)
Core 1:        +54.0°C  (high = +86.0°C, crit = +100.0°C)

BAT0-acpi-0
Adapter: ACPI interface
in0:          12.34 V  
curr1:         2.74 A 

Donde notamos que nos dice la temperatura actual en grados centigrados, además
de que nos indica cual valor sería lato y cual sería crítico.

Para el procesador no de bería pasar de los 70°C, en este ejemplo está en 58°C
cada núcleo.

===========================
Mbps (Megabits por segundo)
===========================

Los megabits por segundo se refieren a la velocidad a la que se transmite 1
Megabit (Mb) en un segundo. 1 Mb se refiere a 1000^2 bits o 1.000 Kb. El uso del
prefijo "Mega-" para mostrar cantidades de un millón de Mbps es una medida común
de las velocidades de transmisión de datos actuales. Un bit es la unidad más
pequeña de información en un sistema digital que pertenece a un valor binario.

Hay una diferencia entre Mbps y MBps, ya que la letra "b" más pequeña denotaría
bits, mientras que la "B" mayúscula se utilizaría al referirse a un cluster de
datos más grande, bytes. Un solo byte es un grupo de 8 bits. Como resultado, un
megabit se referiría a 1.000.000 bits mientras que un megabyte se referiría a
8.000 bits. Los datos de Internet se indican en bytes, pero las velocidades se
miden en bits por segundo, ya que la transmisión de datos se realiza de a 1 bit
cada vez.

La tecnología moderna transfiere datos a velocidades medidas en Mbps. Mientras
que los sistemas altamente desarrollados pueden proporcionar velocidades aún más
rápidas medidas en Gigabits por segundo, con 1Gb equivalente a 1.000Mb, las
tasas más comunes en todo el mundo siguen estando al nivel de los Mbps. La
tecnología anterior funcionaba a velocidades tan bajas como 56Kbps.
Afortunadamente, los crecientes desarrollos en la industria de la tecnología han
llevado a velocidades más rápidas. 1 Mbps equivale a 1.000 Kbps o 1.000.000 bps.
1 Gbps es igual a 1.000.000.000 Kbps o 1.000 millones de bps. La mayoría de las
velocidades de datos se registran en Mbps.

=======================================================
Usar la ñ y las vocales con acénto en teclado en inglés
=======================================================

Agregar en la configuración de idioma o región el Inglés Internacional
con teclas muertas, luego:

ñ = Alt + n

Ñ = Alt + Shit + n

á é í ó ú = Alt + vocal.

====================================
Instalar Counter-Strike en Debian 11
====================================

$ sudo apt-get install apt-transport-https

$ sudo dpkg --add-architecture i386

$ wget -nc https://dl.winehq.org/wine-builds/Release.key

$ sudo apt-key add Release.key

Add this on /etc/apt/sources.list save changes and update repos:
deb https://dl.winehq.org/wine-builds/debian/ jessie main

$ sudo apt-get update

$ sudo apt-get install wine

Instalar el juego:

$ wine cs.exe

Ejecutar el juego, hay que ir a:
/home/user/.wine/dosdevices/c:/Games/Counter-Strike 1.6

y luego

$ wine Counter-Strike\ 1.6.exe

ó

$ wine /home/user/.wine/dosdevices/c:/Program Files (x86)/Counter-Strike 1.6

Todo depende de donde se haya instalado el juego.

Instalar Zoom en Debian 10/11
=============================

1) Descargue el archivo instalador DEB desde el Centro de descargas.

https://zoom.us/download?os=linux

2) Luego instalar las siguientes dependencias del SO:

$ sudo apt install gdebi libxcb-xtest0

3) Instalar el paquete descargado:

# dpkg -i zoom_amd64.deb

Listo!

Si da este error
================

dpkg: problemas de dependencias impiden la configuración de zoom:
 zoom depende de libgl1-mesa-glx; sin embargo:
  El paquete `libgl1-mesa-glx' no está instalado.
 zoom depende de libegl1-mesa; sin embargo:
  El paquete `libegl1-mesa' no está instalado.

Instale lo siguiente:

$ sudo apt-get install libxcb-xtest0

Luego de nuevo:

# dpkg -i zoom_amd64.deb

Listo!

===========================================
Ejecutar comandos en segundo plano en Linux
===========================================

En algunas ocasiones puede ser necesario ejecutar un script en segundo plano; ya
sea porque tarde mucho en finalizar o porque el programa tiene que ejecutarse de
forma indefinida y al mismo tiempo se quieren analizar sus salidas/salidas en
tiempo real, o cuando, en el caso de conexiones remotas, por el motivo que sea,
se pueda producir una desconexión.

1 posibilidad es usar &

===========
& + bg + fg
===========

Si añadimos un ampersand (&) al final de un comando o de un script que queramos
ejecutar, este se ejecutará en segundo plano.

$ ./my-shell-script.sh &
[1] 10233

Si ejecutamos un comando de la forma habitual (en primer plano o foreground) y,
después de pasado un cierto tiempo, nos damos cuenta que hubiera sido mejor
ejecutarlo en segundo plano o background, lo podemos hacer sin necesidad de
tener que matar el proceso y volver a ejecutarlo de nuevo con el ampersand.
Esto se hace presionando “CTRL+Z” para suspender la ejecución del comando
actual, y después invocando el comando bg.

$ ./my-shell-script.sh
^Z
[2]+  Detenido                my-shell-script.sh

$ bg
[2]+ my-shell-script.sh &

Este proceso que acaba de pasar al segundo plano, también se puede volver al
primer plano con el comando fg.

$ fg 2
my-shell-script.sh

Fuente
======

https://medium.com/@calmarianet/3-formas-de-ejecutar-comandos-en-segundo-plano-en-linux-9dedb779ca7d

===============================
Colorear el prompt del terminal
===============================

Metemos esto en la consola y nos pinta el user y el nombre de la máquina:

$ PS1='${debian_chroot:+($debian_chroot)}\[\033[01;33m\]\u\[\033[01;35m\]@\[\033[01;33m\]\h\[\033[00;33m\]:\[\033[01;34m\]\w\[\033[00m\]$ '

ó esto:

$ PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u\[\033[01;34m\]@\[\033[01;33m\]\h\[\033[00;33m\]:\[\033[01;34m\]\w\[\033[00m\]$ '

Ver el link la fuente para ver los demás colores.

Si lo metemos en el .bashrc ya colorea siempre la consola.

Otras pruebas
=============

Prompt por defecto

$ PS1="\u@\h:\W\$ "

Ahora, nuestro prompt quedará tal que así:

:~$

-----

#Prompt con caracteres adicionales
$ PS1="[\u@\h:\W]\$> "

Ahora, nuestro prompt quedará tal que así:

[usuario@hostname:~]$>

-----

Modificación sencilla de nombre de usuario y host:

$ PS1="Hola@bienvenido> "

Ahora, nuestro prompt quedará tal que así:

Hola@bienvenido>

-----

Cambiar el color de fondo al nombre del host, el código a utilizar sería este:

$ PS1="\u@\[\e[31;46m\]\h\[\e[m\] "

Fuentes
=======

-https://ubuntuperonista.blogspot.com/2014/01/como-cambio-los-colores-del-prompt-en.html
-https://www.zeppelinux.es/modificar-el-prompt-en-una-shell-bash/
-https://ubunlog.com/prompt-ejemplos-personalizar-terminal/

=======================================
Mover y redimensionar ventanas en Gnome
=======================================

Mueva una ventana arrastrándola desde la barra de título o manteniendo pulsada
la tecla Súper o Tecla ventana y arrastrando en cualquier parte de la ventana.

Fuente
======

https://help.ubuntu.com/stable/ubuntu-help/shell-windows-states.html.es

====================================================================
Programas recomendados para el un sistema operativo recién instalado
====================================================================

terminator (Configurar, luego)
vim (Configurarlo)

.bashrc (Configurarlo, alias, etc...)
alias ll='ls -l --color'
alias buscar='grep --color -n -Ir'
Colorear el prompt del terminal

sudo (Configurar y Probar)
aptitude (Probar)
ssh (Configurar y Probar)
git (Configurarlo, Probarlo)
vlc player
apache (Probar)
postgresql (Probar)
Virtual Box (Opcional)
rsync
meld
alacarte
audacity
gnome-paint
progress
pavucontrol
vscode o sublime
firefox de la página oficial y crear lanzador al ejecutable
Chrome
Inkscape

====================================================
Apagar el ordenador después de un tiempo determinado
====================================================

Abrimos una terminal. Una vez abierta la terminal ejecutamos el siguiente
comando:

$ sudo shutdown -h +30

El significado de cada uno los términos del comando son los siguientes:

sudo: Porque el programa shutdown precisa permisos de superusuario para ejecutarse.

shutdown: Es el programa que permite programar el apagado del ordenador.

-h: Indica la acción a realizar una vez pasado un tiempo determinado. En este
caso la acción es la acción halt (-h). Por lo tanto una vez pasado el tiempo que
queramos el ordenador se apagará.

+30: Indicamos el tiempo en minutos que queremos que tarde en apagarse el
ordenador.

El comando "shutdown" se encarga de apagar el sistema de manera segura,
asegurándose de que todos los procesos se cierren correctamente antes de apagar
el sistema. Por lo tanto, no debes preocuparte por un apagado brusco o pérdida
de datos.
Además, si por alguna razón necesitas cancelar el apagado programado, puedes
hacerlo usando el siguiente comando en la terminal:

$ sudo shutdown -c

Esto cancelará el apagado programado y mantendrá el sistema encendido.

Fuente
======

https://geekland.eu/programar-el-apagado-del-ordenador/

ChatGPT

Posible missing firmware /lib/firmware/rtl_nic/rtlXXXX

Indica que el kernel de Linux no pudo encontrar el archivo de firmware necesario
para que un dispositivo de red funcione correctamente.

Para solucionar este problema, debes instalar el firmware correspondiente. En
este caso, el firmware que falta es para el controlador de red RTLXXX.

Sigue estos pasos para instalar el firmware:

Abre una terminal en Debian.

Ingresa el siguiente comando para instalar el paquete "firmware-realtek":

$ sudo apt-get install firmware-realtek

Reinicia tu sistema.

Fuente
======

ChatGPT

=====
NGROK
=====

NGROK es una herramienta de uso gratuito que nos permite exponer nuestro entorno
local a la web, es decir, podemos "publicar" nuestro trabajo en local para que
el resto del mundo lo pueda ver sin la necesidad de subir la aplicación a un
servidor.

1- Creamos una cuenta e iniciamos sesión en https://ngrok.com

2- Descargamos el script desde https://dashboard.ngrok.com/get-started/setup
nos quedara algo como esto ngrok-v3-stable-linux-amd64.tgz

3- Descomprimimos el archivo, nos debe quedar una carpeta de nombre
ngrok-v3-stable-linux-amd64 y dentro debe haber un script llamado ngrok

4- Conecta tu cuenta

Ejecutar este comando agregará su authtoken al archivo de configuración
predeterminado ngrok.yml.

Esto le otorgará acceso a más funciones y tiempos de sesión más prolongados.

Los túneles en ejecución aparecerán en la página de puntos finales del tablero.

El token es proporcionado desde la web.

$ ngrok config add-authtoken XXXXXX

ó

$ ./ngrok config add-authtoken XXXXXX

4. Copiamos el script ngrok obtenido dentro de /var/www/html

5. Ejecutamos el script desde /var/ww/html con:

/var/www/html$ ./ngrok http 80

Esto te levanta un servicio:

ngrok                                                                                                                                         (Ctrl+C to quit)
                                                                                                                                                              
Announcing ngrok-rs: The ngrok agent as a Rust crate: https://ngrok.com/rust                                                                                  
                                                                                                                                                              
Session Status                online                                                                                                                          
Account                       usuario-de-mi-cuenta@mail.com (Plan: Free)                                                                                          
Version                       3.2.2                                                                                                                           
Region                        United States (us)                                                                                                              
Latency                       -                                                                                                                               
Web Interface                 http://127.0.0.1:4040                                                                                                           
Forwarding                    https://a71f-XXXXX.ngrok.io -> http://localhost:80                                                                      
                                                                                                                                                              
Connections                   ttl     opn     rt1     rt5     p50     p90                                                                                     
                              0       0       0.00    0.00    0.00    0.00

Si copias esta dirección en la web, podrás ver el contenido de /var/www/html
desde cualquier parte.

Esto es ideal para mostrar proyectos, hacer pruebas, etc.

Conectarse por ssh usando ngrok
===============================

--- En el servidor ---

1- Instalar openssh-server

$ sudo apt install openssh-server

2- Ejecutar el servicio de openssh-server

$ sudo service ssh start

3- Ejecutar ngrok con tcp y el puerto 22

$ ./ngrok tcp 22

# ngrok will start like:
# ngrok by @inconshreveable                                     (Ctrl+C to quit)
#                                                                                                
# Session Status                online                                                            
# Account                       User Name (Plan: Free)                                      
# Version                       2.3.27                                                            
# Region                        United States (us)                                                
# Web Interface                 http://127.0.0.1:4040                                             
# Forwarding                    tcp://0.tcp.ngrok.io:16965 -> localhost:22
#                            /\ url and port number you'll use on ssh connection

--- En el cliente ---

Si el usuario de la maquina es decir el servidor es pcontreras entonces:

$ ssh pcontreras@0.tcp.ngrok.io -p 16965

Te pedirá la contrasena del usuario pcontreras del servidor, la introduces y
listo! ya estás en el server mediante SSH.

==============================================================
Correr aplicación Laravel usando ngrok para verla por internet
==============================================================

1- Inicia tu servidor local de Laravel ejecutando el comando adecuado, como php
artisan serve en la raíz de tu proyecto Laravel, esto seguro servira la app
en una dirección como esta: http://127.0.0.1:8000

2- Abre una nueva terminal o línea de comandos y ejecuta el comando ngrok,
especificando el puerto en el que se está ejecutando tu servidor Laravel. Por
ejemplo, si tu servidor se está ejecutando en el puerto 8000, utiliza el
siguiente comando:

$ ngrok http 8000

Ngrok generará una URL pública que puedes compartir con la persona a la que
deseas mostrar tu aplicación.

Copia la URL generada por ngrok y compártela con la persona a la que deseas
mostrar tu aplicación. Cuando esa persona acceda a la URL en su navegador web,
el tráfico se redirigirá a tu servidor local y podrán ver y utilizar tu
aplicación Laravel en tiempo real.

Recuerda que ngrok genera una URL pública temporal que puede cambiar cada vez
que lo ejecutas.

Fuentes
=======

https://dashboard.ngrok.com/get-started/setup

https://www.youtube.com/watch?v=NqCYquO3byk

https://gist.github.com/philippeoz/e33632f11c64149a00393465fee2cff5

https://www.endtoend.ai/tutorial/ngrok-ssh-forwarding/

ChatGPT

Teamviewer
==========

1- Descargamos el .deb desde https://www.teamviewer.com/es-mx/descarga/linux/ o
directamente con:

$ wget -c https://download.teamviewer.com/download/linux/teamviewer_amd64.deb

2- Realizamos la instalación con:

# dpkg -i teamviewer_amd64.deb

3- Ejecutar teamviewer:

$ teamviewer

4- Esto te abrira el cliente de teamviewer en el cual veras un id y una
contraseña, en la segunda máquina a la cual te quieres conectar, también debes
realizar toda la instalación igual, abrir el cliente de teamviewer y ya, desde
cualquiera de los dos clientes, debes introducir el id y la contraseña de la
máquina a la cual te quieres conectar.

================
¿Qué es pfSense?
================

PfSense es un programa de código abierto que le permite a un usuario tener un
firewall de alto nivel en su ordenador. PfSense permite establecer cortafuegos
desde máquinas virtuales, las cuales pueden descargarse desde su página oficial.
No obstante, también se venden dispositivos físicos (appliances), que traen el
sistema incorporado y listo para funcionar.

PfSense es un cortafuegos que se ubica entre internet y nuestros dispositivos
con el fin de detectar actividades sospechosas y bloquearlas de inmediato. Esto
nos puede poner a salvo de la mayoría de amenazas externas (aunque también
pueden existir fuentes de amenaza internas). Por esta razón, se trata de un
software o hardware bastante útil para las compañías o, incluso, para uso
personal.

Existen diferentes tipos de firewalls y, por supuesto, también diferentes
formatos. PfSense puede clasificarse dentro del tipo de firewall UTM, cuyas
siglas significan unified threat management, que se traduce como gestión
unificada de amenazas. Esto quiere decir que pfSense contiene un conjunto de
funciones avanzadas que van más allá de la simple regulación del tráfico de red
basado en normas.

Al ser un software 100% libre, su código fuente puede hallarse en un repositorio
de GitHub. Por este motivo, la aplicación también puede personalizarse según las
necesidades del equipo de ciberseguridad. Aprender qué es pfSense, cómo
implementarlo y cómo se desarrolló es esencial para contar con un firewall de
alto nivel, totalmente gratuito, protegiendo tu red.

Fuente
======

https://keepcoding.io/blog/que-es-pfsense/

================
¿Qué es PROXMOX?
================

PROXMOX VE “Virtual Environment” es una potente plataforma de virtualización de
nivel empresarial 100% libre y sin límites en su uso.

PROXMOX VE ofrece beneficios similares a los productos para virtualización como
VMware vSphere, Windows Hyper-V, Citrix XenServer, entre otros.

​Siendo PROXMOX libre sin costo, lo puede instalar en cualquier cantidad de
“Servidores físicos”, sin límite en uso de Procesadores y Sockets, Puentes de
comunicación, o integración de NAS o SAN ya sea a través de Fibra Canal, iSCSI
Over Ethernet o NFS.

Principales características de PROXMOX
======================================

Administrador Web HTML5, PROXMOX proporciona un interfaz Web para configurar los
servidores físicos, cluster, máquinas virtuales, políticas de backups,
restauración de backups, snapshots. No es necesario instalar aplicaciones
clientes en su máquina para administrar y siendo HTML5 le permite conectarse y
gestionar el entorno virtualizado desde su Smartphone Android, Iphone, tablet's,
entre otros.

​Virtualización para la mayoría de Sistemas Operativos, en sus versiones
32/64bits: Linux en todas sus versiones, Microsoft Windows 10 / 2016 / 2012 / 7
/ 8/ 2003 / xp, Solaris, AIX, entre otros.

​KVM (Máquina virtual basada en el núcleo) es una solución para implementar
virtualización sobre Linux. Puede funcionar en hardware x86/x86_64 y es
necesario que el microprocesador tenga soporte de virtualización Intel "VT" y en
AMD "SVM".​

​Container-based Virtualization (LXC), es una alternativa para ejecutar máquina
"Linux" en espacios separados. A diferencia de la virtualización este funciona
como un módulo agregado al servidor físico y hace uso directo del hardware
(también conocido como Paravirtualización).

Backup & Restore de "Máquinas Virtuales". En Proxmox el efectuar estas tareas es
muy sencillo y se administra a través de su interfaz Web. Puede efectuar un
backup de forma inmediata o dejarlo programado. La restauración es simple, solo
debe de seleccionar el backup a restaurar y listo.

Snapshot Live. le permite hacer copias instantáneas de "Máquinas Virtuales"
incluyendo el contenido de la RAM, su configuración y el estado de los discos
virtuales. Usted puede retroceder en tiempo la "Maquina Virtual" restaurando
spanshot's.

​"Migración en caliente". En la gráfica izquierda se muestra un pequeño cluster
formado por 3 nodos y poblado con “Máquinas virtuales”. Con fondo rojo se
muestra un nodo con sobrecarga. La administración de los nodos es centralizada a
través de un interfaz Web, permitiéndole movilizar “Máquinas virtuales” entre
cada “Servidor Físico (NODO)” sin tener que apagar la “Máquina Virtual”.​

"Cluster Alta disponibilidad". Esta característica le permite definir reglas de
“Alta disponibilidad” en el cluster, por ejemplo: Si uno de los “Servidores
Físicos (NODO)” esta sobrecargado, este transfiere automáticamente a otro
“Servidor Físico (NODO)” con menos carga la “Máquina Virtual”. Este ejemplo es
una regla de "balanceo de carga entre nodos".

Administración centralizada. En un "Cluster Proxmox" se debe definir una de los
Nodos como "Orquestador" con el objetivo de centralizar el trabajo, sin embargo
cada nodo cuenta con su propio administrador Web.

Cluster no SPOF (Single Point Of Failure). Cada nodo "Servidor físico Proxmox"
cuenta con su propio interfaz Web permitiendo acceso a la administración de las
"Máquinas Virtuales". Si el nodo "Orquestador" llega a fallar, cada nodo tiene
replicado la información del "Orquestador" y desde cualquiera de los nodos puede
tomar control del cluster.

Puentes de red. Proxmox administra las tarjetas físicas a través de "Bridges"
que comparte a las "Máquinas Virtuales". Es muy sencillo asociar 1 o varias
tarjetas a un "Bridge" haciendo un balanceo automático del tráfico de datos.

NAS & SAN. Es muy fácil el uso de NAS o SAN ya sea a través de Fibra Canal,
iSCSI Over Ethernet o NFS. Proxmox no le limita.

Autenticación. Puede configurar la autenticación de acceso al área de
"Administración a los Nodos" a través de cuentas propias con Proxmox o
utilizando LDAP/Active Directory.

Firewall. Proxmox VE Firewall proporciona una manera fácil de proteger su
infraestructura en un entorno virtualizado. Puede definir reglas de firewall
para todas las máquinas virtuales o definir reglas precisas a una máquina
virtual.

¿Cómo funciona Proxmox?
=======================

Proxmox, le permite instalar en múltiples equipos y los únicos requisitos que le
pide es tener un "Procesador que cuente con VT o SVM" y que la máquina esté
vacía. El implanta Debian como sistema operativo y configura KVM para trabajar
con el recurso físico.

Cada máquina con Proxmox se convierte en un NODO y puede trabajar de forma
independiente o puede estar agrupado en un Cluster. El beneficio de definir un
Cluster es tener la administración centralizada, poder mover máquinas entre cada
nodo, activar "Alta Disponibilidad" y aprovechar todo el recurso de los equipos
físicos para la virtualización.

Para hacer uso de "Alta Disponibilidad" y "Mover Máquinas Virtuales sin
apagarlas" es necesario definir un "dispositivo de almacenamiento de tipo NAS o
SAN" por ejemplo OpenMediaVault o FreeNAS. También puede utilizar ECM, NetAPP,
DELL Equallogic, entre otros.

¿Que nos permite el Administración Web PROXMOX?
===============================================

Agregar "Máquinas Virtuales" y gestionarlas. Por ejemplo, puede apagar,
reiniciar, agregar hardware virtual, entre otros.

Mover máquinas entre cada nodo o activar "Alta Disponibilidad".

Conectarse directamente al interfaz gráfico o consola de la "Máquina Virtual" a
través de una conexión segura VNC "HTML5 WebSockets and Canvas -- NoVNC".

Programar Backups, restaurar backups o generar Snapshot.

Ver de forma gráfica la información de las "Máquinas Virtuales" como el tráfico
de red, consumo de procesador, consumo de memoria, entre otros.

Subir medias en formato ISO para instalar sistemas operativos en las "Máquinas
Virtuales".

Cambiar la configuración de los nodos.

Definir reglas en "Proxmox Firewall VE" para todas las "Máquinas Virtuales" o
para una es especial.

El Administrador Web PROXMOX es HTML5 por lo cual le será posible conectarse y
trabajar desde su Smartphone Android, Iphone, tablet's entre otros.

Fuente
======

http://911-ubuntu.weebly.com/proxmox_como_funciona/conoce-como-funciona-proxmox-y-como-usarlo

==============
Instalar Brave
==============

Brave es un navegador web de código abierto basado en Chromium, creado por la
compañía Brave Software en el año 2016, fundada por el cofundador del Proyecto
Mozilla y creador de JavaScript, Brendan Eich.​ A partir de 2019, Brave ha sido
lanzado para Windows, macOS, Linux, Android e iOS.

Instalación con apt
===================

$ sudo apt install curl

$ sudo curl -fsSLo /usr/share/keyrings/brave-browser-archive-keyring.gpg https://brave-browser-apt-release.s3.brave.com/brave-browser-archive-keyring.gpg

$ echo "deb [signed-by=/usr/share/keyrings/brave-browser-archive-keyring.gpg] https://brave-browser-apt-release.s3.brave.com/ stable main"|sudo tee /etc/apt/sources.list.d/brave-browser-release.list

$ sudo apt update

$ sudo apt install brave-browser

Instalación con Snap
====================

$ sudo snap install brave

Fuente
======

https://snapcraft.io/brave
