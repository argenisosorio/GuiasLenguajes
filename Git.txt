==========================
Guía de Git y GitHub by dM
==========================

Software de control de versiones diseñado por Linus Torvalds, pensando en la
eficiencia y la confiabilidad del mantenimiento de versiones de aplicaciones
cuando éstas tienen un gran número de archivos de código fuente. Hay algunos
proyectos de mucha relevancia que ya usan Git en particular, el grupo de
programación del núcleo Linux.

Nota:
-Usaremos $ para describir los comandos que se usaran con usuario regular.
-Usaremos # para describir los comandos que se usaran con superusuario.

-----

Instalar Git

# apt install git

-----

Con este comando nos listara la lista de comandos Git que podemos usar en un
proyecto.

$ git

-----

Saber que versión tenemos instalada.

$ git --version

-----

Lo primero que debemos hacer despues de la instalacion es configurar nuestro
Git.

Asignamos el nombre de usuario que será la firma del usuario en cada commit.

$ git config --global user.name "Argenis Osorio"

Igualmente el correo que siempre acompañara al autor de cada commit.

$ git config --global user.email aosorio@example.com

Comprobar el valor de las variables de configuración inicial de git, las que
acabamos de introducir.

$ git config --list

-----

Crear un directorio, dentro del directorio ejecutar para crear un nuevo
repositorio de git, nos crea una carpeta .git.

$ git init

Dentro están todos los ficheros de configuración de git para ese repositorio
específico.

-----

Remover git del directorio de trabajo.

$ rm -rf .git

-----

Muestra el estado actual de la rama, como los cambios que hay sin commitear.

$ git status

Lista los archivos del proyecto y se visualiza si fueron agregados al
seguimiento de Git.

-----

Tambien podemos ver si un archivo fue modificado y no ha sido agregado al
seguimiento de Git.

$ git status -s

-----

Agregar todos los archivos al seguimiento de Git.

$ git add *

-----

Hacer un commit al proyecto, se activara la rama master por defecto.

$ git commit -m "Primer commit del proyecto"

-----

Podemos ver todos los commits que se han hecho a un proyecto, fecha,
autor, etc...

$ git log

-----

Ver los autores de los commits además de listar cuantos commits han realizado.

$ git shortlog

-----

Genera un resumen condensado de información extendida del encabezado, como
creaciones o eliminaciones de archivos ("nuevo" o "desaparecido", opcionalmente
"+ l" si es un enlace simbólico) y cambios de modo ("+ x" o "-x" para agregar o
eliminar bit ejecutable respectivamente) en diffstat. La información se coloca
entre la parte del nombre del archivo y la parte del gráfico.  Implica --stat.

$ git log --compact-summary

-----

Muestra solo los nombres y el estado de los archivos modificados. Al igual que
--name-only, los nombres de los archivos a menudo se
codifican en UTF-8.

$ git log --name-status

-----

Lista todas las ramas locales.

$ git branch

-----

Lista todas las ramas locales y remotas.

$ git branch -a

-----

Lista todas las ramas locales y remotas.

$ git remote

-----

Lista todas las ramas, locales y remotas con más detalles como la url.

$ git remote -v

-----

Agregar un repositorio remoto a mi repo de Git.

$ git remote add my_name_remote https://github.com/darknesstrue/myrepo.git

-----

Push a la rama del repositorio remoto

$ git push <remote> <branch>

-----

Deshacer un git add antes de un commit

$ git reset <archivo>

$ git reset

-----

Ejemplo de archivos agregados al seguimiento de git:

A  gris.jpg // Agregado
A  file.html // Agregado
AM file2.html // Agregado y modificado, se debe agregar otra vez
?? file3.html // Archivo agregado al directorio pero no agregado al seguimiento

Agregar un fichero específico al seguimiento de Git, esto es útil si tenemos
muchos ficheros con modificaciones pero solo queremos subir los cambios de
algunos específicos, no de todos, entonces los agregamos manualmente.

$ git add Nombre_archivo.xxx

Ejemplo de varios archivos modificados, solo agregaremos algunos al seguimiento
de git:

	modified:    fichero1.xxx
	modified:    fichero2.xxx
	modified:    fichero3.xxx
	modified:    fichero4.xxx
	modified:    fichero4.xxx

Agregando ficheros específicos al seguimiento de git.

$ git add fichero1.xxx fichero2.xxx fichero3.xxx

El resto seguira esperando por una accion, como ser eliminado, seguir siendo
modificado o agregado al seguimiento.

-----

Borrar un fichero de manera segura, puesto que lo borra del directorio y del
seguimiento de git, es un error común borrar los archivos directamente y estos
siguen estando en el seguimiento de git por lo que se lia bastantes veces al
subir los cambios, recomendable borrarlos desde git.

$ git rm Nombre_fichero.xxx

-----

Forzar el borrado del fichero.

$ git rm -f Nombre_fichero.xxx

-----

Si un archivo fue modificado queda un registro de su nombre anterior en el cache
para borrarlo se usa este comando.

$ git rm --cached Nombre_archivo.xxx

-----

Para borrar un directorio y su contenido del seguimiento de git.

$ git rm --cached -r dir/dir

-----

Para borrar un directorio y su contenido del seguimiento de git, esta opción
funciona optimamente en mis pruebas.

$ git rm --cached -r dir/*

---

Corregir algun error en el texto del último commit

$ git commit --amend -m "comentario commit corregido"

Corregir un error en el commit, abrira un editor de texto

$ git commit --amend

---

Correguir un commit particular:

$ git rebase -i hash-del-commit~1

git rebase -i hash-del-commit~1 para pedir hacer rebase interactivo de la rama
actual a partir del commit anterior (~1) al que estás queriendo modificar. Eso
disparará tu editor por defecto con un listado de todos los commits que existen
desde ese hasta el tope de tu rama, indicando pick, hash y mensaje de cada uno.

Algo como:

pick abcdef0 Mensaje del commit más nuevo
pick bcdef01 Mensaje del commit anterior
pick fde2152 Mensaje del commit a editar

Cambiar pick por r o reword en la línea del commit a editar. ejemplo:

pick abcdef0 Mensaje del commit más nuevo
pick bcdef01 Mensaje del commit anterior
r fde2152 Mensaje del commit a editar

Guardar el fichero y salir, git va a volver hasta ese commit y abrirá el editor
nuevamente, pero esta vez con el mensaje del commit ahí presente. Algo como:

Mensaje del commit a editar

Este mensaje es el que habías escrito en el primer
git commit, y que ahora querés reemplazar por uno nuevo

Editar el mensaje para corregirlo, guardamos el archivo, salimos del editor, y
git aplicará todos los commits que faltaban para que tu rama quede igual,
excepto por tener el mensaje actualizado.

No olvidar que se está modificando la historia de tu repositorio, por lo que si
habías publicado el commit al que estás editando el mensaje o cualquiera de sus
sucesores podés generar conflictos.

---

Borrar el ultimo commit hecho.

$ git reset --hard HEAD~1

-----

Deshaciendo la preparación de un archivo, con esto le decimos a git que deje de
seguir a un archivo.

$ git reset HEAD name_file.xxx

-----

Crear una rama.

$ git branch Nombre_Rama

-----

Crear una rama y cambiarse a ella.

$ git checkout -b Nombre_Rama

-----

Borrar o eliminar una rama, se debe estar en otra rama para borrarla

$ git branch -d Nombre_Rama

-----

Forzar el borrado o eliminación de una rama, a veces no se dejan borrar si hay
cambios sin guardar.

$ git branch -D Nombre_Branch

-----

Borrar o eliminar una rama de un repositorio remoto.

$ git push origin :the_remote_branch

-----

Borrar o eliminar múltiples ramas según la busqueda filtrada.

Para borrar todas las ramas locales que comiencen con feat, puedes ejecutar el
siguiente comando en Git:

$ git branch | grep '^  feat' | xargs git branch -d

Explicación:

git branch: Lista todas las ramas locales.

grep '^ feat': Filtra las ramas que comienzan con feat. El ^ indica el comienzo
de la línea y el espacio en blanco que sigue está incluido para capturar ramas
que están alineadas correctamente en el listado.

xargs git branch -d: Pasa las ramas encontradas a git branch -d, que borra las
ramas locales.

Si algunas de estas ramas no se pueden eliminar porque aún no están
completamente fusionadas, puedes usar la opción -D en lugar de -d para forzar la
eliminación:

$ git branch | grep '^  feat' | xargs git branch -D

Fuente
======

ChatGPT

-----

Cambiarse de rama

$ git checkout Nombre_Rama

-----

Para ver los ultimos commits de cada rama.

$ git branch -v

-----

Subir los cambios al repositorio remoto en la rama master.

$ git push origin master

-----

Estando en otra rama local, Subir los cambios al repositorio remoto en la rama
master, si no existe la rama, la creará.

$ git push origin nombre_rama

git push -f <remote> <branch> forzar el push para sobreescribir los ficheros en
el repositorio remoto.

$ git push -f origin master

-----

Guardado rápido provisional de los cambios pendientes, lo cual nos va a permitir
cambiarnos de rama sin que se nos queje de que hay cambios pendientes.

$ git stash

-----

Listar los estados guardados provicionalmente.

$ git stash list
    stash@{0}: WIP on master: 049d078 added the index file
    stash@{1}: WIP on master: c264051... Revert "added file_size"
    stash@{2}: WIP on master: 21d80a5... added number to log

-----

Reactivando el primer cambio guardado rápídamente, falta probar bien.

$ git stash apply stash@{0}

-----

Es posible que no desee guardar algunos trabajos o archivos en su directorio de
trabajo, sino simplemente deshacerse de ellos; para eso es el comando:

$ git clean

==================================
Configurando el fichero .gitignore
==================================

Cuando creamos un repositorio git dentro de un directorio, inicialmente se
incluyen todos los archivos de dicho directorio dentro del control de versiones
de git, para así poder seguir los cambios que se van realizando en el proceso de
desarrollo.

Ficheros .gitignore, es en estos archivos donde se incluyen las rutas de todos
los directorios y ficheros que queremos excluir de git, es decir, que no
queremos que sean rastreados.

Básicamente git hace una lectura en todos los directorios dentro de la carpeta
del proyecto, y cada vez que encuentre un archivo .gitignore lo lee para saber
que otros archivos debe excluir.

La ubicación del .gitignore depende de ti, puedes tener un único archivo global
en el directorio principal o uno independiente dentro de cada carpeta que
quieras configurar.

=============================
Creando un archivo .gitignore
=============================

Esto es muy sencillo, básicamente es un archivo de texto plano donde debes
escribir las rutas que deseas excluir del repositorio, esto no quiere decir que
los ficheros van a ser borrados, simplemente los cambios que hagas allí no se
van a ver reflejados en ningún commit mientras la ruta se encuentre definida en
el .gitignore.

Es importante que el nombre sea exactamente ".gitignore" sin preposiciones,
símbolos o cualquier otro caracter diferente a esto.

Supón que tienes el siguiente directorio:

--index.php
--assets
    css
    main.css
    variables.css
--js
    sidebar.js
    main.js
--contact.php
--config.php
--server_config.php

Digamos que en tu archivoserver_config.php tienes información delicada sobre
conexiones a tu servidor que no quieres incluir en el repositorio para
compartirlo con tus colaboradores, ese tal vez sea el primer archivo que quieras
excluir, para ello creas el archivo .gitignore y agregas la siguiente linea:

server_config.php

Ahora git incluirá todo el directorio menos ese archivo:

--index.php
--assets
    css
    main.css
    variables.css
--js
    sidebar.js
    main.js
--contact.php
--config.php
XXX - server_config.php

Bien, tal vez la carpeta assets/js se haya creado para hacer algunas pruebas de
forma local y aun no quieras incluirla en el commit:

server_config.php
assets/js

Cuando referencias a una carpeta, todo lo que está dentro de ella se incluye
como parte de los archivos sin seguimiento, pero si solo se quisiera
omitir el contenido entonces sería

assets/js/

====================================================
Ignorando un fichero que no se deja en el .gitignore
====================================================

Cuando un fichero ya está bajo el control de versiones de git, git seguirá
rastreando el archivo, no importa lo que escriba en .gitignore. Tienes que decir
explícitamente a git que se olvide de ese fichero con:

1) Agregar el fichero a ignorar en el .gitignore

2) Remover el fichero del seguimiento con:

$ git rm --cached projectname/settings.py

3) Hacer el commit del cambio con:

$ git commit -m "Removido settings del seguimiento"

===========================
Ignorando settings globales
===========================

Es probable que en algún momento se trabaje con un proyecto modular, es decir
que los componentes de dicho proyecto pueden ser ejecutados por separado pero a
su vez se pueden comunicar cuando se necesite, entonces, al ser sub proyectos o
aplicaciones es posible que cada uno posea un fichero de configuración y que por
alguna razón queremos ignorarlo, si estas aplicaciones forman parte de un
proyecto entonces es posible que tengas un fichero .gitignore global y que
abarca todos los subdirectorios, entonces de manera manual, si queremos omitir
esos archivos de configuración sería tal que asi:

project/app1/settings
project/app2/settings

Con eso estaríamos omitiendo los settings de esas aplicaciones
pero si declaramos un settings en el gitignore

settings

Entonces se omitiran de manera global todos los ficheros que coincidan, es
decir, no hay que especificar la ruta completa de los ficheros a omitir, para
este caso, puede ser que si lo amerite para otro casos.

====================
El fichero README.md
====================

README (en español LEEME o LEAME) es un documento de texto que acompaña
normalmente a los programas (Proyectos), en el cual hay información de
relevancia sobre éste en cuanto a su uso, nuevas características, errores (bugs)
y requisitos de software o hardware.

Generalmente se distribuye en formato de texto plano, aunque también puede estar
en otros formatos que permiten agregar estilos como Encabezados, subrayados,
listas, enlaces, imágenes, etc.

Generalmente la estructura del fichero debería ser la siguiente:

*****
-Languaje version
-System dependencies
-Configuration
-Database creation
-Database initialization
-How to run the test suite
-Services (job queues, cache servers, search engines, etc.)
-Deployment instructions
*****

Es posible omitir algunas, lo que se desea es que el que lea este fichero, pueda
correr con éxito el proyecto siguiendo los pasos descritos.

Con (#) escribimos comentarios dentro de un fichero .gitignore

=================================
Ejemplo de .gitignore para Django
=================================

*.*.backup
*.*~
*.tar.gz
*.pyc
*.pyo
*.log
*.swp
*.sqlite3
*.db
#/project/app/migrations
#/project/settings.py

==============================================
Ejemplo de .gitignore para archivos temporales
==============================================

# Temporary files of every sort
*~
*.swp
*.swp~

===================================================================
Eliminando varios archivos de Git que ya se han eliminado del disco
===================================================================

$ git add -u

$ git commit -m "Deleted files manually"

======================================================================
Agregar archivo al seguimiento de git si está omitido en el .gitignore
======================================================================

$ git add -f ruta/del/archivo/archivo.txt

===============
Mezclando ramas
===============

Para fusionar dos ramas, en este caso una rama de desarrollo con la rama master
se hace un git merge, para realizar la mezcla vamos a situarnos en la rama
master, y luego escribimos el comando donde especificamos que rama queremos
mezclar con master.

Tambien está el caso de una mezcla de versiones de una rama, ya sea de la rama
master local, con la rama master del repositorio, entonces si se hace un pull y
hay conflictos hay que arreglarlos manualmente y luego hacer el commit, por
ejemplo "Fix conflicts", si se hace la mezcla y no hay conflictos entonces el
propio git te ofrecera crear el commit, algo parecido a "Merge branch xxx in to
xxx"...

Cambiarsa a la rama master

$ git checkout master

Mezclar la rama desarrollo con master, si hay conflictos tal vez se tengan que
resolver (automáticamente) antes de mezclar.

$ git merge desarrollo

Recuperar y unir automáticamente la rama remota con tu rama actual, traerse los
cambios del repo al repo local. A veces puede haber conflictos con ficheros
locales y no deja hacer el pull, por lo que es necesario descartar esos
ficheros.

$ git pull origin master

Descartar cambios, probar el pull de nuevo

$ git checkout

Si no deja hacer el pull, descartar cambios en ese fichero/s para poder hacer
el pull.

$ git checkout fichero.xxx

Comparar la rama local con la rama del repositorio, nos dirá si estamos atrás o
delante del repo, y por cuantos commits.

$ git status origin master

Si estamos detrás, con un pull nos traeremos los cambios del repo, si estamos
delante, se hará un merge o una mezcla del repo local y el remoto y así tendra
todos los cambios listos, luego en el status del repo local, pedirá hacer un
push para estabilizar todos los cambios en el repo remoto.

======================
Borrando ramas remotas
======================

Imagina que ya has terminado con una rama remota. Es decir, tanto tu como tus
colaboradores habeis completado una determinada funcionalidad y la habeis
incorporado (merge) a la rama master en el remoto (o donde quiera que tengais la
rama de código estable). Puedes borrar la rama remota utilizando la un tanto
confusa sintaxis: git push [nombreremoto] :[rama]. Por ejemplo, si quieres
borrar la rama serverfix del servidor, puedes utilizar:

$ git push origin :serverfix
To git@github.com:schacon/simplegit.git
 - [deleted]         serverfix

Y... ¡Boom!. La rama en el servidor ha desaparecido. Puedes grabarte a fuego
esta página, porque necesitarás ese comando y, lo más probable es que hayas
olvidado su sintaxis. Una manera de recordar este comando es dándonos cuenta de
que proviene de la sintaxis git push [nombreremoto] [ramalocal]:[ramaremota]. Si
omites la parte [ramalocal], lo que estás diciendo es: "no cojas nada de mi lado
y haz con ello [ramaremota]".

-----

Este comando sirve para moverse entre los commits, cada commit genera una
etiqueta, un identificador muy largo alfanumerico, estas etiquetas identifican
una version del proyecto lo que permite restaurar el proyecto a estados
anteriores donde XXXXXX123456 representa la etiqueta del commit al que queremos
ir.

$ git checkout XXXXXX123456

Una vez movidos a ese commit especifico del historial se puede crear una nueva
rama desde ese punto con:

$ git checkout -b Nombre_Rama

Si hacemos git log nos mostrara los commits que habian hasta ese momento y el
ultimo es en el que nos encontramos, si queremos volver a tener los commits
anteriores solo hacemos git checkout a la rama en que estabamos antes o a alguna
rama especifica.

-----

Para forzar volver a la rama master por ejemplo, a veces no nos deja porque no
commitemos algunos cambios, como logs, etc.

$ git checkout -f master

-----

Si se hacen cambios o se agregaron archivos al proyecto este comando nos hará
mostrara una comparacion entre los ultimos cambios hechos el ultimo commit hecho
,es recomendable revisar esos cambios antes de agregarlos al seguimiento de git
y por supuesto antes de hacer un commit.

$ git diff

-----

Comparar diferencias entre la rama local y la del repositorio:

$ git diff <remote-branch> <local-branch>

$ git diff origin/develop develop

Si solo quieres ver los fichero modificados usamos --stat:

$ git diff origin/develop develop --stat

-----

Muestra la lista de ficheros modificados luego del último cambio.

$ git diff --stat

-----

Mostrar los ficheros modificados de dos commits específicos.

$ git diff --stat xxxxxxx xxxxxxx

-----

Mostrar las modificaciones de un fichero o más entre dos commits específicos,
los ficheros se separan con espacio y no con comas.

$ git diff xxxxxxx xxxxxxx file_name.xxx

-----

Ver solo los cambios o modificaciones de ese fichero, por ejemplo:

$ git diff nombre_fichero.xxx

-----

Si hacemos un git status y se muestra:

#	modified:   a.txt
#	modified:   b.html
#	modified:   b.py

Mostrar solo los cambios del fichero especificado.

$ git diff a.txt

---------

Luego de hacer el commit en la rama master y luego de haber creado la rama
desarrollo y hacer el commit se pueden listar los commits de las ramas
existentes y asi poder realizar comparacaiones entre las diferentes versiones
del codigo. En este caso se agregaron 2 lineas al <div id="cabecera"> de una
plantilla del proyecto

Usando los identificadores de cada commit se pueden comparar las versiones del
software.

$ git branch -v

* desarrollo e6dcbf4 Modificacion de texto de la cabecera
  master     a537ef5 Primer commit
user@debian:~/DIV$ git diff a537ef5 e6dcbf4
diff --git a/principal.html b/principal.html
index 554fd4f..94b3eac 100755
--- a/principal.html
+++ b/principal.html
@@ -14,6 +14,8 @@
 
                <div id="cabecera">
                        CabeceraXXX
+                       CabeceraXXX
+                       CabeceraXXX
                </div>  
 
                <div id="cuerpo1">

Crea una copia local del repositorio se debe situar en la carpeta onde se quiere
hacer la copia y luego se le da la ruta del proyecto a copiar .

$ git clone /home/directorio/proyecto/proyecto

Si esta subido en algun servidor.

$ git clone https://xxx.xxx.gob.ve/xxx/xxx/xxx.git

===========
Recomendado
===========

-Cada desarrollador o equipo de desarrollo puede hacer uso de Git de la forma
que le parezca conveniente. Sin embargo una buena práctica es la siguiente:

Se deben utilizar 4 tipos de ramas: Master, Development, Features, y Hotfix.

-Master: Es la rama principal. Contiene el repositorio que se encuentra
publicado en producción, por lo que debe estar siempre estable.

-Development: Es una rama sacada de master. Es la rama de integración, todas las
nuevas funcionalidades se deben integrar en esta rama. Luego que se realice la
integración y se corrijan los errores (en caso de haber alguno), es decir que la
rama se encuentre estable, se puede hacer un merge de development sobre la rama
master.

-Features: Cada nueva funcionalidad se debe realizar en una rama nueva,
específica para esa funcionalidad. Estas se deben sacar de development. Una vez
que la funcionalidad esté pronta, se hace un merge de la rama sobre development,
donde se integrará con las demás funcionalidades.

-Hotfix: Son bugs que surgen en producción, por lo que se deben arreglar y
publicar de forma urgente. Es por ello, que son ramas sacadas de master. Una vez
corregido el error, se debe hacer un merge de la rama sobre master. Al final,
para que no quede desactualizada, se debe realizar el merge de master sobre
development.

Algo de teoría...

================
¿Qué es un fork?
================

La palabra fork se traduce al castellano, dentro del contexto que nos ocupa,
como bifurcación. Cuando hacemos un fork de un repositorio, se hace una copia
exacta en crudo (en inglés “bare”) del repositorio original que podemos utilizar
como un repositorio git cualquiera. Después de hacer fork tendremos dos
repositorios git idénticos pero con distinta URL. Justo después de hacer el
fork, estos dos repositorios tienen exactamente la misma historia, son una copia
idéntica. Finalizado el proceso, tendremos dos repositorios independientes que
pueden cada uno evolucionar de forma totalmente autónoma. De hecho, los cambios
que se hacen el repositorio original NO se transmiten automáticamente a la copia
(fork). Esto tampoco ocurre a la inversa: las modificaciones que se hagan en la
copia (fork) NO se transmiten automáticamente al repositorio original.

¿Y en qué se diferencia un fork de un clon?

Cuando hacemos un clon de un repositorio, te bajas una copia del mismo a tu
máquina. Empiezas a trabajar, haces modificaciones y haces un push. Cuando haces
el push estás modificando el repositorio que has clonado.

Cuando haces un fork de un repositorio, se crea un nuevo repositorio en tu
cuenta de Github o Bitbucket, con una URL diferente (fork). Acto seguido tienes
que hacer un clon de esa copia sobre la que empiezas a trabajar de forma que
cuando haces push, estás modificando TU COPIA (fork). El repositorio original
sigue intacto. Lo vamos a ver en breve con un ejemplo.

¿Para qué sirve?

Tiene varios usos. El más común es el de permitir a los desarrolladores
contribuir a un proyecto de forma segura.

¿Porqué decimos de forma segura? Imaginaos un super proyecto como puede ser el
código fuente de Apache. ¿Cómo se trabajaba antes de existir git? con Subversion
o CVS existía un servidor centralizado que tenía dos tipos de usuarios: lo que
podían “escribir” en el repositorio (subir cambios al código fuente) y los que
sólo podían “leer” el repositorio. Estos últimos sólo podían bajarse el código a
su máquina y podían modificarlo sólo en su copia local. No podían subir ninguna
modificación al servidor central.

¿Qué tenías que hacer para contribuir? Tenías que solicitar permiso de escritura
y que alguien te lo diese. Una vez te lo concedían, ya podías subir tus
modificaciones y, por supuesto, liarla si no sabías lo que estabas haciendo.
Otra opción era enviar parches, trabajar con ramas… había varias formas pero
todas bastante engorrosas.

Además, este procedimiento de dar acceso de escritura a un repositorio
centralizado es un poco arriesgado. Siguiendo con el ejemplo que he puesto de
Apache ¿cómo sé yo, responsable del repositorio, que esta persona que está a
10000Km de mí en la otra punta del planeta sabe lo que está haciendo? ¿puedo
confiar en él?. Al final, contribuir a un proyecto se convertía en una tarea
tediosa tanto para el que pretendía contribuir como para el que lo tenía que
gestionar. Y no hablemos de lo divertido que era hacer un merge…

Git, al tratarse de un sistema distribuido, resuelve este tipo de problemas de
una forma muy elegante a través de los forks. Digamos que Pepito es una persona
quiere contribuir al proyecto. Ha encontrado un bug y sabe cómo corregirlo. Como
propietario del repositorio me interesa que Pepito pueda enviarme el parche de
forma rápida, que no pierda mucho tiempo. Si es así ¡Pepito estará encantado de
colaborar con nosotros! ;-). Además, necesito que el proceso sea ágil, no quiero
tener que invertir 5 horas de mi tiempo cada vez que tenga que hacer un merge
del trabajo que Pepito me envíe. ¿Cómo resuelve git el problema?

-Pepito hace un fork de mi repositorio, para lo que sólo necesito darle permiso
de lectura.

-Pepito trabaja en SU COPIA (fork) del repositorio. Como es suya, puede hacer lo
que quiera, la puede borrar, corromper, dinamitar, reescribir la historia del
proyecto… nos da lo mismo, es SU COPIA (fork).

-Cuando Pepito termina de programar y testear el parche, me avisa de que ya lo
tiene y me dice “En la rama parche_de_pepito de MI COPIA (fork), tienes el
parche que corrige el Bug XXXX”.

-Yo voy a su repositorio, miro lo que ha hecho y si está bien lo incorporo
(merge) a mi repositorio, que es el original.

Las ventajas de este proceso son las siguientes:

-Pepito trabaja con SU COPIA. En ningún momento le tengo que dar acceso al
repositorio central.

-El proceso de incorporación de los cambios de Pepito es muy sencillo. Si no hay
conflictos en los ficheros puede que sea tan simple como ejecutar un par de
comandos git.

-Pepito tiene muy fácil contribuir, no le cuesta esfuerzo.

-Yo puedo gestionar muy fácilmente las contribuciones de muchas personas ¡me
cuesta muy poco trabajo!

========================
Subir proyectos a GitHub
========================

Repositorio: Un repositorio, depósito o archivo es un sitio centralizado donde
se almacena y mantiene información digital, habitualmente bases de datos o
archivos informáticos.

1- Crearnos una cuenta en GitHub

2- Crear un repositorio, desde la intefáz gráfica de github nos pedirá el nombre
para el repositorio ese repo tendra una URL asignada, ejem:
https://github.com/name_user/name_repo

3- La forma mas rápida de subir un proyecto al repositorio creado es bajando ese
repositorio creado, clonandolo en nuestro directorio, al clonarlo ya viene
configurado con los ficheros de git lo que nos permitira hacer push directamente
sin hacer mayores esfuerzos.

Clonamos el repositorio del proyecto, se guardará en nuestro directorio.

$ git clone https://github.com/name_user/name_repo.git

Clonar directamente una rama específica.

$ git clone -b branch_name https://xxx.xxx.com/xxx/xxx/git/xxx.git

Nos cambiamos a la carpeta del proyecto

$ cd name_repo/

4- Una vez hecho es veremos una carpeta local con el nombre de nuestro
repositorio de GitHub esta carpeta estará vacía, dentro de la carpeta irá el
proyecto que queremos subir. Ahora metemos dentro de la carpeta todos los
directorios y ficehros de nuestro proyecto.

Para agregar todos los archivos que pegamos al seguimiento de git.

$ git add .

Hacemos el primer commit del proyecto, ejemplo: "Primer commit" o "Caga inicial
del proyecto"

$ git commit -m "Comentario"

Este comando es para subir el proyecto directamente a la rama master de nuestro
repo.

$ git push origin master

Cabe mencionar que en el proyecto git descargado, oculta está la carpeta .git,
dentro en el fichero config estará por defecto escrita la URL de nuestro repo,
lo que facilita subir los proyectos y los cambios directamente, por ello el paso
de la clonacion del repo.

Ejemplo de un fichero config:

[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[remote "origin"]
        fetch = +refs/heads/*:refs/remotes/origin/*
        url = https://github.com/user/Project_name.git
[branch "master"]
        remote = origin
        merge = refs/heads/master

-Nota: Podemos añadir este contenido a otro proyecto de git, cambiando el
usuario y el nombre del proyecto, para que apunte al repositorio remoto que se
desee, debe estar creado en github para que no haya problema al hacer el push.

Antes de subir los cambios nos pedira el user y pass de la cuenta github para
realizar la autenticación

user@debian:~/MiProyecto$ git push origin master
Username for 'https://github.com': user
Password for 'https://user@github.com': ************
Counting objects: 14, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (13/13), 45.99 KiB, done.
Total 13 (delta 0), reused 0 (delta 0)
To https://github.com/user/proyecto.git
   af47064..228246e  master -> master

Listo ya deberias porder ver tu proyecto en github

-----

Eliminar una rama en tu GitHub o en tu repositorio remoto.

$ git push origin --delete your_branch

-----

Eliminar una rama, alternativa al anterior.

$ git push origin :your_branch

----

Para borrar o deshacer un commit en github, se debe primero borrar el commit de
manera local, luego volvemos a subir el proyecto con este comando para que quede
como estaba.

$ git push origin +master

----- Inviting collaborators to a personal repository -----

You can invite users to become collaborators on your personal repository.
Tip: You can grant read/write access to collaborators on a personal repository.
Repositories owned by an organization can grant more granular access. For more
information, see "What are the different access permissions?"

Ask for the username of the person you're inviting as a collaborator. If they
don't have a username yet, they can sign up for GitHub.

On GitHub, navigate to the main page of the repository.
Repository settings buttonUnder your repository name, click Settings.
Repository settings sidebar with Collaborators highlightedIn the left sidebar,
click Collaborators.
Under "Collaborators", start typing the collaborator's username.
Select the collaborator's username from the drop-down menu.
Click Add collaborator.
The user will receive an email inviting them to the repository.

Once they accept your invitation, they will have collaborator access to your
repository.

========================
¿Qué es un pull request?
========================

Un pull request es una petición que el propietario de un fork de un repositorio
hace al propietario del repositorio original para que este último incorpore los
commits que están en el fork.

Ejemplo:

-El usuario A crea un repositorio X en github: https://github.com/A/X

-El usuario B crea un fork (bifurcación) para trabajar en él:
https://github.com/B/X

-Los dos usuarios realizan modificaciones cada uno en su repositorio, cada uno
de ellos hace un commit y posteriormente un push. Cada uno sube los cambios a su
correspondiente repositorio.

-El usuario B configura un repositorio remoto adicional (upstream) e incorpora,
haciendo un merge, los cambios en el código que hizo A. Después de hacer el
merge, B hace un push para actualizar su repositorio remoto.

En el caso del ejemplo, el usuario B le enviará la petición a A para que este
último incorpore los commits que tiene en su fork.

=====
Otros
=====

Si un repostirotio git remoto no cuenta con el certificado digital del servidor
a veces se debe saltar chequeo de la firma para bajar las fuentes con este
comando.

$ export GIT_SSL_NO_VERIFY=True

================================
Ejemplo de archivo config de git
================================

[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[remote "origin"]
        url = https://github.com/user/repo_name.git
        fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
        remote = origin
        merge = refs/heads/master

=========
git blame
=========

El comando git blame es una utilidad de resolución de problemas versátil que
cuenta con numerosas opciones de uso. A grandes rasgos, la función de git blame
es visualizar los metadatos de autor adjuntos a líneas específicas confirmadas
en un archivo. Esto sirve para examinar puntos específicos del historial de un
archivo y poner en contexto quién fue el último autor que modificó la línea.
Esto sirve para explorar el historial del código específico y responder
preguntas sobre qué código se ha añadido a un repositorio, cómo se ha añadido y
por qué.

$ git blame ruta/al/archivo.xxx

========================================================
Git archive, Exportación del contenido de un repositorio
========================================================

Git archive nos permite exportar el contenido de nuestro proyecto empaquetándolo
o comprimiéndolo en un solo fichero.

Git archive no sólo nos permitirá exportar una rama deseada sino que también nos
permite seleccionar que directorios o ficheros de esta queremos exportar. Pero
recuerda hacer commit de los cambios o estos no serán exportados.

Hay que tener en cuenta que cuando realizamos una exportación el directorio
.git/ no será incluido.

Formas de uso
=============

Para exportar una rama de nuestro proyecto en formato zip tecleamos el
siguiente comando estando dentro del directorio del proyecto.

$ git archive --format=zip master > project.zip

Fuente
======

https://blog.artegrafico.net/git-archive-exportacion-del-contenido-de-un-repositorio

=========================
Devolver cambio del stage
=========================

Usa "git restore --staged <archivo>..." para sacar del área de stage, ejemplo:

$ git add app/Http/Controllers/UserController.php

Con lo anterior UserController.php está en stage

Ahora lo sacamops de stage con:

$ git restore --staged app/Http/Controllers/UserController.php

-----

Se utiliza en Git para deshacer el último commit y dejar los cambios que se
realizaron en el área de preparación (staging area) sin perderlos. En otras
palabras, este comando deshace el último commit pero mantiene los cambios en un
estado preparado para ser confirmados nuevamente.

$ git reset --soft HEAD~

============================================================================
Hacer push a un repositorio gitlab pasando usuario y contraseña directamente
============================================================================

$ git push https://your-username:your-token@gitlab.com/usuario/repositorio.git master

Ejemplo:

$ git push https://pepeperez:xyz1233212zyx@gitlab.com/pepeperez/mi_repo.git master

Fuente
======

ChatGPT

===============================================================
¿Cuál es la diferencia entre los comandos Git Fetch y Git Pull?
===============================================================

Git pull y fetch son dos comandos que son usados regularmente por los usuarios
de Git. Veamos la diferencia entre ambos comandos.

Por el contexto, vale la pena recordar que probablemente estemos trabajando en
un repositorio clonado. ¿Qué es un clon? Es simplemente un duplicado de otro
repositorio. Básicamente es obtener tu propia copia del código fuente de otra
persona.

Dicho esto, para mantener tu clon actualizado con cualquier cambio que se haya
aplicado al original, necesitarás llevarlos a tu clon.

Ahí es donde entran fetch y pull.

git fetch es el comando que le dice a tu git local que recupere la última
información de los metadatos del original (aunque no hace ninguna transferencia
de archivos. Es más bien como comprobar si hay algún cambio disponible).

git pull por otro lado hace eso Y trae (copia) esos cambios del repositorio
remoto.

Por ejemplo:

$ git pull origin ankur bugfix

Lo que hay que tomar de aquí es tener en cuenta que generalmente hay al menos
tres copias de un proyecto en tu estación de trabajo.

* Una copia es tu propio repositorio con tu propio historial de confirmación (el
ya guardado, por así decirlo).

* La segunda copia es tu copia de trabajo donde estás editando y construyendo
(aún sin realizar commit a tu repositorio).

* La tercera copia es tu copia local "en caché" de un repositorio remoto
(probablemente el original de donde clonaste el tuyo).

Puedes usar git fetch para saber los cambios hechos en el repo/rama remoto desde
tu último pull. Esto es útil para permitir la comprobación antes de hacer un
pull real, lo que podría cambiar los archivos en tu rama actual y en la copia de
trabajo (y potencialmente perder tus cambios, etc.).

$ git fetch

$ git diff ...origin

Fuente
======

https://www.freecodecamp.org/espanol/news/git-fetch-vs-pull-cual-es-la-diferencia-entre-los-comandos-git-fetch-y-git-pull/

===================================================
Traerse rama remota del repositorio remoto al local
===================================================

Para traer la rama "nombre_rama" de tu repositorio remoto a tu repositorio local
puedes seguir estos pasos:

1- Actualiza las referencias de las ramas remotas:

Ejecuta el siguiente comando en tu repositorio local:

$ git fetch origin

Este comando actualizará las referencias de las ramas remotas en tu repositorio
local, lo que significa que Git obtendrá la información más reciente sobre las
ramas de tu repositorio remoto, incluida nombre_rama.

2- Crea la rama local nombre_rama:

Ejecuta el siguiente comando para crear una rama local llamada nombre_rama que
rastrea la rama remota origin/nombre_rama:

$ git checkout -b nombre_rama origin/nombre_rama

Este comando creará una nueva rama local llamada nombre_rama y te cambiará a
ella. También establecerá un enlace de seguimiento entre la rama local
nombre_rama y la rama remota origin/nombre_rama. Esto significa que, en el
futuro, cuando ejecutes git fetch, los cambios realizados en la rama remota
origin/nombre_rama se fusionarán automáticamente con tu rama local nombre_rama.

Fuente
======

Gemini IA
